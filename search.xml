<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>EC+AV(VO)+Scope Chain</title>
    <url>/2021/05/29/EC-AV-VO-Scope-Chain/</url>
    <content><![CDATA[<h2 id="EC、ECS、VO、AO、Scope-Chain"><a href="#EC、ECS、VO、AO、Scope-Chain" class="headerlink" title="EC、ECS、VO、AO、Scope Chain"></a>EC、ECS、VO、AO、Scope Chain</h2><p>题目：</p>
<pre><code class="javascript">var a = 1, b = 2;
function fn() {
    var a = 100, b = 200
    console.log(a + b)
}
fn()
</code></pre>
<p>一道很常见的 javascript 题目，输出<code>300</code>。</p>
<p>从这道题一出发，捋一遍 EC、ECS、VO、AO、Scope Chain 相关知识点。</p>
<h3 id="EC"><a href="#EC" class="headerlink" title="EC"></a>EC</h3><p>执行上下文（Execution Context），也叫执行环境。</p>
<p>在《javascript高级程序设计》中的定义：</p>
<blockquote>
<p>定义了变量或函数有权访问的其他数据，决定了它们各自的行为。</p>
</blockquote>
<p>即：EC 决定了当前代码对其他变量或函数的访问权限。</p>
<p>javascript 中会维护一个<code>执行上下文栈 ECS（Execution Context Stack）</code>。</p>
<ul>
<li>栈底是全局上下文（Global Context）；</li>
<li>当一个函数执行的时候，会将当前函数的 EC push 进 ECS，函数执行结束 pop 出 ECS。</li>
</ul>
<p><code>EC</code> 主要包含三个成员：</p>
<ul>
<li><code>VO</code>：变量对象</li>
<li><code>Scope Chain</code>：作用域链</li>
<li><code>this</code></li>
</ul>
<h3 id="VO"><a href="#VO" class="headerlink" title="VO"></a>VO</h3><p>变量对象（Variable Object）</p>
<p>作用：</p>
<ul>
<li>保存 EC 的作用域链</li>
<li>保存 EC 的 arguments 和变量</li>
</ul>
<p>可以理解为数据作用域。</p>
<p>当函数执行的时候，进入函数的 EC，VO 激活为活动对象 AO。当函数开始执行前，VO 进行初始化，包括 arguments 和内部的变量；当函数真正执行代码会将修改 VO 中的 arguments 和内部的变量。</p>
<p>比如上面的题目：</p>
<pre><code class="javascript">var a = 1, b = 2;
function fn() {
    var a = 100, b = 200;
    console.log(a + b)
}
fn()
</code></pre>
<p>函数 fn 在开始执行前，会初始化 VO 的 arguments 和内部的变量。如下：</p>
<pre><code class="javascript">const fnVO = {
    arguments: {
        length: 0
    },
    a: undefined,
    b: undefined
}
</code></pre>
<p>当函数开始执行，修改 VO 的 arguments 和内部的变量。如下：</p>
<pre><code class="javascript">const fnVO = {
    arguments: {
        length: 0
    },
    a: 100,
    b: 200
}
</code></pre>
<h3 id="Scope-Chain"><a href="#Scope-Chain" class="headerlink" title="Scope Chain"></a>Scope Chain</h3><p>作用域链。</p>
<p>在《javascript高级程序设计》中的解释：</p>
<blockquote>
<p>作用域链的用途，是保证对执行环境有权访问的所有变量和函数的有序访问。作用域链的前端，始终都是当前执行的代码所在环境的变量对象。</p>
</blockquote>
<p>当在 EC 中查找一个变量，会先在当前作用域中进行查找，查找不到就向父级作用域查找，如此循环，直到找到为止；如果找不到，就返回 undefined。</p>
<p>在作用域链的最外级，是全局作用域 <code>Global Context</code>    。</p>
<p>当函数创建的时候，函数内部有个属性 <code>[[scope]]</code>保存父级 EC 的作用域链；当函数开始执行，先创建函数的 EC，推入 ECS；然后将<code>[[scope]]</code>保存的作用域复制到 EC 中进行保存，接着初始化 VO 的 arguments 和变量，最后将当前 VO 添加到保存的作用域最前端，这样就形成了作用域链。</p>
<h3 id="题目流程"><a href="#题目流程" class="headerlink" title="题目流程"></a>题目流程</h3><p>结合 EC、ECS、VO、AO、Scope Chain，解析题目。</p>
<pre><code class="javascript">var a = 1, b = 2;
function fn() {
    var a = 100, b = 200;
    console.log(a + b)
}
fn()
</code></pre>
<p>流程为：</p>
<ul>
<li>函数创建的时候，函数的内部属性<code>[[scope]]</code>会保存外部 EC 的作用域链；</li>
</ul>
<pre><code class="javascript">fn.[[scope]] = [
    GlobalContext.VO
]
</code></pre>
<ul>
<li>函数开始执行前，先创建函数的 EC，推入 ECS；</li>
</ul>
<pre><code class="javascript">ECStack = [
    fnContext,
    globalContext
];
</code></pre>
<ul>
<li>将<code>[[scope]]</code>保存的作用域复制到函数执行上下文 EC 中进行保存；</li>
</ul>
<pre><code class="javascript">const fnContext = {
    Scope: fn.[[scope]]
}
</code></pre>
<ul>
<li>初始化函数 VO 的 arguments 和变量；</li>
</ul>
<pre><code class="javascript">const fnContext = {
    Scope: fn.[[scope]],
    fnVO: {
        arguments: {
            length: 0
        },
        a: undefined,
        b: undefined
    }
}

</code></pre>
<ul>
<li>将函数的 VO 添加到作用域的前端；</li>
</ul>
<pre><code class="javascript">const fnContext = {
    Scope: [fnVO, [[Scope]]],
    fnVO: {
        arguments: {
            length: 0
        },
        a: undefined,
        b: undefined
    }
}

</code></pre>
<ul>
<li>函数执行，修改 VO 对象；</li>
</ul>
<pre><code class="javascript">const fnContext = {
    Scope: [fnVO, [[Scope]]],
    fnVO: {
        arguments: {
            length: 0
        },
        a: 100,
        b: 200
    }
}

</code></pre>
<ul>
<li>函数执行结束， EC 出 ECS。</li>
</ul>
<pre><code class="javascript">ECStack = [
    globalContext
];

</code></pre>
<hr>
<p>参考链接：</p>
<ul>
<li><a href="https://github.com/mqyqingfeng/Blog/issues/7" target="_blank" rel="noopener">https://github.com/mqyqingfeng/Blog/issues/7</a></li>
<li><a href="https://javascript.info/reference-type" target="_blank" rel="noopener">https://javascript.info/reference-type</a></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>搭建组件库</title>
    <url>/2021/04/10/%E6%90%AD%E5%BB%BA%E7%BB%84%E4%BB%B6%E5%BA%93/</url>
    <content><![CDATA[<h1 id="搭建组件库"><a href="#搭建组件库" class="headerlink" title="搭建组件库"></a>搭建组件库</h1><p>利用 webpack，通过入口将所有的组件模块导入并且注册，然后通过生成一个 bundle.js 文件即可。</p>
<h2 id="创建-vue-项目"><a href="#创建-vue-项目" class="headerlink" title="创建 vue 项目"></a>创建 vue 项目</h2><p>创建 vue 项目，除了 vue 项目自带的文件目录外，在根目录下添加以下目录结构： </p>
<pre><code class="txt">└───build 目录：主要存放 webpack 相关配置
|     └───webpack.biuld.config.js // 打包生成组件库 webpack 配置
|───lib 目录：打包生成的 bundle.js 目录
|     └───bundle.js // 打包生成的 bundle
|───packages
|   └───index.js // 注册所有组件脚本文件
|     └───组件名称 1
|         └───src
|             └───index.vue // 组件源码
|         └───index.js // 单个组件注册
|     └───组件名称 2
|         └───src
|             └───index.vue // 组件源码
|         └───index.js // 单个组件注册
|     └───组件名称 n
|     └───...
</code></pre>
<h2 id="添加生成组件库-webpack-配置"><a href="#添加生成组件库-webpack-配置" class="headerlink" title="添加生成组件库 webpack 配置"></a>添加生成组件库 webpack 配置</h2><p>配置目录：<code>build/webpack.biuld.config.js</code></p>
<h3 id="entry"><a href="#entry" class="headerlink" title="entry"></a>entry</h3><p>入口作用：入口将所有的组件模块导入并且注册。</p>
<pre><code class="javascript">entry: {
    xx: path.resolve(__dirname, &#39;../packages/index.js&#39;),
}
</code></pre>
<h3 id="output"><a href="#output" class="headerlink" title="output"></a>output</h3><pre><code class="javascript">output: {
    path: path.resolve(__dirname, &#39;../lib&#39;),
    publicPath: &#39;/lib/&#39;,
    library: &#39;xx&#39;, // 包名
    libraryTarget: &#39;umd&#39;,
    umdNamedDefine: true,
}
</code></pre>
<p>其中，<a href="https://webpack.docschina.org/configuration/output/#outputlibrarytarget" target="_blank" rel="noopener">libraryTarget</a> 采用 umd 格式。</p>
<blockquote>
<p>打包后的 library 暴露为所有的模块定义下都可运行的方式。它将在 CommonJS, AMD 环境下运行，或将模块导出到 global 下的变量。</p>
</blockquote>
<h3 id="loader"><a href="#loader" class="headerlink" title="loader"></a>loader</h3><p>babel-loader（@babel/preset-env、@babel/transform-runtime、dynamic-import-webpack）、vue-loader、css-loader、postcss-loader、sass-loader、url-loader。</p>
<p>静态资源如图片等统一转化成 base64，后面统一使用 iconfont 的方式使用图标。</p>
<pre><code class="javascript">module: {
    rules: [
        {
            test: /\.(png|jpe?g|gif|svg|ttf|woff|woff2|eot)$/i,
            use: [
                {
                    loader: &#39;url-loader&#39;,
                    options: {
                        limit: 10240000,
                        name: &#39;static/[name].[hash:6].[ext]&#39;,
                        esModule: false, // https://webpack.docschina.org/loaders/url-loader/#esmodule
                    },
                },
            ],
        },
        {
            test: /\.css$/i,
            use: [
                // 将 JS 字符串生成为 style 节点
                &#39;style-loader&#39;,
                // 将 CSS 转化成 CommonJS 模块
                &#39;css-loader&#39;,
            ],
        },
        {
            test: /\.s[ac]ss$/i,
            use: [
                // 将 JS 字符串生成为 style 节点
                &#39;style-loader&#39;,
                // 将 CSS 转化成 CommonJS 模块
                &#39;css-loader&#39;,
                // 将 Sass 编译成 CSS
                &#39;sass-loader&#39;,
            ],
        },
        {
            test: /\.js$/,
            loader: &#39;babel-loader&#39;,
            exclude: /node_modules/,
        },
        {
            test: /\.vue$/,
            loader: &#39;vue-loader&#39;,
        },
    ],
}
</code></pre>
<h3 id="plugins"><a href="#plugins" class="headerlink" title="plugins"></a>plugins</h3><p>vue-loader</p>
<pre><code class="javascript">plugins: [
    new VueLoaderPlugin(),
    new webpack.LoaderOptionsPlugin({
        options: {
            errorDetails: true,
        },
    }),
],
</code></pre>
<h3 id="externals"><a href="#externals" class="headerlink" title="externals"></a>externals</h3><p><a href="https://webpack.docschina.org/configuration/externals/" target="_blank" rel="noopener">externals 文档链接</a></p>
<blockquote>
<p><strong>防止</strong>将某些 <code>import</code> 的包(package)<strong>打包</strong>到 bundle 中，而是在运行时(runtime)再去从外部获取这些<em>扩展依赖(external dependencies)</em>。</p>
</blockquote>
<p>由于是封装组件库，有使用到如 element-ui 等第三方依赖，所以不需要再对第三方依赖包进行打包。在安装私有库的时候，会自动安装第三方依赖。</p>
<pre><code class="javascript">externals: [
    {
        vue: {
            root: &#39;Vue&#39;,
            commonjs: &#39;vue&#39;,
            commonjs2: &#39;vue&#39;,
            amd: &#39;vue&#39;,
        },
        lodash: {
            root: &#39;lodash&#39;,
            commonjs: &#39;lodash&#39;,
            commonjs2: &#39;lodash&#39;,
            amd: &#39;lodash&#39;,
        },
        // &#39;element-ui&#39;: &#39;element-ui&#39;,
        vuedraggable: &#39;vuedraggable&#39;,
    },
    /element-ui[\s\S]+/ig,
]
</code></pre>
<h2 id="修改-package-json-入口"><a href="#修改-package-json-入口" class="headerlink" title="修改 package.json 入口"></a>修改 package.json 入口</h2><p>package.json 入口指向打包好的 bundle.js</p>
<pre><code class="txt">{
    // ...
    &quot;main&quot;: &quot;lib/xx.js&quot;
}
</code></pre>
<h2 id="发布"><a href="#发布" class="headerlink" title="发布"></a>发布</h2><h3 id="npm-发布"><a href="#npm-发布" class="headerlink" title="npm 发布"></a>npm 发布</h3><p>通过 npm publish 发布到 npm 上，使用的时候通过 <code>npm i xx</code> 即可。</p>
<h3 id="放到个人-gitlab-github"><a href="#放到个人-gitlab-github" class="headerlink" title="放到个人 gitlab / github"></a>放到个人 gitlab / github</h3><p>使用的时候，添加依赖到 package.json 中：</p>
<pre><code class="txt">&quot;xxx&quot;: &quot;git+https://xxxxx.git&quot;,
</code></pre>
<p>删除 node_modules，重新安装依赖即可。</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化搭建平台（四）- 优化</title>
    <url>/2021/04/10/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0%EF%BC%88%E5%9B%9B%EF%BC%89-%E4%BC%98%E5%8C%96/</url>
    <content><![CDATA[<h2 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h2><p><img src="https://i.loli.net/2021/04/07/3bTfUoiZunrGFed.png" alt="image.png"></p>
<p>痛点：右侧样式组件有很多相同的样式，如：margin、padding 等。这样每次都重复开发相同样式，不仅浪费时间和精力，而且代码量也会大大增多。</p>
<h2 id="解决方案"><a href="#解决方案" class="headerlink" title="解决方案"></a>解决方案</h2><p>解决方案：将多个样式抽离成单一样式组件。（一个组件对应一个样式）</p>
<p>有两种使用方式：</p>
<ul>
<li>常规方式：将单一组件当作普通组件使用，需要用到该样式的组件独自 import。</li>
<li>可配置方式：将用到的样式通过配置方式进行组装成包含多种样式的样式聚合组件。</li>
</ul>
<p>之前的流程：</p>
<p><img src="https://i.loli.net/2021/03/27/X2rnp8xLQRBjlgb.png" alt="image.png"></p>
<p>现在的流程：</p>
<p><img src="https://i.loli.net/2021/04/07/lETSNrIJ5Hci8xk.png" alt="image.png"></p>
<p>在页面预览区域点击组件后，右侧样式修改组件多加一层处理逻辑，添加一个 <code>&lt;styleCollection /&gt;</code> 组件对各个单一样式进行聚合和数据派发。</p>
<p>当单一样式组件内部样式更改后，向样式聚合组件 <code>&lt;styleCollection /&gt;</code> 组件派发 <code>changeStyleItem</code> 事件，然后样式聚合组件 <code>&lt;styleCollection /&gt;</code> 组件再向上派发事件 <code>changeStyle</code> 事件。</p>
<h2 id="数据格式"><a href="#数据格式" class="headerlink" title="数据格式"></a>数据格式</h2><p>之前外部传入基本数据信息 data 格式：</p>
<pre><code class="txt">[
    {
        component, // 渲染组件
        styleComponent, // 渲染组件对应修改样式的组件
        dynamicStyle, // 组件样式 props
    },
    {
         // ...       
    }
]
</code></pre>
<p>更改为：</p>
<pre><code>[
    {
        component, // 渲染组件
        styleComponent, // 渲染组件对应修改样式的单一组件列表
        dynamicStyle, // 组件样式 props
        customSingleStyles, // 自定义单一组件 map
    },
    {
         // ...       
    }
]
</code></pre><ul>
<li>更改 styleComponent 数据格式</li>
<li>新增 customSingleStyles 属性</li>
</ul>
<h3 id="styleComponent"><a href="#styleComponent" class="headerlink" title="styleComponent"></a>styleComponent</h3><p>兼容旧的逻辑，仍然可以传入一整个样式修改组件。</p>
<p>新的格式为：</p>
<pre><code class="txt">styleComponent: {
    component, // 单一样式组件名
    label, // label 名
    name, // dynamicStyle 中对应的对象属性名
}
</code></pre>
<p>之所以这么设计，是考虑到单一组件复用的情况。如：一个 Color 组件，可能同时拥有背景色 backgroundColor 和文本颜色 Color。那么外部传入基本数据信息 data 格式为：</p>
<pre><code class="txt">[
    {
        component: &#39;Color&#39;,
        label: &#39;Background Color&#39;,
        name: &#39;backgroundColor&#39;,
    },
    {
        component: &#39;Color&#39;,
        label: &#39;Text Color&#39;,
        name: &#39;color&#39;,
    }
]
</code></pre>
<h3 id="customSingleStyles"><a href="#customSingleStyles" class="headerlink" title="customSingleStyles"></a>customSingleStyles</h3><p>该属性为拓展除了框架提供的单一样式组件，自定义的单一样式组件数据。</p>
<p>数据格式为：</p>
<pre><code class="txt">{
    componentName: Component // 组件名： 样式组件
}
</code></pre>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>可视化搭建平台</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化搭建平台（三）- 打包</title>
    <url>/2021/03/28/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E6%89%93%E5%8C%85/</url>
    <content><![CDATA[<p> 通过生成的 jsonData，可以拿到页面的基本信息 pageInfo，如：背景色、title等，还有页面布局 layout。主要处理两个问题：</p>
<ul>
<li>通过 jsonData 数据实现页面渲染；</li>
<li>打包生成 html。</li>
</ul>
<h2 id="打包目录结构"><a href="#打包目录结构" class="headerlink" title="打包目录结构"></a>打包目录结构</h2><pre><code class="txt">└───build 目录：主要存放 webpack 相关配置
|     └───static.js // 封装 webpack.run() 方法
|     └───webpack.base.config.js // webpack 基本配置
|───src
|     └───App.vue // server 端入口
|     └───main.js // client 端入口
|     └──index.tpl.html // 页面模板
|     └───components.js // 组件引进注册
|───create-html
|     └───待页面名称 目录
|         └───config.js // webpack 发布相关配置
|         └───data.js // jsonData 获取相关逻辑
|───html 目录：打包输出
|     └───static 目录：静态资源目录
|         └───...
|     └──待页面名称.html // 输出的页面
|───index.js // 打包入口文件
</code></pre>
<h2 id="打包相关"><a href="#打包相关" class="headerlink" title="打包相关"></a>打包相关</h2><h3 id="webpack-公共基本配置-webpack-base-config-js"><a href="#webpack-公共基本配置-webpack-base-config-js" class="headerlink" title="webpack 公共基本配置 - webpack.base.config.js"></a>webpack 公共基本配置 - webpack.base.config.js</h3><p>用到的 webpack 插件有：vue-loader、optimize-css-assets-webpack-plugin、html-webpack-plugin、html-webpack-inline-source-plugin、ptimize-css-assets-webpack-plugin、babel-loader等。</p>
<p>常规的 webpack 配置跳过，说下 plugins 配置：</p>
<pre><code class="javascript"> plugins(type) {
     const common = [
         new VueLoaderPlugin(),
         new MiniCssExtractPlugin({
             filename: &#39;[name].[contenthash:6].css&#39;,
             chunkFilename: &#39;[id].[contenthash:6].css&#39;,
         }),
         new OptimizeCssAssetsWebpackPlugin(),
     ]
     const onDemand = {
         server: [],
         client: [
             new HtmlWebpackPlugin({
                 filename: &#39;index.template.html&#39;,
                 template: path.resolve(__dirname, &#39;../src/index.tpl.html&#39;),
                 inlineSource: &#39;.css$&#39;,
                 minify: {
                     collapseWhitespace: true,
                 },
             }),
             new OptimizeCSSAssetsPlugin({}),
             new HtmlWebpackInlineSourcePlugin(),
         ],
     }
     return [].concat(common).concat(onDemand[type] || [])
 },
</code></pre>
<p>这通过传入 type 类型判断，判断是 client 端还是 server 端。公共需要的是 vue-loader，但 client 需要的是 html-webpack-plugin。</p>
<h3 id="client-webpack-配置"><a href="#client-webpack-配置" class="headerlink" title="client webpack 配置"></a>client webpack 配置</h3><p>除了 webpack.base.config.js 公共配置，client 的 webpack 需要配置的有：entry、output、端判断变量等。</p>
<pre><code class="javascript">const clientWebpackConfig = {
    ...webpackBaseConfig,
    mode,
    entry: path.resolve(__dirname, &#39;./src/main.js&#39;),
    output: {
        path: path.resolve(__dirname, &#39;.&#39;, publishConfig.outputPath),
        filename: &#39;[name].[contenthash:8].js&#39;,
        publicPath: publishConfig.publicPath,
    },
    plugins: [
        ...webpackBaseConfig.plugins(&#39;client&#39;),
        new webpack.DefinePlugin({
            &#39;process.env&#39;: JSON.stringify({
                IS_SERVER: false,
            }),
        }),
    ],
}
</code></pre>
<h3 id="server-webpack-配置"><a href="#server-webpack-配置" class="headerlink" title="server webpack 配置"></a>server webpack 配置</h3><p>除了 webpack.base.config.js 公共配置，server 的 webpack 需要配置的有：entry、output、端判断变量等。</p>
<pre><code class="javascript">const serverWebpackConfig = {
    ...webpackBaseConfig,
    mode,
    entry: {
        app: path.resolve(__dirname, &#39;./src/App.vue&#39;),
    },
    output: {
        path: path.resolve(__dirname, &#39;.&#39;, publishConfig.outputPath),
        libraryTarget: &#39;commonjs&#39;,
        publicPath: publishConfig.publicPath,
    },
    plugins: [
        ...webpackBaseConfig.plugins(&#39;server&#39;),
        new webpack.DefinePlugin({
            &#39;process.env&#39;: JSON.stringify({
                IS_SERVER: true,
            }),
        }),
    ],
}
</code></pre>
<h2 id="static-js-webpack-run-封装"><a href="#static-js-webpack-run-封装" class="headerlink" title="static.js - webpack.run 封装"></a>static.js - webpack.run 封装</h2><p>这里封装要给 Static 类，输入 webpack 配置，输出打包好的 bundle。</p>
<pre><code class="javascript">const webpack = require(&#39;webpack&#39;)

class Static {
  constructor(options) {
    this.options = options
  }

  run() {
    const webpacks = []
    Object.keys(this.options).forEach((k) =&gt; {
      webpacks.push(webpack(this.options[k]))
    })
    return Promise.all(
      webpacks.map(
        (web) =&gt;
          new Promise((reslove) =&gt; {
            web.run((err, stats) =&gt; {
              reslove()
            })
          })
      )
    )
  }
}

module.exports = {
  Static,
}
</code></pre>
<h2 id="server-入口-渲染生成页面"><a href="#server-入口-渲染生成页面" class="headerlink" title="server 入口 - 渲染生成页面"></a>server 入口 - 渲染生成页面</h2><p>通过封装一个入口组件 App.vue，将 jsonData 通过 props 传入，然后通过 js 引进相关的渲染组件，最后通过 <code>v-for</code> 配合动态组件<code>&lt;component :is=&quot;&quot; /&gt;</code>可以实现 组件渲染。</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;h5-page&quot; :style=&quot;pageStyle&quot;&gt;
    &lt;div class=&quot;layout-item&quot; v-for=&quot;(item, index) in layout&quot; :key=&quot;index&quot;&gt;
      &lt;component :is=&quot;item.component&quot; :dynamicStyle=&quot;item.config&quot;&gt;&lt;/component&gt;
    &lt;/div&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
import components from &quot;./components.js&quot;;
export default {
  name: &quot;H5Page&quot;,
  components: components,
  props: {
    pageConfig: {
      type: Object,
      default: () =&gt; [],
    },
  },
  data() {
    return {
      layout: [],
    };
  },
  computed: {
    pageStyle() {
      return {
        backgroundColor:
          this.$props.pageConfig.pageInfo.backgroundColor || &quot;#fff&quot;,
      };
    },
  },
  created() {
    this.bindComponent();
  },
  methods: {
    /**
     * 给每个布局绑定唯一组件
     */
    bindComponent() {
      if (!Object.keys(components).length) {
        return;
      }
      // 给 layout 绑定对应组件
      const layout = this.$props.pageConfig.layout || [];
      if (!layout.length) {
        return;
      }
      layout.forEach((item) =&gt; {
        item.component = components[item.type];
      });
      this.layout = layout;
    },
  },
};
&lt;/script&gt;

&lt;style lang=&quot;scss&quot;&gt;
.h5-page {
  width: 100vw;
}
&lt;/style&gt;
</code></pre>
<p>这里将组件注入单独抽离，后期有新的组件使用，改动 components.js 即可。</p>
<pre><code class="javascript">/************************ 组件注册 ************************/

if (!process.env.IS_SERVER) {
  // 解决：UnhandledPromiseRejectionWarning: ReferenceError: window is not defined 问题
  const H5Editor = require(&#39;h5-editor&#39;)

  module.exports = {
    EdText: H5Editor.default.EdText,
    EdImage: H5Editor.default.EdImage
  }
}

</code></pre>
<p>注意：上面有一个全局变量（通过 webpack.DefinePlugin 插件注入变量）判断是服务端还是客户端的判断，因为打包使用的是<a href="https://ssr.vuejs.org/zh/api/" target="_blank" rel="noopener">vue-server-renderer</a>相关逻辑。故：存在两个端，client 和 server，server 端没有 window、document 等对象。</p>
<h2 id="client-入口-注入全局数据-window-initData"><a href="#client-入口-注入全局数据-window-initData" class="headerlink" title="client 入口 - 注入全局数据 window.__initData__"></a>client 入口 - 注入全局数据 window.__initData__</h2><p>主要做两件事：</p>
<ul>
<li>挂载 Vue 实例到目标节点；</li>
<li>注入全局 window.__ininData__</li>
</ul>
<pre><code class="javascript">import Vue from &#39;vue&#39;
import App from &#39;./App.vue&#39;

let props = {}
if (window.__initData__) {
  props = { pageConfig: window.__initData__.pageConfig }
}

new Vue({
  components: { App: App },
  render: (h) =&gt; h(&#39;App&#39;, { props }),
}).$mount(&#39;#app&#39;)

</code></pre>
<h3 id="页面-html-模板"><a href="#页面-html-模板" class="headerlink" title="页面 html 模板"></a>页面 html 模板</h3><pre><code class="html">&lt;!DOCTYPE html&gt;
&lt;html style=&quot;font-size:100px;&quot;&gt;

&lt;head&gt;
  &lt;title&gt;{{ title }}&lt;/title&gt;
  &lt;meta charset=&quot;utf-8&quot;&gt;
  &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt;
  &lt;meta name=&quot;viewport&quot;
    content=&quot;width=device-width,initial-scale=1.0,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,minimal-ui&quot;&gt;
  &lt;meta name=&quot;description&quot; content=&quot;{{description}}&quot; /&gt;
&lt;/head&gt;

&lt;body style=&quot;font-size: 16px&quot;&gt;
  &lt;div id=&quot;app&quot;&gt;
    &lt;!--vue-ssr-outlet--&gt;
  &lt;/div&gt;
  &lt;script&gt;
    {{{ script }}}
  &lt;/script&gt;
&lt;/body&gt;

&lt;/html&gt;
</code></pre>
<h2 id="index-js-构建"><a href="#index-js-构建" class="headerlink" title="index.js - 构建"></a>index.js - 构建</h2><p>打包使用的是<a href="https://ssr.vuejs.org/zh/api/" target="_blank" rel="noopener">vue-server-renderer</a>相关逻辑。</p>
<p>主要做几件事：</p>
<ul>
<li>通过 webpack 打包输出 templateHtml 和 bundle.js（还没有注入页面数据 window.__initData__）</li>
</ul>
<pre><code class="javascript"> const compiler = new Static({
    app: appWebpackConfig,
    client: clientWebpackConfig,
  })
  await compiler.run()
</code></pre>
<ul>
<li>通过 <code>vue-server-renderer</code>结合 templateHtml 和 bundle.js 生成 renderer 对象</li>
</ul>
<pre><code class="javascript">const renderer = require(&#39;vue-server-renderer&#39;).createRenderer({
    template: fs.readFileSync(&#39;./html/static/index.template.html&#39;, &#39;utf-8&#39;),
})
const main = require(path.resolve(
    __dirname,
    `./${publishConfig.outputPath}/app.js`
))
</code></pre>
<ul>
<li>通过 <code>/create-html/待打包页面名/data.js</code>脚本获取 jsonData 数据</li>
<li>将 jsonData 相关数据通过 context，注入到模板页面中</li>
</ul>
<pre><code class="javascript">const pageConfigData = await dataHandler()
const { title = &#39;&#39;, description = &#39;&#39; } = pageConfigData.pageInfo
const context = {
    title,
    description,
    script: `window.__initData__=${JSON.stringify({
        pageConfig: pageConfigData,
    })}`,
}
const app = new Vue({
    data: {},
    components: { App: main.default },
    render: (h) =&gt; h(&#39;App&#39;, { props: { pageConfig: pageConfigData } }),
})
</code></pre>
<ul>
<li>通过 renderer 对象输出 html 并写入到目标目录下。</li>
</ul>
<pre><code class="javascript">renderer.renderToString(app, context, (err, html) =&gt; {
    if (!html) {
        return
    }
    const filePath = path.resolve(__dirname, `${publishConfig.filePath}`)
    fse.ensureDirSync(filePath)
    // name 为 nodejs 命令行参数：待打包页面名称
    fs.writeFile(`${filePath}/${name}.html`, html, function(err) {
        if (err) {
            console.error(`&gt;&gt;&gt;&gt; 生成 ${name} 页面失败!`, err)
            return
        }
        console.log(
            `${publishConfig.filePath}/${name}.html` + &#39;:数据写入成功！&#39;
        )
    })
})
</code></pre>
<p>over~</p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>可视化搭建平台</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化搭建平台（二）- 实现</title>
    <url>/2021/03/28/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AE%9E%E7%8E%B0/</url>
    <content><![CDATA[<p>页面效果：</p>
<p><img src="https://i.loli.net/2021/03/28/eZxB8cI6DSN25ly.gif" alt="h5_editor.gif"></p>
<p>主要解决两个问题：</p>
<ul>
<li>组件的拖拽；</li>
<li>渲染组件 component 和样式修改组件 styleComponent 数据流转问题。</li>
</ul>
<h2 id="组件的拖拽和克隆"><a href="#组件的拖拽和克隆" class="headerlink" title="组件的拖拽和克隆"></a>组件的拖拽和克隆</h2><p>组件拖拽这里使用到的是这个基于 <a href="https://github.com/SortableJS/Sortable" target="_blank" rel="noopener">sortable.js</a>，使用 Vue 进行封装的组件 <a href="https://github.com/SortableJS/Vue.Draggable" target="_blank" rel="noopener">Vue.Draggable</a>。具体使用官方文档和相关例子都很详细。</p>
<p>主要使用两个功能：</p>
<ul>
<li>拖拽：更改页面布局</li>
<li>克隆：将左边渲染组件列表中的组件拖拽克隆到中间页面预览区域</li>
</ul>
<h3 id="拖拽"><a href="#拖拽" class="headerlink" title="拖拽"></a>拖拽</h3><p>h5-editor 组件使用方式：</p>
<pre><code class="vue">&lt;h5-editor v-model=&quot;jsonData&quot; :data=&quot;data&quot;&gt;&lt;/h5-editor&gt;
</code></pre>
<pre><code class="vue">&lt;template&gt;
    &lt;draggable
        class=&quot;dragArea list-group&quot;
        v-model=&quot;layout&quot;
        tag=&quot;div&quot;
        v-bind=&quot;dragOptions&quot;
        @start=&quot;startDragLayout&quot;
        @end=&quot;finishDragLayout&quot;
        group=&quot;preview&quot;
        &gt;
        &lt;div v-for=&quot;(element, index) in layout&quot; :key=&quot;index&quot;&gt;
            // ...
            &lt;component :is=&quot;element.component&quot; :dynamicStyle=&quot;element.dynamicStyle&quot;&gt;&lt;/component&gt;
        &lt;/div&gt;   
    &lt;/draggable&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
    model: {
        prop: &quot;jsonData&quot;,
        event: &quot;changePageInfo&quot;,
     },
    props: {
        // 页面初始化数据
        data: {
            type: Array,
            default: () =&gt; [],
        },
    },
    data() {
        return {
            layout: []   
        }
    },
    computed: {
        // 主要是定义一些属性
        dragOptions() {
            return {
                animation: 200, // 动画执行时间
                group: &quot;preview&quot;, // 这个 group  的作用是，设置渲染区域的 group 和左边组件列表的 group 相同，在同一 group 中，即可进行克隆
                disabled: false,
                ghostClass: &quot;ghost&quot;, // 组件拖动还未放下的样式
            };
        },
    },
    // ... 其他实现细节忽略
    watch: {
        // ...
    }
}
&lt;/script&gt;

</code></pre>
<p>实现 v-model，监听 layout 是否变更，然后派发 changePageInfo 事件即可实现 v-model。</p>
<p><code>&lt;draggable&gt;&lt;/draggable&gt;</code> 标签是 <a href="https://github.com/SortableJS/Vue.Draggable" target="_blank" rel="noopener">Vue.Draggable</a> 封装好的组件，只要把我们的布局数组 layout 跟内部进行判定，即可实现拖拽和 layout 数据更新。</p>
<p>而<code>&lt;draggable&gt;&lt;/draggable&gt;</code>标签内部通过一个 <code>v-for</code>循环包裹，结合 Vue 动态组件 <code>&lt;component :is=&quot;&quot; /&gt;</code> 即可实现组件的展示。 </p>
<p>注：<code>@start</code>、<code>@end</code>等事件的绑定，函数的参数里面有新旧索引等重要信息可利用。</p>
<h3 id="克隆"><a href="#克隆" class="headerlink" title="克隆"></a>克隆</h3><p>h5-editor 组件使用方式：</p>
<pre><code class="vue">&lt;h5-editor v-model=&quot;jsonData&quot; :data=&quot;data&quot;&gt;&lt;/h5-editor&gt;
</code></pre>
<pre><code class="vue">&lt;draggable
    class=&quot;all-coms__box dragArea list-group&quot;
    :list=&quot;baseComponentsData&quot;
    :group=&quot;{ name: &#39;preview&#39;, pull: &#39;clone&#39;, put: false }&quot;
    :clone=&quot;clone&quot;
    :sort=&quot;false&quot;
    @end=&quot;finishClone&quot;
&gt;
&lt;/draggable&gt;
</code></pre>
<p>克隆组件跟拖拽组件多了两个设置属性：</p>
<ul>
<li>group：设置组别，组别跟预览区域的组别一样，都是 preview；</li>
<li>sort：禁止自身列表重新排序。</li>
</ul>
<h2 id="显示对应的样式修改组件"><a href="#显示对应的样式修改组件" class="headerlink" title="显示对应的样式修改组件"></a>显示对应的样式修改组件</h2><p>在中间预览区域点击一个组件后，右边样式修改区域会显示对应的组件。这个逻辑实现比较简单，因为每个组件都有对应的索引，通过对应索引显示对应组件即可，结合 Vue 动态组件 <code>&lt;component :is=&quot;&quot; /&gt;</code> 即可实现组件的展示。 </p>
<h2 id="修改对应的渲染组件样式"><a href="#修改对应的渲染组件样式" class="headerlink" title="修改对应的渲染组件样式"></a>修改对应的渲染组件样式</h2><p>当样式修改组件向上派发事件 changeStyle，父组件 h5-editor 就可以监听到事件触发和携带新的样式对象，然后通过修改 layout 对应索引的 dynamicStyle 属性值（<code>$set()</code>触发），即可修改对应渲染组件样式。</p>
<p><a href="https://ertsul.com/2021/03/28/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%89%EF%BC%89-%E6%89%93%E5%8C%85/" target="_blank" rel="noopener">可视化搭建平台（三）-打包</a></p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>可视化搭建平台</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>可视化搭建平台（一）- 流程</title>
    <url>/2021/03/28/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%B8%80%EF%BC%89-%E6%B5%81%E7%A8%8B/</url>
    <content><![CDATA[<p>做一个更加通用的可视化搭建平台，用户通过 npm 安装 h5-editor (包名)，就可以直接使用了。</p>
<p>可以使用的功能有：</p>
<ul>
<li>拖拽组件、删除组件；</li>
<li>修改页面基本信息，如：页面标题、页面背景色等；</li>
<li>修改组件样式，如：组件大小、颜色等；</li>
<li>可以使用基础组件（组件内提供）；</li>
<li>可以使用自定义组件（用户自己实现的组件）；</li>
<li>打包生成静态化页面。</li>
</ul>
<p>应用场景：面对不同业务所需的组件不同，因此抽离并且封装内部数据流通，封装基础组件。</p>
<p>最终页面效果如下：</p>
<p><img src="https://i.loli.net/2021/03/28/eZxB8cI6DSN25ly.gif" alt="h5_editor.gif"></p>
<h2 id="页面布局"><a href="#页面布局" class="headerlink" title="页面布局"></a>页面布局</h2><p><img src="https://i.loli.net/2021/03/27/Liw4XgCNj5lxkUE.png" alt="image.png"></p>
<h2 id="数据流转"><a href="#数据流转" class="headerlink" title="数据流转"></a>数据流转</h2><p>主要数据流转如下图：</p>
<p><img src="https://i.loli.net/2021/03/28/n9s4fUWHwpJLPBx.png" alt="image.png"></p>
<p>上图就是数据流转的使用图：通过将基础组件信息传入 h5-editor，然后输出一份 json 数据，然后通过这份 json 数据打包生成 html 页面。</p>
<p>组件最后的使用方式为：</p>
<pre><code class="vue">&lt;h5-editor v-model=&quot;jsonData&quot; :data=&quot;data&quot;&gt;&lt;/h5-editor&gt;
</code></pre>
<h2 id="数据格式及流转"><a href="#数据格式及流转" class="headerlink" title="数据格式及流转"></a>数据格式及流转</h2><h3 id="外部传入-h5-editor-组件信息"><a href="#外部传入-h5-editor-组件信息" class="headerlink" title="外部传入 h5-editor 组件信息"></a>外部传入 h5-editor 组件信息</h3><p>外部传入基本数据信息 data 格式如下：</p>
<pre><code class="txt">[
    {
        component, // 渲染组件
        styleComponent, // 渲染组件对应修改样式的组件
        dynamicStyle, // 组件样式 props
    },
    {
         // ...       
    }
]
</code></pre>
<ul>
<li><code>component</code>：渲染组件，即拖拽添加到页面、最后显示到实际页面上的组件；</li>
<li><code>styleComponent</code>：渲染组件对应的样式修改组件。即在中间预览区域点击了一个组件后，右边区域显示对应的样式修改组件。</li>
<li><code>dynamicStyle</code>：该属性是传入到组件内部的 props 对象。</li>
</ul>
<h3 id="h5-editor-输出数据格式"><a href="#h5-editor-输出数据格式" class="headerlink" title="h5-editor 输出数据格式"></a>h5-editor 输出数据格式</h3><p>h5-editor 调用者和 h5-editor 组件通过 v-model 共享一份 jsonData 数据。有两个作用：</p>
<ul>
<li>调用者实时拿到 jsonData 数据；</li>
<li>可用于草稿 jsonData 数据的传入初始化 h5-editor 组件信息。</li>
</ul>
<p>jsonData 数据格式如下：</p>
<pre><code class="txt">{
    // 基本配置信息
    pageInfo: {
        title: &#39;&#39;, // 页面标题
        description: &#39;&#39;, // 页面描述
        backgroundColor: &#39;&#39;, // 页面背景色
        // ...
    },
    // 页面布局信息
    layout: [
        {
            type: &#39;&#39;, // 组件类型，对用 component.name
            dynamicStyle: { // 页面样式信息 
                // ...
            }
        }
    ]
}
</code></pre>
<h3 id="数据流转过程"><a href="#数据流转过程" class="headerlink" title="数据流转过程"></a>数据流转过程</h3><p>渲染组件 component 和 样式修改组件 styleComponent 都包含这个 props 对象，这样一旦样式修改组件 styleComponent 修改了样式，就通过向父级组件派发样式修改事件 changeStyle（通过 <code>this.$emit(&#39;changeStyle&#39;, newDynamicStyleObj)</code>派发），这样父级组件 h5-editor 就可以接收到样式修改事件和新的样式值，然后将新的样式值注入到渲染组件 component 的 dynamicStyle props 中，最后将页面样式进行更新。</p>
<p><img src="https://i.loli.net/2021/03/27/X2rnp8xLQRBjlgb.png" alt="image.png"></p>
<p>总结：h5-editor 在渲染组件 component 和样式修改组件 styleComponent 之间扮演的角色只是数据转发的作用。</p>
<p><a href="https://ertsul.com/2021/03/28/%E5%8F%AF%E8%A7%86%E5%8C%96%E6%90%AD%E5%BB%BA%E5%B9%B3%E5%8F%B0%EF%BC%88%E4%BA%8C%EF%BC%89-%E5%AE%9E%E7%8E%B0/" target="_blank" rel="noopener">可视化搭建平台（二）-实现</a></p>
]]></content>
      <tags>
        <tag>Vue</tag>
        <tag>可视化搭建平台</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter 知识点记录</title>
    <url>/2021/03/21/flutter-%E7%9F%A5%E8%AF%86%E7%82%B9%E8%AE%B0%E5%BD%95/</url>
    <content><![CDATA[<h2 id="Flutter-记录"><a href="#Flutter-记录" class="headerlink" title="Flutter 记录"></a>Flutter 记录</h2><h3 id="1-Button-限制宽高"><a href="#1-Button-限制宽高" class="headerlink" title="1. Button 限制宽高"></a>1. Button 限制宽高</h3><p>使用 SizeBox 进行包裹。</p>
<pre><code class="dart">Widget _arrowIcon = SizedBox(
  width: duSetWidth(18.0),
  child: FlatButton(
    padding: EdgeInsets.all(0),
    onPressed: () {
      print(&#39;_arrowIcon  tap&#39;);
    },
    child: Icon(
      IconFont.iconmore,
      color: AppColors.grayThirdColor,
      size: duSetFontSize(14),
    ),
  ),
);

</code></pre>
<h3 id="2-获取目标-widget-相关信息"><a href="#2-获取目标-widget-相关信息" class="headerlink" title="2.获取目标 widget 相关信息"></a>2.获取目标 widget 相关信息</h3><p>使用 GlobalKey()</p>
<pre><code class="dart">// 定义变量
GlobalKey _Key = GlobalKey();
// 绑定 widget
Center(
    key: _Key,
    child: Text(&#39;content&#39;)
);
// 使用
RenderBox _box = _alphabetListKey?.currentContext?.findRenderObject();
_box.localToGlobal(Offset.zero); // offset
// ...
</code></pre>
<h3 id="3-沉浸式状态栏"><a href="#3-沉浸式状态栏" class="headerlink" title="3.沉浸式状态栏"></a>3.沉浸式状态栏</h3><pre><code class="dart">void _statusBar([String color]) {
    // 白色沉浸式状态栏颜色  白色文字
    SystemUiOverlayStyle light = SystemUiOverlayStyle(
      systemNavigationBarColor: Color(0xFF000000),
      systemNavigationBarDividerColor: null,

      /// 注意安卓要想实现沉浸式的状态栏 需要底部设置透明色
      statusBarColor: Colors.transparent,
      systemNavigationBarIconBrightness: Brightness.light,
      statusBarIconBrightness: Brightness.light,
      statusBarBrightness: Brightness.dark,
    );

    // 黑色沉浸式状态栏颜色 黑色文字
    SystemUiOverlayStyle dark = SystemUiOverlayStyle(
      systemNavigationBarColor: Color(0xFF000000),
      systemNavigationBarDividerColor: null,

      /// 注意安卓要想实现沉浸式的状态栏 需要底部设置透明色
      statusBarColor: Colors.transparent,
      systemNavigationBarIconBrightness: Brightness.light,
      statusBarIconBrightness: Brightness.dark,
      statusBarBrightness: Brightness.light,
    );
    &quot;white&quot; == color?.trim()
        ? SystemChrome.setSystemUIOverlayStyle(light)
        : SystemChrome.setSystemUIOverlayStyle(dark);
  }
</code></pre>
<h3 id="4-获取顶部状态栏高度"><a href="#4-获取顶部状态栏高度" class="headerlink" title="4.获取顶部状态栏高度"></a>4.获取顶部状态栏高度</h3><ul>
<li>MediaQuery.of(context).padding.top</li>
<li>MediaQueryData.fromWindow(window).padding.top</li>
</ul>
<h3 id="5-安全区域，比如：iphone-12等全面屏底部遮挡问题"><a href="#5-安全区域，比如：iphone-12等全面屏底部遮挡问题" class="headerlink" title="5.安全区域，比如：iphone 12等全面屏底部遮挡问题"></a>5.安全区域，比如：iphone 12等全面屏底部遮挡问题</h3><ul>
<li>SafeArea</li>
</ul>
<h3 id="6-国际化初始化生命周期问题"><a href="#6-国际化初始化生命周期问题" class="headerlink" title="6.国际化初始化生命周期问题"></a>6.国际化初始化生命周期问题</h3><p>问题：在 initState 直接调用 <code>DemoLocalizations.of(context).all</code></p>
<pre><code>原因：initState 生命周期的作用主要是将当前的 state 与上下文 buildContext 产生关联，此时的上下文还不能使用。
</code></pre><p><img src="https://i.loli.net/2021/03/11/2Ox4blhzp3SjwaJ.png" alt="image-20201209164937816.png"></p>
<p>解决方案：</p>
<ul>
<li>initState 添加异步逻辑</li>
</ul>
<pre><code class="dart">Future.delayed(Duration.zero, () { // ... });
</code></pre>
<ul>
<li>放 didChangeDependencies 生命周期</li>
</ul>
<h3 id="7-切换-tab，addListener-触发两次"><a href="#7-切换-tab，addListener-触发两次" class="headerlink" title="7.切换 tab，addListener 触发两次"></a>7.切换 tab，addListener 触发两次</h3><p>点击切换tab的时候执行了一个动画效果，滑动切换的时候是没有的，在这个过程中触发了一次Listener，所以触发了两次addListener方法。</p>
<p>解决方案：在 addListener 中添加判断</p>
<ul>
<li><code>if(_newsTabController.index == _newsTabController.animation.value) { //... }</code></li>
<li><code>if(_newsTabController.indexIsChanging) { //... }</code></li>
</ul>
<h3 id="8-stack-溢出部分点击失效问题"><a href="#8-stack-溢出部分点击失效问题" class="headerlink" title="8.stack 溢出部分点击失效问题"></a>8.stack 溢出部分点击失效问题</h3><p>如下图：蓝色区域为父级 stack 容器，灰色容器（1+2）为 stack 子级样式，由于 2 溢出父级容器，出现问题：2 点击事件不生效。</p>
<p><img src="https://i.loli.net/2021/03/11/cmoSrClHk9LYtTV.png" alt="image-20201224173117517.png"></p>
<p>解决办法：更改布局，父级容器包裹整个区域，不让其溢出。</p>
<h3 id="9-vscdoe-多渠道-flavor-配置"><a href="#9-vscdoe-多渠道-flavor-配置" class="headerlink" title="9.vscdoe 多渠道 flavor 配置"></a>9.vscdoe 多渠道 flavor 配置</h3><p>根目录添加 .vscode/launch.json 配置文件，添加配置：</p>
<pre><code class="dart">{
  &quot;version&quot;: &quot;xxx&quot;,
  &quot;configurations&quot;: [
    {
      &quot;name&quot;: &quot;wapcar&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;type&quot;: &quot;dart&quot;,
      &quot;args&quot;: [
        &quot;--flavor&quot;,
        &quot;wapcar&quot;
      ]
    },
    {
      &quot;name&quot;: &quot;autofun&quot;,
      &quot;request&quot;: &quot;launch&quot;,
      &quot;type&quot;: &quot;dart&quot;,
      &quot;args&quot;: [
        &quot;--flavor&quot;,
        &quot;autofun&quot;
      ]
    }
  ]
}
</code></pre>
<h3 id="10-json-序列化"><a href="#10-json-序列化" class="headerlink" title="10.json 序列化"></a>10.<a href="https://flutter.cn/docs/development/data-and-backend/json#code-generation" target="_blank" rel="noopener">json 序列化</a></h3><ul>
<li>安装依赖</li>
</ul>
<pre><code class="yaml">dependencies:
    json_annotation: ^3.1.1
dev_dependencies:
     build_runner: ^1.10.13
    json_serializable: ^3.5.1
</code></pre>
<ul>
<li>创建模型类 user.dart</li>
</ul>
<pre><code class="dart">import &#39;package:json_annotation/json_annotation.dart&#39;;

/// This allows the `User` class to access private members in
/// the generated file. The value for this is *.g.dart, where
/// the star denotes the source file name.
part &#39;user.g.dart&#39;;

/// An annotation for the code generator to know that this class needs the
/// JSON serialization logic to be generated.
@JsonSerializable()

class User {
  User(this.name, this.email);

  String name;
  String email;

  /// A necessary factory constructor for creating a new User instance
  /// from a map. Pass the map to the generated `_$UserFromJson()` constructor.
  /// The constructor is named after the source class, in this case, User.
  factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json);

  /// `toJson` is the convention for a class to declare support for serialization
  /// to JSON. The implementation simply calls the private, generated
  /// helper method `_$UserToJson`.
  Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this);
}
</code></pre>
<ul>
<li>执行命令 flutter pub run build_runner build 后生成 user.g.dart 文件 </li>
</ul>
<p><img src="https://i.loli.net/2021/03/11/41H8cOWdCIlamjG.png" alt="image-20210122170901165.png"></p>
<h3 id="11-延迟加载库"><a href="#11-延迟加载库" class="headerlink" title="11.延迟加载库"></a>11.延迟加载库</h3><p><img src="https://i.loli.net/2021/03/11/jn18W4s9T2olSci.png" alt="image-20210122170901165.png"></p>
<h3 id="12-获取屏幕宽高"><a href="#12-获取屏幕宽高" class="headerlink" title="12.获取屏幕宽高"></a>12.获取屏幕宽高</h3><pre><code class="dart">double _screenHeight = MediaQuery.of(context).size.height
double _screenWidth = MediaQuery.of(context).size.width

</code></pre>
<h3 id="13-解决-bottomNavigationBar切换-tabbar-刷新页面，原有状态消失问题"><a href="#13-解决-bottomNavigationBar切换-tabbar-刷新页面，原有状态消失问题" class="headerlink" title="13.解决 bottomNavigationBar切换 tabbar 刷新页面，原有状态消失问题"></a>13.解决 bottomNavigationBar切换 tabbar 刷新页面，原有状态消失问题</h3><ul>
<li>AutomaticKeepAliveClientMixin </li>
<li>IndexedStack</li>
</ul>
<pre><code class="dart">Scaffold(
    bottomNavigationBar: _buildBottomNavigationBar(),
    body: IndexedStack( // indexedStack 可以确保 tabbar 时候不刷新页面
        index: _selectedIndex,
        children: _contentListView,
    ),
);

</code></pre>
<h3 id="14-切换-tabbar-保存状态"><a href="#14-切换-tabbar-保存状态" class="headerlink" title="14.切换 tabbar 保存状态"></a>14.切换 tabbar 保存状态</h3><pre><code class="dart">class _HomeRecommednedState extends State&lt;HomeRecommedned&gt;
    with AutomaticKeepAliveClientMixin {
  @override
    bool get wantKeepAlive =&gt; true; //  with AutomaticKeepAliveClientMixin + 设置 wantKeepAlive 为 true，确保顶部切换 tabbar 保存 state
  }

</code></pre>
<h3 id="15-FutrueBuilder-StreamBuilder"><a href="#15-FutrueBuilder-StreamBuilder" class="headerlink" title="15.FutrueBuilder / StreamBuilder"></a>15.FutrueBuilder / StreamBuilder</h3><p>作用：异步 UI 更新。两者都可以用于接收异步事件数据。</p>
<p>区别：</p>
<p><code>futureBuilder</code> 只有一个响应，类似于 js 中的 Promise。</p>
<p><code>streamBuilder</code> 可以接收多个异步操作的结果，常用于多次读取数据的异步任务场景。</p>
<h3 id="16-Flutter-布局约束"><a href="#16-Flutter-布局约束" class="headerlink" title="16. Flutter 布局约束"></a>16. Flutter 布局约束</h3><p>链接：<a href="https://flutter.cn/docs/development/ui/layout/constraints" target="_blank" rel="noopener">https://flutter.cn/docs/development/ui/layout/constraints</a></p>
]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>flutter 字母联动列表</title>
    <url>/2020/12/20/flutter-%E5%AD%97%E6%AF%8D%E8%81%94%E5%8A%A8%E5%88%97%E8%A1%A8/</url>
    <content><![CDATA[<h1 id="flutter-字母联动列表"><a href="#flutter-字母联动列表" class="headerlink" title="flutter 字母联动列表"></a>flutter 字母联动列表</h1><p>网上的第三方包，用的最多就是：<a href="https://pub.dev/packages/azlistview" target="_blank" rel="noopener">azListView</a>。</p>
<p>但是它有 bug：当列表到达页面底部的时候，滑动最后几个字母，还会触发回弹到屏幕顶部。如下：</p>
<p><img src="https://i.loli.net/2020/12/07/Kkad3H7t82GXyLq.gif" alt="azlisview_list.gif"></p>
<p>经过分析，一开始以为是 ListView 的 physics 属性影响，<a href="https://book.flutterchina.club/chapter6/intro.html" target="_blank" rel="noopener">physics </a>介绍：</p>
<ul>
<li>ClampingScrollPhysics：Android下微光效果。</li>
<li>BouncingScrollPhysics：iOS下弹性效果。</li>
<li>NeverScrollableScrollPhysics：禁止滚动。</li>
</ul>
<p>但是设置该属性其实没有效果，还是会出现上面的问题。</p>
<p>后面多次测试 ListView，发现是 ListView 跳转事件 jumpTo 的影响，后面改用 animateTo，animateTo 的用法如下：</p>
<pre><code>_scrollController.animateTo( offsetHeight, duration: Duration(milliseconds: 10), curve: Curves.linear, )
</code></pre><p>但是又有新的问题：</p>
<ul>
<li>当连续快速滑动的时候，这个 duration 相当于多了个防抖的作用。</li>
<li>点击字母列表的时候，也会有问题。</li>
</ul>
<p>效果如下：</p>
<p><img src="https://i.loli.net/2020/12/07/iQeIG5ay6TCEKHU.gif" alt="animato_list.gif"></p>
<p>azListView 存在问题：</p>
<ul>
<li>azListView 包体较大；</li>
<li>存在的问题修改源码耗时较久。</li>
</ul>
<hr>
<p>自己实现，效果如下：</p>
<p><img src="https://i.loli.net/2020/12/07/Ts58gGam3C6FBI2.gif" alt="alphabet_link_list.gif"></p>
<h2 id="布局"><a href="#布局" class="headerlink" title="布局"></a>布局</h2><p>整个页面用 Stack 布局，分为：</p>
<ul>
<li>主列表（头部 + 城市列表）</li>
<li>主列表顶部字母提示</li>
<li>字母列表（字母列表 + 当前字母提示）</li>
</ul>
<p>代码如下：</p>
<pre><code class="dart">/// _buildBody
Widget _buildBody() {
  return Stack(
    children: [
      _buildMainListView(),
      _buildSusBarView(),
      Positioned(
        top: duSetHeight(120),
        right: duSetWidth(10),
        child: Row(
          mainAxisAlignment: MainAxisAlignment.center,
          children: [_buildAlphabetListView()],
        ),
      ),
    ],
  );
}
</code></pre>
<h2 id="GestureDetector"><a href="#GestureDetector" class="headerlink" title="GestureDetector"></a>GestureDetector</h2><p><a href="https://book.flutterchina.club/chapter8/gesture.html" target="_blank" rel="noopener">GestureDetector 文档链接</a></p>
<ul>
<li>onVerticalDragUpdate：滑动更新</li>
<li>onVerticalDragEnd：滑动结束</li>
<li>…</li>
</ul>
<h2 id="主要思路"><a href="#主要思路" class="headerlink" title="主要思路"></a>主要思路</h2><h3 id="1-初始化的时候，先计算获取以下数值。"><a href="#1-初始化的时候，先计算获取以下数值。" class="headerlink" title="1.初始化的时候，先计算获取以下数值。"></a>1.初始化的时候，先计算获取以下数值。</h3><ul>
<li>计算主列表每个字母分组需要跳转的 offsetTopList 和每个字母分组所占用的高度 groupHeight；</li>
</ul>
<p>【计算：遍历字母列表，字母的 offsetTop = 之前的所有字母所有的 offsetTop 累加；当前字母的 groupHeight = 每个主列表项 itemHeight * 每个字母分组数量。】</p>
<pre><code class="dart">/// 计算主列表每个字母需要滚动的距离和每个字母项所占用的高度
void _calcEachLetterOffsetTop() {
  List&lt;String&gt; _alphabetList = widget.alphabetList;

  /// offset top
  _alphabetListOffsetTopMap[_alphabetList[0]] = 0; // &#39;#&#39; header offsetTop
  _alphabetListOffsetTopMap[_alphabetList[1]] =
      widget.headerHeight; // 第一个字母，滚动距离为顶部 header 高度 offsettop
  /// height
  _alphabetListHeightMap[_alphabetList[0]] =
      widget.headerHeight; // &#39;#&#39; header height
  _alphabetListHeightMap[_alphabetList[1]] =
      widget.alphabetCountMap[_alphabetList[1]] * widget.mainListItemHeight +
          widget.guideBarHeight; // 第一个字母所占用的高度
  // 第二项开始循环
  for (int i = 2; i &lt; _alphabetList.length; i++) {
    String _curLetter = _alphabetList[i]; // 当前字母

    // 保存当前字母项的高度
    _alphabetListHeightMap[_curLetter] =
        widget.alphabetCountMap[_curLetter] * widget.mainListItemHeight +
            widget.guideBarHeight;

    // 计算主列表每一个字母项需要滚动的 offsetTop（之前的所有字母所有的 offsetTop 累加）
    double _offsetTopSum = 0.0;

    for (int j = i - 1; j &gt; 0; j--) {
      String _preLetter = _alphabetList[j]; // 之前的字母
      // 将之前所有字母的高度累加
      // 主列表每个字母单元高度 = 子项数量 * 子项高度 + 主列表导航条高度
      _offsetTopSum +=
          widget.alphabetCountMap[_preLetter] * widget.mainListItemHeight +
              widget.guideBarHeight;
    }
    _alphabetListOffsetTopMap[_curLetter] =
        _offsetTopSum + widget.headerHeight; // 设置当前字母的滚动 offsetTop
  }
}
</code></pre>
<ul>
<li>获取主列表不需要滚动的字母列表。</li>
</ul>
<p>【计算：从字母表后面遍历，将每个字母分组所占用的高度 groupHeight 进行累加，与屏幕的高度进行比较，如果累加结果小于屏幕高度，则对该字母进行标记。】</p>
<p>主要代码如下：</p>
<pre><code class="dart">/// 获取主列表不需要滚动的字母列表
void _getNotScrollAlphebetList() {
  final _screenHeight =
      duSetHeight(MediaQuery.of(context).size.height); // 屏幕高度
  // final _screenHeight = duSetHeight(size.height);
  double _heightSum = 0.0;
  // 判断那些字母不需要触发列表滚动，从后面字母开始循环累加，判断是否小于屏幕高度
  for (int i = widget.alphabetList.length - 1; i &gt;= 0; i--) {
    String _curLetter = widget.alphabetList[i];
    bool _ifLessThanScreenHeight =
        _heightSum + _alphabetListHeightMap[_curLetter] &lt;= _screenHeight;
    if (_ifLessThanScreenHeight) {
      _heightSum += _alphabetListHeightMap[_curLetter]; // 累加
      _notScrollAlphabetLst.insert(0, _curLetter); // 添加到列表
    } else {
      break;
    }
  }
}
</code></pre>
<h3 id="2-滑动主列表，获取当前的字母，更新右侧字母表状态和更新顶部字母导航条。"><a href="#2-滑动主列表，获取当前的字母，更新右侧字母表状态和更新顶部字母导航条。" class="headerlink" title="2. 滑动主列表，获取当前的字母，更新右侧字母表状态和更新顶部字母导航条。"></a>2. 滑动主列表，获取当前的字母，更新右侧字母表状态和更新顶部字母导航条。</h3><ul>
<li>获取主列表当前滑动位置的 screenOffsetTop；</li>
<li>遍历 offsetTopList，判断 screenOffsetTop 在哪两个字母的区间内，则可以定位到目标字母。</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="dart">/// 更新字母表当前激活的字母
void _updateAlphebetListView() {
  // 主列表上锁中（滚动执行中），直接返回
  if (_mainListScrollLock == true) return;
  List&lt;String&gt; _alphabetList = widget.alphabetList;
  // 监听主列表滚动，判断主列表的 offsetTop 在哪两个字母的 offsetTop 区间内，将右侧字母导航列表激活为当前字母
  for (int i = 0; i &lt; widget.alphabetList.length; i++) {
    // 不为最后一个字母 + 主列表 offsetTop 大于当前字母的 offsetTop + 主列表的 offsetTop 小于下一个字母的 offsetTop
    bool _ifInCurRange = i != widget.alphabetList.length - 1 &amp;&amp;
        _scrollController.offset &lt;=
            _alphabetListOffsetTopMap[_alphabetList[i + 1]] &amp;&amp;
        _scrollController.offset &gt;
            _alphabetListOffsetTopMap[_alphabetList[i]];
    if (_ifInCurRange) {
      _selectedAlphabetIndex = i; // 设置字母表选中字母索引
      _mainListScrollLock = false; // 解锁
      setState(() {});
      return;
    }
  }
}
</code></pre>
<h3 id="3-滑动字母表，获取当前的字母，主列表跳转到目标字母和更新顶部字母导航条。"><a href="#3-滑动字母表，获取当前的字母，主列表跳转到目标字母和更新顶部字母导航条。" class="headerlink" title="3. 滑动字母表，获取当前的字母，主列表跳转到目标字母和更新顶部字母导航条。"></a>3. 滑动字母表，获取当前的字母，主列表跳转到目标字母和更新顶部字母导航条。</h3><ul>
<li>获取字母表当前位置相对于字母表容器顶部的高度 paddingOffsetTop【获取字母表当前位置对于视窗的高度 - 字母表容器顶部的高度相对于视窗的高度】;</li>
<li>计算每个字母项占用字母表容器的高度 alphabetItemHeight 【(字母表容器的高度 - padding) / 字母数量】；</li>
<li>获取当前索引，paddingOffsetTop / alphabetItemHeight；</li>
<li>获取当前字母和主列表 offsetTopList 滚动高度，</li>
<li>更新视图。</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="dart">/// 滑动字母表：滚动主列表 + 更新字母列表
void _onVerticalDragUpdateHandle(DragUpdateDetails event, int index) {
  /// 更新字母表
  if (_alphabetListOffset == null) {
    // 获取字母表的 margin top
    RenderBox _box = _alphabetListKey?.currentContext?.findRenderObject();
    _alphabetListOffset = _box.localToGlobal(Offset.zero);
  }
  // 字母表的padding
  double _alphabetPadding = widget.alphabetListItemHeight;
  // 计算当前字母项索引：(当前活动的 dy - 字母表的 marginTop - 字母表的 padding) / 每个字母所占的高度
  int _curActiveLetterIndex =
      ((event.globalPosition.dy - _alphabetListOffset.dy - _alphabetPadding) /
              widget.alphabetListItemHeight)
          .round();
  if (_curActiveLetterIndex &lt; 0) {
    // 滑出字母表区域上面，保持为 0
    _selectedAlphabetIndex = 0;
  } else if (_curActiveLetterIndex &gt;= widget.alphabetList.length) {
    // 滑出字母表区域下面，保持为最后一个
    _selectedAlphabetIndex = widget.alphabetList.length - 1;
  } else {
    _selectedAlphabetIndex = _curActiveLetterIndex;
  }
  setState(() {});

  /// 滚动主列表
  String _curLetter = widget.alphabetList[_selectedAlphabetIndex]; // 获取当前字母项
  _scrollMainList(_curLetter);
}
</code></pre>
<h3 id="4-当主列表已经滑动到底部，继续滑动字母表剩下的字母，判断当前字母时候标记为不需要滚动主列表，直接滑动列表底部，不滑动到字母分组位置。"><a href="#4-当主列表已经滑动到底部，继续滑动字母表剩下的字母，判断当前字母时候标记为不需要滚动主列表，直接滑动列表底部，不滑动到字母分组位置。" class="headerlink" title="4.当主列表已经滑动到底部，继续滑动字母表剩下的字母，判断当前字母时候标记为不需要滚动主列表，直接滑动列表底部，不滑动到字母分组位置。"></a>4.当主列表已经滑动到底部，继续滑动字母表剩下的字母，判断当前字母时候标记为不需要滚动主列表，直接滑动列表底部，不滑动到字母分组位置。</h3><p>主要代码如下：</p>
<pre><code>/// 滚动主列表 void _scrollMainList(String letter) {  if (_notScrollAlphabetLst.contains(letter)) {    // 当前字母不需要滚动    _scrollController        .jumpTo(_scrollController.position.maxScrollExtent); // 滚动到列表底部    return;  }  _scrollController.jumpTo(    _alphabetListOffsetTopMap[letter],  ); }
</code></pre><h3 id="5-主列表滚动锁。"><a href="#5-主列表滚动锁。" class="headerlink" title="5. 主列表滚动锁。"></a>5. 主列表滚动锁。</h3><p>为防止出现上次滚动还没结束，下次滚动就开始执行的问题，给主列表滚动上锁。</p>
<pre><code>/// 更新字母表当前激活的字母 void _updateAlphebetListView() {  // 主列表上锁中（滚动执行中），直接返回  if (_mainListScrollLock) return;  // ... }
</code></pre>]]></content>
      <categories>
        <category>flutter</category>
      </categories>
      <tags>
        <tag>flutter</tag>
      </tags>
  </entry>
  <entry>
    <title>svg sprite</title>
    <url>/2020/08/09/svg-sprite/</url>
    <content><![CDATA[<h2 id="svg-sprite"><a href="#svg-sprite" class="headerlink" title="svg sprite"></a>svg sprite</h2><h3 id="介绍"><a href="#介绍" class="headerlink" title="介绍"></a>介绍</h3><p>svg sprite 不跟传统图片雪碧图一样是许多小图的集合。它是基于 svg，是很多 svg  的集合，每个 svg 元素都包含在标签<code>&lt;symbol id=&quot;xxxx&quot;&gt;&lt;/symbol&gt;</code>，这样就不用像图片雪碧图一样去请求一张大图。如下面就是一个 sprite.svg 文件：</p>
<pre><code class="xml">&lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot;
  xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt;
  &lt;defs&gt;
    &lt;symbol t=&quot;1595505780153&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; id=&quot;icon-logo&quot;&gt;
      &lt;path d=&quot;M680.97024 343.06048A238.26432 238.26432 0 0 0 512 273.05984c-131.93216 0-238.92992 106.97728-238.92992 238.92992S380.06784 750.94016 512 750.94016c120.29952 0 219.5968-89.05728 236.19584-204.81024H512v-68.27008h307.2v34.12992a313.1392 313.1392 0 0 1-1.9968 34.14016C800.2048 699.74016 670.12608 819.21024 512 819.21024c-169.66656 0-307.2-137.53344-307.2-307.22048 0-169.64608 137.53344-307.2 307.2-307.2 84.82816 0 161.62816 34.39616 217.23136 89.99936l-48.26112 48.27136z&quot; p-id=&quot;3177&quot;&gt;&lt;/path&gt;
    &lt;/symbol&gt;
  &lt;/defs&gt;
&lt;/svg&gt;
</code></pre>
<p>当需要新增 svg icon 的时候，只需要添加新的 svg 在 symbol 上就行，每个 symbol 都有一个 id，用于使用的时候调用。</p>
<p>使用的时候，需要 <code>&lt;use xlink:href=&quot;#xxxx&quot;&gt;&lt;/use&gt;</code> 标签进行调用。当 sprite.svg 独立抽离成一个文件的时候，use 标签的格式为：<code>&lt;use xlink:href=&quot;/path/sprite.svg#xxxx&quot;&gt;&lt;/use&gt;</code>。如：使用上面的 logo icon，格式为：</p>
<pre><code class="xml">&lt;svg width=&quot;40&quot; height=&quot;40&quot;&gt;
    &lt;use xlink:href=&quot;/svg/sprite.svg#icon-logo&quot; x=&quot;0&quot; y=&quot;0&quot; /&gt;
&lt;/svg&gt;
</code></pre>
<p>svg sprite 更加方便的是，可以通过 css 属性<code>fill:color;</code>直接更改颜色：</p>
<p><img src="https://i.loli.net/2020/07/28/YWsk1M6zjIeoymd.png" alt="image-20200728150102202.png"></p>
<h3 id="结合-vue-webpack-使用"><a href="#结合-vue-webpack-使用" class="headerlink" title="结合 vue + webpack 使用"></a>结合 vue + webpack 使用</h3><p>主要是使用两个 loader ：</p>
<ul>
<li>svg-sprite-loader</li>
<li>svgo-loader</li>
</ul>
<p>在 <code>vue.config.js</code>中添加配置配置：</p>
<ol>
<li>不抽离 sprite.svg 文件为独立的文件（集成在 html 文件中），一般用于开发环境。</li>
</ol>
<p>vue.config.js 配置：</p>
<pre><code class="javascript">chainWebpack(config) {
    config.module.rules.delete(&quot;svg&quot;);
    config.module
      .rule(&quot;svg&quot;)
      .test(/\.svg$/)
      .use(&quot;svg-sprite&quot;)
      .loader(&quot;svg-sprite-loader&quot;)
      .options({
        extract: false, // 默认不抽离 sprite.svg 为独立的文件
        // spriteFilename: (svgPath) =&gt; `sprite${svgPath.substr(-4)}`,
        esModule: false,
      })
      .end()
}
</code></pre>
<p>封装 svgIcon 组件：</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;svg-icon&quot;&gt;
    &lt;svg :style=&quot;styleObj&quot; :viewBox=&quot;svgCtx.viewBox&quot;&gt;
      &lt;use :id=&quot;svgCtx.id&quot; :xlink:href=&quot;&#39;#&#39; + svgCtx.id&quot;/&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
export default {
  props: {
    width: {
      type: String,
      default: &quot;40px&quot;
    },
    height: {
      type: String,
      default: &quot;40px&quot;
    },
    color: {
      type: String,
      default: &quot;&quot;
    },
    svg: {
      type: Object,
      default: () =&gt; {},
      required: true
    }
  },
  computed: {
    styleObject() {
      // 样式对象
      let styleObj = {};
      this.width &amp;&amp; (styleObj.width = this.width);
      this.height &amp;&amp; (styleObj.height = this.height);
      this.color &amp;&amp; (styleObj.fill = this.color);
      return styleObj;
    }，
    svgCtx() {
        // 兼容 import 和 require 两种模式（require 模式下默认的 svg 对象在 default 中）
        // return this.svg.hasOwnProperty(&quot;default&quot;) ? this.svg.default : this.svg;
        return this.svg.default || this.svg;
    }
  }
};
&lt;/script&gt;
</code></pre>
<p>组件使用：</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;svg-container&quot;&gt;
    &lt;svgIcon :svg=&quot;logoSvg&quot;&gt;&lt;/svgIcon&gt;
    &lt;svgIcon :svg=&quot;playSvg&quot;&gt;&lt;/svgIcon&gt;
  &lt;/div&gt;
&lt;/template&gt;
&lt;script&gt;
import svgIcon from &quot;../../src/components/svgIcon&quot;
import logoSvg from &quot;../../src/assets/logo.svg&quot;
import playSvg from &quot;../../src/assets/play.svg&quot;
export default {
  components: {svgIcon},
  data() {
    return {
      logoSvg: logoSvg,
      playSvg: playSvg
    };
  },
};
&lt;/script&gt;
</code></pre>
<p>效果：</p>
<p><img src="https://i.loli.net/2020/07/28/TBYh2iFx8lXyUbs.png" alt="image-20200728144255915.png"></p>
<ol start="2">
<li>抽离 sprite.svg 文件为独立的文件，一般用户生产环境：</li>
</ol>
<p>修改 vue.config.js 配置：</p>
<pre><code class="javascript">config.module.rules.delete(&quot;svg&quot;);

config.module
  .rule(&quot;svg&quot;)
  .test(/\.svg$/)
  .use(&quot;svg-sprite&quot;)
  .loader(&quot;svg-sprite-loader&quot;)
  .options({
    extract: true,
    // spriteFilename: (svgPath) =&gt; `sprite${svgPath.substr(-4)}`,
    esModule: false,
  })
  .end()

config.plugin(&quot;svg-sprite&quot;).use(require(&quot;svg-sprite-loader/plugin&quot;)); // 抽离 sprite.svg 必需
</code></pre>
<p>修改 svg 组件：</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;svg-icon&quot;&gt;
    &lt;svg :style=&quot;styleObject&quot; :viewBox=&quot;svgCtx.viewBox&quot;&gt;
      &lt;!-- 指向打包后抽离的 sprite.svg 文件 --&gt;
      &lt;use :id=&quot;svgCtx.id&quot; :xlink:href=&quot;&#39;../dist/sprite.svg#&#39; + svgCtx.id&quot;/&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
&lt;/template&gt;
</code></pre>
<p>其他不变，效果如下：</p>
<p><img src="https://i.loli.net/2020/07/28/BNazUW2mGO3vd6F.png" alt="image-20200728150200223.png"></p>
<p>思考：怎么通过环境变量将生产模式和开发环境结合起来？</p>
<h3 id="结合开发模式和生产模式"><a href="#结合开发模式和生产模式" class="headerlink" title="结合开发模式和生产模式"></a>结合开发模式和生产模式</h3><p>主要解决两个问题：</p>
<ul>
<li>vue.config.js 中的 extract 配置：false 和 true；</li>
<li>svgIcon 中 <code>xlink:href</code> 指向问题。</li>
</ul>
<p>通过环境变量即可。</p>
<p>修改 vue.config.js：</p>
<pre><code class="js">const ifProd = process.env.NODE_ENV === &#39;production&#39;;

// ...
extract: ifProd,
// ...
</code></pre>
<p>修改 svgIcon 组件：</p>
<pre><code class="vue">&lt;template&gt;
  &lt;div class=&quot;svg-icon&quot;&gt;
    &lt;svg :style=&quot;styleObject&quot; :viewBox=&quot;svgCtx.viewBox&quot;&gt;
      &lt;use :id=&quot;svgCtx.id&quot; :xlink:href=&quot;xlinkHref&quot;/&gt;
    &lt;/svg&gt;
  &lt;/div&gt;
&lt;/template&gt;

&lt;script&gt;
// ...
xlinkHref() {
    const ifProd = process.env.NODE_ENV === &#39;production&#39;;
    const svgCtxId = this.svgCtx.id;
    // 生产环境指向打包后抽离的 sprite.svg 文件
    // 开发环境不抽离独立的 sprite.svg 文件
    return ifProd ? `../dist/sprite.svg#${svgCtxId}` : `#${svgCtxId}`;
}
//...
&lt;/script&gt;

</code></pre>
<h3 id="问题"><a href="#问题" class="headerlink" title="问题"></a>问题</h3><p>用了  svg-sprite-loader 之后，不能通过 CSS 属性 <code>fill:color;</code>更改颜色。是因为这个 loader 默认给 svg 添加了 <code>fill:none;</code> 属性，导致更改不了。</p>
<p><img src="https://i.loli.net/2020/07/28/91batqBTO4pK3YE.png" alt="image-20200728155235199.png"></p>
<p>解决办法：通过<code>svgo-loader</code> 解决。通过这个 loader 我们可以添加很多插件，这些插件是基于 <code>svgo</code>，<code>svgo</code> 在安装 <code>svgo-loader</code> 的时候自动安装了。下面是 <code>svgo</code> 的截图：</p>
<p><img src="https://i.loli.net/2020/07/28/ot4XUBhmOurly9E.png" alt="image-20200728155531489.png"></p>
<p>回归正题，修改 vue.config.js 配置，去除默认加上的 <code>fill:none;</code> 属性：</p>
<pre><code class="javascript">// ...
.use(&quot;svgo-loader&quot;)
.loader(&quot;svgo-loader&quot;)
.options({
  plugins: [
    { removeAttrs: { attrs: &quot;(fill|stroke)&quot;,  } },
  ],
})
.end();
// ...

</code></pre>
<p>就这样，问题解决了~</p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>实现一个简易的webpack</title>
    <url>/2020/03/08/%E5%AE%9E%E7%8E%B0%E4%B8%80%E4%B8%AA%E7%AE%80%E6%98%93%E7%9A%84webpack/</url>
    <content><![CDATA[<h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>webpack 的官方解释如下：</p>
<blockquote>
<p>本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。</p>
</blockquote>
<p>简单理解，webpack 就是从入口开始，分析各个模块之间的相互依赖关系，最后将这些依赖模块生成 bundle。所以要手动实现一个 webpack，需要解决以下几个问题：</p>
<ul>
<li>获取入口文件和出口文件的路径；</li>
<li>分析入口文件的相关模块依赖；</li>
<li>递归分析其他模块的相关模块依赖；</li>
<li>生成模块之间的依赖关系；</li>
<li>解决浏览器不能识别 require 的问题，生成 bundle。</li>
</ul>
<h2 id="实现"><a href="#实现" class="headerlink" title="实现"></a>实现</h2><h3 id="文件目录结构"><a href="#文件目录结构" class="headerlink" title="文件目录结构"></a>文件目录结构</h3><pre><code>└───lib 目录
|     └───compiler.js // 主要 webpack 类，存放主要逻辑，如：调用 parser.js 相关方法，生成依赖关系图谱和 bundle。
|     └───parser.js // 获取 AST、依赖模块和最后生成的 code
|───src
|     └───index.js // 入口文件
|     └───module1.js // 模块 1，被 index.js 引用
|     └───module1-1.js // 模块 1-1，被 module1.js 引用
└───webpack.js // node 执行文件
└───webpack.config.js // webpack 配置信息
└───node_modules
└───package.json
</code></pre><ul>
<li>webpack.config.js</li>
</ul>
<pre><code class="javascript">const path = require(&#39;path&#39;);
module.exports = {
  entry: &#39;./src/index.js&#39;,
  output: {
    filename: &#39;bundle.js&#39;,
    path: path.resolve(__dirname, &#39;./dist&#39;)
  }
}
</code></pre>
<ul>
<li>webpack.js</li>
</ul>
<p>该文件作用是最后通过 <code>node webpack.js</code> 即可执行 webpack 代码逻辑，故：需要将 <code>lib/compiler.js</code> 引进并且执行，传入 webpack 的配置即可。</p>
<pre><code class="javascript">const Compiler = require(&quot;./lib/compiler&quot;);
const options = require(&quot;./webpack.config.js&quot;);

new Compiler(options).run();
</code></pre>
<h3 id="初始化-Compiler-类"><a href="#初始化-Compiler-类" class="headerlink" title="初始化 Compiler 类"></a>初始化 Compiler 类</h3><pre><code class="javascript">module.exports = class Compiler {
  constructor(options) {
    this.entry = options.entry;
    this.output = options.output;
    this.modules = []; // 存放所有依赖模块
  }
  /**
   * 主要执行函数
   */
  run() {
    // ...
  }
  /**
   * 获取单个文件的依赖关系、文件名和执行代码
   */
  build(entryFile) {
    // ...
  }
  /**
   * 获取 bundle
   */
  generateBundle() {
    // ... 
  }
}
</code></pre>
<h3 id="实现-parser-js"><a href="#实现-parser-js" class="headerlink" title="实现 parser.js"></a>实现 parser.js</h3><p>该文件主要实现由三点：</p>
<ul>
<li>获取 AST；</li>
<li>获取文件的所有依赖；</li>
<li>生成执行代码。</li>
</ul>
<p>在 index.js 中引进使用了 module1.js 模块，那么 index.js 的依赖模块就是 module1.js；在 module1.js 中引进使用了 module1-1.js 模块，那么 module1.js 的依赖模块就是 module1-1.js。想要获得模块的相关依赖模块，需要借助 AST（抽象语法树），从 AST 中我们可以获得模块的依赖。实现逻辑如下：</p>
<ul>
<li>获取文件的绝对路径，通过 <code>@babel/parser</code> 将目标文件中的代码转化为 AST；</li>
<li>通过 <code>@babel/traverse</code> 分析 AST 中的 <code>ImportDeclaration</code> 方法，可以得到该模块的所有依赖模块；</li>
<li>通过 <code>@babel/core</code> 中的 <code>transformFromAst</code> 可以将 AST 转化为 js 代码。</li>
</ul>
<p>最后所有的代码如下：</p>
<pre><code class="javascript">const fs = require(&quot;fs&quot;);
const path = require(&quot;path&quot;);
const parser = require(&quot;@babel/parser&quot;);
const traverse = require(&quot;@babel/traverse&quot;).default;
const { transformFromAst } = require(&quot;@babel/core&quot;);

module.exports = {
  // 分析模块，获取 ast
  getAst: fileName =&gt; {
    const content = fs.readFileSync(fileName, &quot;utf-8&quot;);
    const ast = parser.parse(content, {
      sourceType: &quot;module&quot; // module 模块模式
    });
    return ast;
  },
  // 获取依赖
  getDependencies: (ast, fileName) =&gt; {
    const dependencies = {}; // key: 相对路径 value: 根路径
    traverse(ast, {
      ImportDeclaration({ node }) {
        // dependencies.push(node.source.value); // 提取 import 依赖的相对路径
        const dirname = path.dirname(fileName);
        let newPath = path.join(dirname, node.source.value); // 拼接路径
        if (!/\.js$/.test(newPath)) { // 兼容解决 window 文件路径不带后缀问题
          newPath += &quot;.js&quot;;
        }
        dependencies[node.source.value] = newPath;
      }
    });
    return dependencies;
  },
  // 转换代码
  getCode: ast =&gt; {
    const { code } = transformFromAst(ast, null, {
      presets: [&quot;@babel/preset-env&quot;]
    });
    return code;
  }
};
</code></pre>
<h3 id="完成-compiler-js"><a href="#完成-compiler-js" class="headerlink" title="完成 compiler.js"></a>完成 compiler.js</h3><ul>
<li><code>build()</code>。这个方法的主要作用：获取单个文件的 AST、所有依赖模块的路径和执行代码。</li>
</ul>
<pre><code class="javascript">build(entryFile) {
  const ast = getAst(entryFile);
  const dependencies = getDependencies(ast, entryFile);
  const code = getCode(ast);
  return {
    fileName: entryFile,
    dependencies,
    code
  };
}
</code></pre>
<ul>
<li><code>run()</code>。这个方法的主要作用：<ul>
<li>从入口文件开始调用 build 方法（获取单个文件的 AST、所有依赖模块的路径和执行代码）；</li>
<li>将 build 方法返回的获取单个文件的 AST、所有依赖模块的路径和执行代码存进 modules 数组；</li>
<li>循环遍历 modules 数组，判断每个数组单元是否有自己的依赖（dependencies是否为空 ），有则继续调用 build 方法；</li>
<li>数组结构转化为 <code>key - value</code> 格式，<code>key</code> 是每个模块的相对路径，<code>value</code> 是 build 返回的结果。</li>
</ul>
</li>
</ul>
<pre><code class="javascript">run() {
  const info = this.build(this.entry);
  this.modules.push(info);
  for (let i = 0; i &lt; this.modules.length; i++) {
    const item = this.modules[i];
    const { dependencies } = item;
    if (dependencies) {
      for (let j in dependencies) {
        this.modules.push(this.build(dependencies[j]));
      }
    }
  }
  // 转换数据结构：数组 =&gt; 对象
  const obj = {};
  this.modules.forEach(item =&gt; {
    obj[item.fileName] = {
      dependencies: item.dependencies,
      code: item.code
    };
  });
  // 生成代码文件
  this.generateBundle(obj);
}
</code></pre>
<ul>
<li><code>generateBundle()</code>。重写 require 方法，生成 bundle。</li>
</ul>
<p>通过将 run 最后生成的 <code>key - value</code> 对象进行解析，通过 <code>eval</code> 执行代码，遇到 <code>require()</code> 方法，调用本地的 <code>localRequire()</code> 方法。</p>
<pre><code class="javascript">generateBundle(code) {
  // 获取输出信息
  const filePath = path.join(this.output.path, this.output.filename); // dist 路径
  const newCode = JSON.stringify(code);
  const bundle = `(function(graph){
    function require(module) {
      function localRequire(relativePath) {
        return require(graph[module].dependencies[relativePath]);
      }
      var exports = {};
      (function(require, exports, code) {
        eval(code)
      })(localRequire, exports, graph[module].code)
      return exports;
    }
    require(&#39;${this.entry}&#39;);
  })(${newCode})`;

  fs.writeFileSync(filePath, bundle, &quot;utf-8&quot;);
}
</code></pre>
<h2 id="测试"><a href="#测试" class="headerlink" title="测试"></a>测试</h2><p>执行 <code>node webpack.js</code>，获取生成的 bundle.js。</p>
<pre><code class="javascript">(function(graph){
      function require(module) {
        function localRequire(relativePath) {
          return require(graph[module].dependencies[relativePath]);
        }
        var exports = {};
        (function(require, exports, code) {
          eval(code)
        })(localRequire, exports, graph[module].code)
        return exports;
      }
      require(&#39;./src/index.js&#39;);
    })({&quot;./src/index.js&quot;:{&quot;dependencies&quot;:{&quot;./module1.js&quot;:&quot;src\\module1.js&quot;},&quot;code&quot;:&quot;\&quot;use strict\&quot;;\n\nvar _module = require(\&quot;./module1.js\&quot;);\n\ndocument.write((0, _module.module1)());&quot;},&quot;src\\module1.js&quot;:{&quot;dependencies&quot;:{&quot;./module1-1.js&quot;:&quot;src\\module1-1.js&quot;},&quot;code&quot;:&quot;\&quot;use strict\&quot;;\n\nObject.defineProperty(exports, \&quot;__esModule\&quot;, {\n  value: true\n});\nexports.module1 = module1;\n\nvar _module = require(\&quot;./module1-1.js\&quot;);\n\nfunction module1() {\n  return &#39;module1&#39; + (0, _module.module2)();\n}&quot;},&quot;src\\module1-1.js&quot;:{&quot;dependencies&quot;:{},&quot;code&quot;:&quot;\&quot;use strict\&quot;;\n\nObject.defineProperty(exports, \&quot;__esModule\&quot;, {\n  value: true\n});\nexports.module2 = module2;\n\nfunction module2() {\n  return &#39;module2&#39;;\n}&quot;}})
</code></pre>
<p>执行结果如下：</p>
<p><img src="https://i.loli.net/2020/03/08/WT6M8G5tbr1kR7N.png" alt="res.png"></p>
]]></content>
      <tags>
        <tag>webpack</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序文件生成脚本</title>
    <url>/2020/02/06/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E6%96%87%E4%BB%B6%E7%94%9F%E6%88%90%E8%84%9A%E6%9C%AC/</url>
    <content><![CDATA[<h3 id="痛点"><a href="#痛点" class="headerlink" title="痛点"></a>痛点</h3><p>开发微信小程序，当需要新增页面或者组件的时候，需要手动增加一个目录和四个文件。如果是页面的话，还需要将页面路由添加到 <em>app.json</em> 文件中。这样一旦增加页面或者组件多了，是十分繁琐的。重复工作用脚本替代。</p>
<h3 id="技术"><a href="#技术" class="headerlink" title="技术"></a>技术</h3><p><strong>node.js</strong></p>
<h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3><ul>
<li>读取命令行参数，获取目录类型和目录名称。</li>
<li>生成目录和四个文件。</li>
<li>如果是页面类型，则将页面路由添加到 <em>app.json</em> 文件中。</li>
</ul>
<h3 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h3><ul>
<li>安装依赖：<em>npm install</em>。</li>
<li>链接生成本地命令：<em>npm link</em>。</li>
<li>命令<ul>
<li><code>make-mp-file -t page -n name</code></li>
<li><code>make-mp-file -t component -n name</code></li>
</ul>
</li>
<li>参数<ul>
<li><em>-t</em> 或 <em>–type</em>：<em>page</em> 或者 <em>component</em></li>
<li><em>-n</em> 或 <em>–name</em>：组件或者页面名称。</li>
</ul>
</li>
</ul>
<h3 id="github-地址"><a href="#github-地址" class="headerlink" title="github 地址"></a>github 地址</h3><p><a href="https://github.com/Ertsul/make-mp-file" target="_blank" rel="noopener">链接地址</a></p>
]]></content>
      <categories>
        <category>minapp</category>
      </categories>
      <tags>
        <tag>minapp</tag>
      </tags>
  </entry>
  <entry>
    <title>广度优先搜索 BFS 和深度优先搜索 DFS</title>
    <url>/2019/12/14/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS-%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/</url>
    <content><![CDATA[<p>最近在写 <code>virtual dom</code> 方面的逻辑，用到 <code>BFS</code> 和 <code>DFS</code>。总结一波~😀</p>
<p><code>Virtual Dom</code> 的示例 <code>json</code> 如下：</p>
<pre><code class="javascript">const vNode = {
  node: &quot;root&quot;,
  child: [
    {
      node: &quot;element1&quot;,
      child: [
        {
          node: &quot;element3&quot;
        },
        {
          node: &quot;element4&quot;
        }
      ]
    },
    {
      node: &quot;element2&quot;
    }
  ]
};

</code></pre>
<p><code>Virtual Dom</code> 的树如下：</p>
<p><img src="https://i.loli.net/2019/12/13/Li2XeM8a46u3jZV.png" alt="image.png"></p>
<h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索  BFS"></a>广度优先搜索  BFS</h3><p><code>BFS</code> ：逐层访问节点，从左到右访问完成一层访问后，访问下一层，且每个节点只访问一次。</p>
<p>上面的树用 <code>BFS</code> 顺序就是：<code>root</code> -&gt; <code>element1</code> -&gt; <code>element2</code> -&gt; <code>element3</code> -&gt; <code>element4</code>。</p>
<p>实现思路：</p>
<ul>
<li>设置队列 <code>queue</code>，就将<strong>根节点</strong>添加到队列 <code>queue</code>；</li>
<li>判断当队列 <code>queue</code> 是否为空，不为空则弹出队头节点 <code>currentNode</code>；</li>
<li>将队头节点 <code>currentNode</code> 添加到结果队列 <code>lists</code>；</li>
<li>判断队头节点 <code>currentNode</code> 是否有子节点，有则将子节点<strong>从左到右</strong>依次添加到队列 <code>queue</code>；</li>
<li>重复步骤2~4。</li>
</ul>
<p>简单理解就是：</p>
<ul>
<li>根节点进队列；</li>
<li>判断队头节点是否子节点，有则将子节点<strong>从左到右</strong>依次进队列，队头节点出队列。</li>
<li>重复2。</li>
</ul>
<p>用 <code>js</code> 代码实现如下：（注意：判断条件为队列长度）</p>
<pre><code class="javascript">/**
 * BFS 非递归写法
 * @param {*} root 根节点
 */
const BFS = root =&gt; {
  if (Object.prototype.toString.call(root) != &#39;[object Object]&#39;) {
    throw(new Error(&#39;root 类型错误！&#39;));
    return;
  }
  let resLists = []; // 存放 BFS 节点队列
  if (!Object.keys(root).length) {
    return lists;
  }
  let queue = []; // 临时队列，每遇到一个节点就存放进队列
  queue.unshift(root);
  while (queue.length) {
    // queue 队列不为空，遍历临时队列
    let currentNode = queue.pop(); // 弹出临时队列的一个节点
    const hasChild =
      currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点
    if (hasChild) {
      const childrenNodes = currentNode.child; // 子节点数组
      for (let i = 0, len = childrenNodes.length; i &lt; len; i++) {
        const currentChildNode = childrenNodes[i]; // 当前子节点
        queue.unshift(currentChildNode); // 添加到队列
      }
    }
    resLists.push(currentNode); // 当前节点存放到 BFS 节点队列
  }
  return resLists;
};
</code></pre>
<p>结果如下：</p>
<p><img src="https://i.loli.net/2019/12/13/fQRoxlaeU1mXEku.png" alt="image.png"></p>
<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索  DFS"></a>深度优先搜索  DFS</h3><p> <code>DFS</code>：对每一个可能的分支路径深入到不能再深入为止，且每个节点只访问一次。</p>
<p>上面的树用 <code>BFS</code> 顺序就是：<code>root</code>  -&gt; <code>element1</code> -&gt; <code>element3</code> -&gt; <code>element4</code> -&gt; <code>element2</code>。</p>
<p>实现思路1（非递归）:</p>
<ul>
<li>根节点进栈 <code>stack</code>；</li>
<li>判断栈 <code>stack</code> 是否为空，判断栈顶元素是否有有子节点，有则将栈顶元素的子节点<strong>从右到左</strong>依次进栈；</li>
<li>弹出栈顶元素，存进 <code>lists</code>;</li>
<li>重复2~3；</li>
</ul>
<p>简单理解就是：</p>
<ul>
<li>根节点进栈；</li>
<li>弹出栈顶元素，判断栈顶元素是否子节点，有则将子节点<strong>从右到左</strong>依次进栈；</li>
<li>重复2。</li>
</ul>
<p>代码如下：（注意：判断条件为栈长度）</p>
<pre><code class="javascript">const DFS = root =&gt; {
  if (Object.prototype.toString.call(root) != &quot;[object Object]&quot;) {
    throw new Error(&quot;root 类型错误！&quot;);
  }
  let resLists = []; // 存放 BFS 节点队列
  if (!Object.keys(root).length) {
    return lists;
  }
  let stack = []; // 栈，每遇到一个节点就存放进栈
  stack.push(root);
  while (stack.length) {
    let currentNode = stack.pop(); // 弹出栈顶元素
    const hasChild =
      currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点
    if (hasChild) {
      const childrenNodes = currentNode.child; // 子节点数组
      for (let i = childrenNodes.length - 1; i &gt;= 0; i--) {
        const currentChildNode = childrenNodes[i]; // 当前子节点
        stack.push(currentChildNode); // 添加到队列
      }
    }
    resLists.push(currentNode); // 当前节点存放到 DFS 结果列表
  }
  return resLists;
};
</code></pre>
<p>实现思路2（递归）：</p>
<ul>
<li>当前节点入栈 <code>stack</code>；</li>
<li>判断当前节点是否有子节点；</li>
<li>有子节点：<ul>
<li>将子节点从右到左依次进行递归；（栈是先进后出 ）</li>
<li>所有子节点递归结束，当前节点出栈；</li>
</ul>
</li>
<li>无：<ul>
<li>当前节点出栈。</li>
</ul>
</li>
</ul>
<p>代码实现如下：（注意：判断关键为节点是否有子节点）</p>
<pre><code class="javascript">var stack = []; // 栈
var lists = []; // 存放 DFS 节点
/**
 * 全局变量实现
 * @param {*} currentNode : 当前节点
 */
const DFS = currentNode =&gt; {
  let hasChild =
    currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点

  stack.push(currentNode); // 推入栈
  if (hasChild) {
    let len = currentNode.child.length;
    for (let i = len - 1; i &gt;= 0; i--) {
      const currentChildNode = currentNode.child[i]; // 当前子节点
      DFS(currentChildNode); // 递归
    }
    lists.unshift(stack.pop()); // 出栈
  } else {
    lists.unshift(stack.pop()); // 出栈
  }
};
</code></pre>
<pre><code class="javascript">/**
 * 非全局变量方式实现
 * @param {*} currentNode : 当前节点
 * @param {*} cache : 缓存栈和节点
 */
const DFS = (currentNode = {}, cache = { lists: [], stack: [] }) =&gt; {
  if (Object.prototype.toString.call(currentNode) != &quot;[object Object]&quot;) {
    throw new Error(&quot;root 类型错误！&quot;);
  }
  let hasChild =
    currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点

  let { lists, stack } = cache;

  stack.push(currentNode); // 推入栈
  if (hasChild) {
    let len = currentNode.child.length;
    for (let i = len - 1; i &gt;= 0; i--) { // 注意这里要从右向左循环，因为 stack 是先进后出
      const currentChildNode = currentNode.child[i]; // 当前子节点
      const {
        lists: newLists,
        stack: newStack
      } = DFS(currentChildNode, {
        lists,
        stack
      }); // 递归
      lists = newLists; // 更新 lists
      stack = newStack; // 更新栈
    }
    lists.unshift(stack.pop()); // 出栈
  } else {
    lists.unshift(stack.pop()); // 出栈
  }
  // 函数返回结果，如果栈中还有节点，证明还没回溯完成，则返回缓存；否则函数执行结束
  const res = stack.length
    ? {
        lists: lists,
        stack: stack
      }
    : lists;
  return res;
};
</code></pre>
<p>结果如下：</p>
<p><img src="https://i.loli.net/2019/12/13/WoE4fxkBRCs3NOd.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序工程化</title>
    <url>/2019/11/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a><em>gulp</em></h2><p><a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">👉官方文档传送门</a></p>
<h2 id="gulp-编译项目"><a href="#gulp-编译项目" class="headerlink" title="gulp 编译项目"></a><em>gulp</em> 编译项目</h2><p>日常进行小程序开发，遇到的问题有：</p>
<ul>
<li>如果在微信开发者工具进行开发的话，效率低；</li>
<li>不支持 <em>less</em> css预编译器 ；</li>
<li><em>autoprefixer</em> ；</li>
<li>…</li>
</ul>
<p>考虑到小程序是多页面应用，我们只要在 <em>src</em> 目录添加小程序初始化时所需要的相关配置文件，然后通过 <em>gulp</em> 将 <em>src</em> 下的代码搬移到 <em>dist</em> 打包目录即可。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre><code>└───gulpTask 目录：主要存放 gulp 代码逻辑
|     └───baseConfig.js // gulp 路径和 blob 配置信息
|     └───clean.js // 清理 dist nodejs 脚本文件
|     └───taskControler.js // gulp 任务定义
|───src
|     └───common // 公共代码
|         └───less
|             └───...
|         └───js
|             └───...
|     └───components // 组件
|             └───...
|     └───pages // 页面
|             └───...
|     └───router // 路由
|             └───router.js // 路由处理逻辑
|             └───routerPath.js // 路由表
|     └───api // 请求数据接口统一处理
|             └───api.js
|     └───http // http 网络请求
|             └───baseConfig.js // 基本配置
|             └───devConfig.js // 开发基本配置
|             └───prodConfig.js // 生产基本配置
|             └───request.js // 请求处理逻辑
|    └───app.js
|    └───app.json
|    └───project.config.json
|    └───sitemap.json
└───.eslintrc // eslint 配置
└───.gitignore // git 配置
└───gulpfile.js // gulp 主入口
└───package.json
└───README.md
</code></pre><h3 id="gulp-配置文件-baseConfig-js"><a href="#gulp-配置文件-baseConfig-js" class="headerlink" title="gulp 配置文件 baseConfig.js"></a><em>gulp</em> 配置文件 <em>baseConfig.js</em></h3><p>将 <em>gulp</em> 相关路径和 <em>blob</em> 配置信息统一在 <em>baseConfig.js</em> 中进行配置。</p>
<pre><code class="javascript">const path = require(&quot;path&quot;);

const srcPath = path.resolve(__dirname, &quot;../src&quot;);
const distPath = path.resolve(__dirname, &quot;../dist&quot;);
const isDev = process.argv.includes(&quot;--development&quot;);

module.exports = {
  isDev, // 当前环境
  srcPath, // src 源路径
  distPath, // dist 编译目标路径
  basePath: [
    srcPath
  ],
  otherPath: [
    srcPath,
    `!${srcPath}/**/**/*.less`,
    `!${srcPath}/**/**/*.wxml`,
    `!${srcPath}/**/**/*.json`,
    `!${srcPath}/**/**/*.js`,
    `!${srcPath}/static/icons/*.jpg`,
    `!${srcPath}/static/icons/*.png`,
    `!${srcPath}/static/images/*.jpg`,
    `!${srcPath}/static/images/*.png`,
  ],
  lessPath: [ // less blob
    `${srcPath}/**/**/*.less`,
  ],
  jsPath: [ // js blob
    `${srcPath}/**/**/*.js`,
  ],
  wxmlPath: [ // wxml blob
    `${srcPath}/**/**/*.wxml`,
  ],
  jsonPath: [ // json blob
    `${srcPath}/**/**/*.json`,
  ],
  lessImportPath: [
    `${srcPath}/common/less/*.less`
  ],
  iconPath: [
    `${srcPath}/static/icons/*.jpg`,
    `${srcPath}/static/icons/*.png`
  ],
  imagePath: [
    `${srcPath}/static/images/*.jpg`,
    `${srcPath}/static/images/*.gif`,
    `${srcPath}/static/images/*.png`
  ]
}
</code></pre>
<h3 id="gulp-开发流程"><a href="#gulp-开发流程" class="headerlink" title="gulp 开发流程"></a><em>gulp</em> 开发流程</h3><p>主要流程如下：</p>
<p><img src="https://i.loli.net/2019/11/05/yxatp6HzRUAm9G4.png" alt="image-20191105174239088.png"></p>
<h4 id="gulp-的各个任务：（taskControler-js-文件）"><a href="#gulp-的各个任务：（taskControler-js-文件）" class="headerlink" title="gulp 的各个任务：（taskControler.js 文件）"></a><em>gulp</em> 的各个任务：（<em>taskControler.js</em> 文件）</h4><ul>
<li><p>每次进行 <em>gulp</em> 任务前都要清空 <em>dist</em> 打包后的目录。主要代码如下：</p>
<pre><code class="javascript">task(&quot;clean:dist&quot;, done =&gt; {
    // console.log(&quot;:::: clean:dist&quot;);

    src(baseConfig.distPath, {
        read: true,
        allowEmpty: true,
    })
        .pipe(clean())

    done();
})
</code></pre>
<p>但是，上面这样处理会有问题：第二次运行 <em>gulp</em> 命名的时候会有文件权限等问题。故：<em>dist</em> 文件的处理通过 <em>nodejs</em> 进行处理。</p>
<pre><code class="javascript">// gulp-clean 清空 dist 命令会有权限等一系列问题，故：直接用 node 进行删除 dist
const path = require(&quot;path&quot;);
const chalk = require(&quot;chalk&quot;);
const rimraf = require(&quot;rimraf&quot;);

const distPath = path.resolve(__dirname, &#39;../dist&#39;);
rimraf(distPath, err =&gt; {
  if (err) {
    console.log(chalk.red(err));
  }
})
</code></pre>
<p>然后在 <em>package.json</em> 中配置脚本命令：</p>
<pre><code class="json">&quot;scripts&quot;: {
    &quot;build:dev&quot;: &quot;node gulpTask/clean.js &amp;&amp; gulp dev --development&quot;,
    &quot;build:prod&quot;: &quot;node gulpTask/clean.js &amp;&amp; gulp prod --production&quot;
},
</code></pre>
<p>这样每次执行 <em>gulp</em> 命令前都会删除 <em>dist</em> 目录。</p>
</li>
<li><p>处理 <em>less</em> 文件。需要解决的问题有：</p>
<ul>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
<li>自动添加属性前缀，<em>autoperfixer</em>；</li>
<li>将 <em>less</em> 文件的后缀更改为 <em>wxss</em>；</li>
<li>将 <em>less</em> 文件内部的 <em>@import</em> 引用文件的后缀更改为 <em>wxss</em>。</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:less&quot;, done =&gt; {
    // console.log(&quot;:::: compile:less&quot;);

    src(baseConfig.lessPath, {
        base: &quot;src&quot;
    })
        .pipe(changed(baseConfig.distPath))
        .pipe(gulpif(!this.isDev, cleanCss()))
        .pipe(autoprefixer())
    // .pipe(less({
    //   paths: baseConfig.lessImportPath,
    //   plugins: [autoprefix]
    // }))
        .pipe(rename(function (path) { // 更改 .less 文件后缀为 .wxss
        path.extname = &quot;.wxss&quot;;
    }))
        .pipe(replace(/\.less/g, &quot;.wxss&quot;)) // 修改 less 文件内部的引用 .less 文件后缀为 .wxss
        .pipe(dest(baseConfig.distPath));

    done();
})
</code></pre>
<p>这里遇到一个坑，用 l<em>ess-plugin-autoprefix @import</em> 会有问题，<em>@import</em> 语句会被删除。后面改用 <em>gulp-autoprefixer</em>。</p>
</li>
<li><p>处理 <em>js</em> 文件。需要解决的问题有：</p>
<ul>
<li><em>eslint</em> 代码格式检查；</li>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:js&quot;, done =&gt; {
  // console.log(&quot;:::: compile:js&quot;);

  src(baseConfig.jsPath, {
      base: &quot;src&quot;
    })
    .pipe(changed(baseConfig.distPath))
    // .pipe(babel({ // 先通过 babel 转化语法然后才能进行压缩 --&gt; 微信开发者工具有 es6 转 es5 功能
    //   presets: [&quot;@babel/env&quot;]
    // }))
    .pipe(eslint())
    // .pipe(eslint.format())
    .pipe(gulpif(!this.isDev, uglify()))
    .pipe(dest(baseConfig.distPath));

  done();
})
</code></pre>
<p>这里原本加了 <em>babel</em> 进行 <em>es6</em> 到 <em>es5</em> 的转化，但是微信开发者工具本身就有这个功能，故去除。另一个坑是，用 <em>gulp-uglify</em> 不能进行 <em>es6</em> 代码的压缩，要用 <em>gulp-uglify-es</em> 。</p>
</li>
<li><p>处理 <em>wxml</em> 文件。需要解决的问题有：</p>
<ul>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:wxml&quot;, done =&gt; {
  // console.log(&quot;:::: compile:wxml&quot;);

  src(baseConfig.wxmlPath, {
      base: &quot;src&quot;
    })
    .pipe(changed(baseConfig.distPath))
    .pipe(gulpif(!this.isDev, htmlmin({
      collapseWhitespace: true
    })))
    .pipe(dest(baseConfig.distPath));

  done();
})
</code></pre>
</li>
<li><p>处理 <em>json</em> 文件。需要解决的问题有：</p>
<ul>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:json&quot;, done =&gt; {
  // console.log(&quot;:::: compile:json&quot;);

  src(baseConfig.jsonPath, {
      base: &quot;src&quot;
    })
    .pipe(changed(baseConfig.distPath))
    .pipe(gulpif(!this.isDev, prettyData({
      type: &quot;minify&quot;,
      preserveComments: true,
      extensions: {
        &quot;json&quot;: &quot;json&quot;,
      }
    })))
    .pipe(dest(baseConfig.distPath));

  done();
})
</code></pre>
</li>
<li><p>其他所有文件。</p>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:other&quot;, done =&gt; {
      // console.log(&quot;:::: compile:other&quot;);

      src(baseConfig.otherPath, {
          base: &quot;src&quot;
        })
        .pipe(changed(baseConfig.distPath))
        .pipe(dest(baseConfig.distPath));

      done();
    })
</code></pre>
</li>
<li><p>图片压缩。</p>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;minify:image&quot;, async done =&gt; {
  // console.log(&quot;:::: minify:image&quot;);

  src(baseConfig.imagePath, {
      base: &quot;src&quot;
    })
    .pipe(imagemin([imagemin.optipng(), imagemin.gifsicle(), imagemin.jpegtran()]))
    .pipe(dest(baseConfig.distPath))

  done();
})
</code></pre>
</li>
<li><p>开发环境开启监控 <em>watch</em>。</p>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;watch&quot;, done =&gt; {
  // console.log(&quot;:::: compile:other&quot;);

  watch(baseConfig.basePath, {
    base: &quot;src&quot;
  }, series(&quot;compile:less&quot;, &quot;compile:js&quot;, &quot;compile:wxml&quot;, &quot;compile:json&quot;, &quot;compile:other&quot;, &quot;minify:image&quot;))

  done();
})
</code></pre>
</li>
<li><p>最后，将任务进行 <em>id</em> 绑定处理，还有不同环境的区分。主要代码如下：</p>
<pre><code class="javascript">task(&quot;default&quot;, parallel(&quot;compile:less&quot;, &quot;compile:js&quot;, &quot;compile:wxml&quot;, &quot;compile:json&quot;, &quot;compile:other&quot;, &quot;minify:image&quot;));
task(`dev-${id}`, series(&quot;default&quot;, &quot;watch&quot;));
task(`prod-${id}`, series(&quot;default&quot;));
</code></pre>
</li>
</ul>
<h4 id="gulp-入口文件处理：（gulpfile-js-文件）"><a href="#gulp-入口文件处理：（gulpfile-js-文件）" class="headerlink" title="gulp 入口文件处理：（gulpfile.js 文件）"></a><em>gulp</em> 入口文件处理：（<em>gulpfile.js</em> 文件）</h4><p>主要是对不同环境的区分，还有 <em>taskControler.js</em> 定义的各个任务进行引用。主要代码如下：</p>
<pre><code class="javascript">const {
  task,
  series
} = require(&quot;gulp&quot;);
const TaskControler = require(&quot;./gulpTask/taskControler&quot;);
// 项目 ID
const id = require(&quot;./package.json&quot;).name || &quot;min-program&quot;;

new TaskControler(id);

/*---------- 相关的 gulp 任务 ----------*/

// dev 开发环境任务
task(&quot;dev&quot;, series(`dev-${id}`));

// prod 生产环境任务
task(&quot;prod&quot;, series(`prod-${id}`));
</code></pre>
<p>接着，只需要执行 <code>npm run build:dev</code>或 <code>npm run build:prod</code>，然后将生成的 <em>dist</em> 目录丢到微信开发者工具即可。</p>
<h2 id="路由封装"><a href="#路由封装" class="headerlink" title="路由封装"></a>路由封装</h2><ul>
<li><p>路由表文件</p>
<pre><code class="javascript">/**
 * 路由路径
 */
const routerPath = {
  index: &quot;/pages/index/index&quot;,
  detail: &quot;/pages/detail/detail&quot;,
}

module.exports = routerPath;
</code></pre>
</li>
<li><p>路由逻辑处理</p>
<p>最后使用路由的方式为：</p>
<pre><code class="javascript">app.Router.push({
    path: &#39;detail&#39;,
    query: {
        name: &#39;Ertsul&#39;,
        age: 23
    }
})
</code></pre>
<p>需要处理的问题有：路由参数转化为小程序的格式、有参无参路由。</p>
<p>路由参数转化为小程序的格式。</p>
<pre><code class="javascript">/**
 * 处理路由参数，拼接成字符串形式
 * @param {*} queryObj ： 路由参数
 */
function dealQuery(queryObj) {
  let tempArr = [];
  for (let key in queryObj) {
    if (queryObj.hasOwnProperty(key)) {
      const value = queryObj[key];
      const item = `${key}=${value}`;
      tempArr.push(item);
    }
  }
  return &quot;?&quot; + tempArr.join(&quot;&amp;&quot;);
}
</code></pre>
<p>封装一个对象，添加 <em>push</em> 对外暴露的方法，添加内部跳转的方法。</p>
<pre><code class="javascript">let Router = {
  /**
   * 
   * @param {String} param0 : 路径
   * @param {Object} param1 : 参数
   * @param {String} param2 : 类型，redirectTo/reLaunch/back/navigateTo
   */
  push({
    path = &quot;&quot;,
    query = {},
    type = &quot;navigateTo&quot;
  }) {
    if (!path) {
      return;
    }
    // 获取对应的小程序路径
    let url = routerPath[path] || routerPath[&#39;index&#39;];
    let params = &quot;&quot;;
    // 处理 query 
    if (Object.keys(query) &amp;&amp; Object.prototype.toString.call(query) == &#39;[object Object]&#39;) {
      params = dealQuery(query);
    } else {
      console.error(&quot;路由参数类型错误！&quot;);
      return;
    }
    url += params;
    this.to(url, type); // 执行跳转
  },
  /**
   * 
   * @param {*} url : 路径 + 参数
   * @param {*} type : 类型，redirectTo/reLaunch/back/navigateTo
   */
  to(url, type = &quot;&quot;) {
    switch (type) {
      case &quot;redirectTo&quot;:
        wx.redirectTo({
          url
        });
        break;
      case &quot;reLaunch&quot;:
        wx.reLaunch({
          url
        });
        break;
      case &quot;back&quot;:
        wx.navigateBack({
          delta: 1
        });
        break;
      case &quot;navigateTo&quot;:
        wx.navigateTo({
          url
        });
        break;
    }
  }
}
</code></pre>
<p>最后将 <em>Router</em> 对象挂载到 <em>app</em> 对象。</p>
<pre><code class="javascript">const Router = require(&quot;./router/router&quot;);

//app.js
App({
  Router,
  ...
})
</code></pre>
</li>
</ul>
<h2 id="http-封装及其接口统一管理"><a href="#http-封装及其接口统一管理" class="headerlink" title="http 封装及其接口统一管理"></a>http 封装及其接口统一管理</h2><p><em>http</em> 封装，可以添加一些请求公共参数等。核心代码为：</p>
<pre><code class="javascript">function request({
  url = &#39;&#39;,
  data = {},
  method = &#39;POST&#39;,
  header = {
    &#39;content-type&#39;: &#39;application/json&#39; // 默认值
  }
}) {
  return new Promise(async (resolve, reject) =&gt; {
    wx.request({
      url,
      data,
      method,
      header,
      success(res) {
        resolve(res);
      },
      fail(err) {
        reject(err);
      }
    })
  })
}
</code></pre>
<p>接口统一管理。接口统一管理有利于后期维护。</p>
<pre><code class="javascript">const request = require(&#39;../http/request&#39;);
const baseConfig = require(&#39;../http/baseConfig&#39;);

// get 例子
const getList = request({
  method: &#39;GET&#39;,
  url: baseConfig.baseUrl + &#39;/list?page=1&amp;size=10&#39;,
})

// post 例子
const updateInfo = request({
  method: &#39;POST&#39;,
  url: baseConfig.baseUrl + &#39;/updateInfo&#39;,
  data: {
    name: &#39;Ertsul&#39;,
    age: 23
  }
})

module.exports = {
  getList,
  updateInfo
}
</code></pre>
]]></content>
      <categories>
        <category>minapp</category>
      </categories>
      <tags>
        <tag>minapp</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 操作（补充）</title>
    <url>/2019/10/12/Git-%E6%93%8D%E4%BD%9C%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89/</url>
    <content><![CDATA[<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p><em>cherry-pick</em> 可以将分支 <em>B</em> 的任何<strong>一个</strong> <em>commit</em> 合并到分支 <em>A</em>。</p>
<p><strong>情景</strong>：<em>dev</em> 分支有两个 <em>commit</em>，分别是：创建 <em>b.txt</em> 文件 <em>commitB</em>、创建 <em>c.txt</em> 文件 <em>commitC</em>。现在我们只想要合并 <em>commitAB 到 </em>master<em> 分支。下面是 </em>master<em> 和 </em>dev* 两个分支的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-049b7c95c62a3131.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d46ecad032fee3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果直接用 <em>git merge</em> 会将 <em>commitC</em> 也合并到 <em>master</em>，这不是我们想要的结果。这时候，<em>cherry-pick</em> 就派上用场了。用法如下：</p>
<ul>
<li>切换到目标分支。</li>
<li><em>cherry-pick</em> 待合并的 <em>commitID</em>。</li>
</ul>
<p>上面的情景，只需要：</p>
<pre><code class="powershell">git checkout master
git cherry-pick 8f2aa26
</code></pre>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-4c396adb0bb8588a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>不过，<em>cherry-pick</em> 只能合并单个指定的 <em>commit</em>。☞ <a href="http://git-scm.com/docs/git-cherry-pick" target="_blank" rel="noopener">cherry-pick 更多操作</a></p>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p><em>rebase变基</em> 是 <em>Git</em> 中整合来自不同分支修改的一种操作。（另一种是 <em>merge</em>）</p>
<p><strong>情景1</strong>：<em>dev</em> 分支有两个 <em>commit</em> ，分别是：创建 <em>d.txt</em> 文件 <em>commitD</em>、创建 <em>e.txt</em> 文件 <em>commitE</em>。现在我们想要将 <em>dev</em> 分支的所有 <em>commit</em> 合并到 <em>master</em>。下面是 <em>dev</em> 分支的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-293e36b78fb47d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>想要通过 <em>rebase</em> 变基将 <em>commit</em> 合并到 <em>master</em>，只需要：</p>
<ul>
<li>将 <em>dev</em> 分支变基到 <em>master</em> 分支。</li>
<li>切换到 <em>master</em> 分支。</li>
<li>执行 <em>merge</em> 操作。</li>
</ul>
<pre><code class="powershell">git rebase master
git checkout master 
git merge --no-ff dev
</code></pre>
<p>最后结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-0417d63fc36aef1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1570868576457.png"></p>
<p>通过 <em>rebase</em> 合并分支跟 <em>merge</em> 合并是不一样的。☞ <a href="[http://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA](http://git-scm.com/book/zh/v2/Git-分支-变基">点击查看区别</a>)</p>
<p><strong>情景2</strong>：<em>dev</em> 分支上有四个 <em>commit</em>，顺序分别是：创建 <em>f.txt</em> 文件 <em>commitF</em>、增加 <em>f.txt</em> 文件内容 <em>commitF1</em>、创建 <em>g.txt</em> 文件 <em>commitG</em>、增加 <em>g.txt</em> 文件内容 <em>commitG1</em>。现在只想要将 <em>dev</em> 分支上关于文件 <em>f.txt</em> 的所有操作合并到 <em>master</em> 分支。下面是 <em>dev</em> 分支的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-b9f954b059404b15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现在只想要将 <em>dev</em> 分支上关于文件 <em>f.txt</em> 的所有操作合并到 <em>master</em> 分支，需要：</p>
<ul>
<li>以 <em>f.txt</em> 的最后一个修改的 <em>commitID</em> 新建一个分支 <em>dev-temp</em>。</li>
<li>将以 <em>dev-temp</em> 分支上关于 <em>f.txt</em> 的第一个修改的 <em>commitID</em> <em>rabase</em> 变基到 <em>master</em> 分支。</li>
<li>切换到 <em>master</em> 分支。</li>
<li><em>merge</em> <em>dev-temp</em> 分支到 <em>master</em> 分支。</li>
</ul>
<pre><code class="powershell">git checkout -b dev-temp 884c858
git rebase --onto master 3b0bfd7^
git checkout master 
git merge --no-ff dev-temp
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-e52de0c710b4437c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>情景3</strong>：<em>dev</em> 分支上有四个 <em>commit</em>，顺序分别是：创建 <em>i.txt</em> 文件 <em>commitI</em>、增加 <em>i.txt</em> 文件内容 <em>commitI1</em>、创建 <em>j.txt</em> 文件 <em>commitJ</em>、增加 <em>j.txt</em> 文件内容 <em>commitJ1</em>。现在只想要将 <em>dev</em> 分支上关于文件 <em>j.txt</em> 的所有操作合并到 <em>master</em> 分支。下面是 <em>dev</em> 分支的情况：（其实跟上面的情况和操作一样）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-59f2f8f60f66ef93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现在只想要将 <em>dev</em> 分支上关于文件 <em>j.txt</em> 的所有操作合并到 <em>master</em> 分支，需要：</p>
<ul>
<li>以 <em>j.txt</em> 的最后一个修改的 <em>commitID</em> 新建一个分支 <em>dev-temp1</em>。</li>
<li>将以 <em>dev-temp1</em> 分支上关于 <em>j.txt</em> 的第一个修改的 <em>commitID</em> <em>rabase</em> 变基到 <em>master</em> 分支。</li>
<li>切换到 <em>master</em> 分支。</li>
<li><em>merge</em> <em>dev-temp1</em> 分支到 <em>master</em> 分支。</li>
</ul>
<pre><code class="powershell">git checkout -b dev-temp1 54ea4bd
git rebase --onto master e31249b^
git checkout master 
git merge --no-ff dev-temp1
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-8507dd6818db90d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><a href="[http://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA](http://git-scm.com/book/zh/v2/Git-分支-变基">rebase更多操作</a>)</p>
<h2 id="合并多个-commit-为一个-commit"><a href="#合并多个-commit-为一个-commit" class="headerlink" title="合并多个 commit 为一个 commit"></a>合并多个 commit 为一个 commit</h2><p>合并多个 <em>commit</em> 为一个 <em>commit</em> 同样需要 <em>rebase</em>。</p>
<p>如下图：要将最新的两个 <em>commit</em> 合并为一个 <em>commit</em>。具体操作如下：</p>
<ul>
<li><p>找到这三个 <em>commit</em> 的前一个 <em>commit</em> 的 <em>commitID</em>，执行 <code>git rebase -i commitID</code></p>
</li>
<li><p>这时候会进入 <em>vi</em> 编辑。</p>
<ul>
<li><code>pick</code> 的意思是要会执行这个 <em>commit</em></li>
<li><code>squash</code> 的意思是这个 commit 会被合并到前一个 <em>commit</em></li>
</ul>
</li>
<li><p>之后会进入 <em>vi</em> 编辑 <em>commit</em> 信息。只需要将原先的 <em>commit</em> 信息注释，在顶部添加新的 <em>commit</em> 信息。</p>
</li>
<li><p>完成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-a8a97ecd1b5c4901.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-5528059b7ca9273d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d173423d001b4e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d7e5d016bfa4b80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-cb502bcc195b4fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>删除分支包括删除本地分支和远程分支：</p>
<ul>
<li>删除本地分支<ul>
<li>如本地分支不是打开状态，则：<code>git branch -d branchName</code></li>
<li>如本地分支是打开状态，则：<code>git branch -D branchName</code></li>
</ul>
</li>
<li>删除远程分支<ul>
<li><code>git push origin --delete branchName</code></li>
</ul>
</li>
</ul>
<h2 id="恢复分支"><a href="#恢复分支" class="headerlink" title="恢复分支"></a>恢复分支</h2><p>恢复分支，我们只需要以之前分支的 <em>commitID</em> 新开一个分支即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-a2e8638e3cc8a3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果不记得 <em>commitID</em>，可以通过 <em>git reflog</em> 进行查看。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-ba394e5b699ff0f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1570871432663.png"></p>
<h2 id="撤销本地修改"><a href="#撤销本地修改" class="headerlink" title="撤销本地修改"></a>撤销本地修改</h2><ul>
<li><p>撤销指定本地文件的修改（未提交状态）：<code>git checkout -- fileName</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-75f7a0a74ac422d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>撤销本地的所有修改（未提交状态）：<code>git reset --hard</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-0359a8aee6d9ae94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<h2 id="其他基本操作"><a href="#其他基本操作" class="headerlink" title="其他基本操作"></a>其他基本操作</h2><ul>
<li>生成本地的 <em>key</em>，并添加到远程仓库</li>
</ul>
<pre><code>ssh-keygen -t rsa
</code></pre><ul>
<li>初始化本地目录</li>
</ul>
<pre><code>git init
</code></pre><ul>
<li>添加到本地仓库</li>
</ul>
<pre><code>git add filename
</code></pre><ul>
<li>提交到仓库（<em>git</em> 提交的是修改）</li>
</ul>
<pre><code>git commit -m &quot;description&quot;
</code></pre><ul>
<li>查看仓库状态</li>
</ul>
<pre><code>git status
</code></pre><ul>
<li>查看不同点</li>
</ul>
<pre><code>git diff filename
</code></pre><ul>
<li>版本回退</li>
</ul>
<pre><code>git reset --hard
</code></pre><ul>
<li>第一分支 <em>master</em> 创建分支 <em>v1</em> （<em>HEAD</em> 指向当前分支）</li>
</ul>
<pre><code>// 创建并指向新分支
git checkout -b v1 
// 分步执行
git branch v1
git checkouut v1
</code></pre><ul>
<li>合并到当前分支</li>
</ul>
<pre><code>git merge v1
</code></pre><ul>
<li>删除指定分支</li>
</ul>
<pre><code>git branch -d v1
</code></pre><ul>
<li>指定分支将远程仓库的代码拉到本地</li>
</ul>
<pre><code>git clone gitAddress -b branchName
</code></pre><ul>
<li>将本地的代码提交到远程仓库</li>
</ul>
<pre><code>git pull    //获取最新的更改
git add modefied_filename
git commit -m &quot;description&quot;
git push  // 推送
</code></pre><ul>
<li>冲突解决<br>可以用上面的方法解决就解决，不行的话就用下面的方法：<ul>
<li>用远程仓库的代码完全覆盖本地代码。</li>
</ul>
</li>
</ul>
<pre><code>git reset --hard // 版本回退
git pull

</code></pre><ul>
<li>修改 commit 提交的内容</li>
</ul>
<pre><code>git commit --amend

</code></pre><ul>
<li>打印 log 数量</li>
</ul>
<pre><code>git log -p -3

</code></pre><ul>
<li>文件被添加到暂存区，撤销该文件到工作目录</li>
</ul>
<pre><code>git reset HEAD fliename

</code></pre><ul>
<li>工作目的删除文件后，还有在暂存区中删除该文件</li>
</ul>
<pre><code>rm filename
git rm filename

</code></pre><ul>
<li>撤销对当前文件的修改，恢复到上一次快照的状态</li>
</ul>
<pre><code>git checkout -- filename

</code></pre><ul>
<li><em>HEAD</em> 指针指向当前的分支，提交后都会快进（<em>fast-forward</em> ：指针右移）。</li>
<li><em>rebase</em> 合并分支<br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</li>
</ul>
<pre><code>git checkout dev
......修改......
git add filename
git commit -m &quot;......&quot;
git rebase master
git checkout master
git merge dev

</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 操作</title>
    <url>/2019/10/12/Git-%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>想必每个开发者对Git并不陌生，先来看看官方对于Git的定义：</p>
<blockquote>
<p>Git是一个免费和开源的分布式版本控制系统，旨在快速和有效率地处理从大到小的项目。</p>
</blockquote>
<h4 id="安装-Git-和查看-Git-版本"><a href="#安装-Git-和查看-Git-版本" class="headerlink" title="安装 Git 和查看 Git 版本"></a>安装 Git 和查看 Git 版本</h4><ul>
<li>安装（仅说明在 <em>Linux</em> 系统下的安装，若您是windows系统，直接官网下载安装就行~）</li>
</ul>
<pre><code>sudo apt install git
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-1b4d4c825d3e9cf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>由于我之前已经安装过了，所以这里升级等都是 <em>0</em>。</p>
<ul>
<li>查看是否安装成功</li>
</ul>
<pre><code>git
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-b029bb624636ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>输入git命令后，出现一系列关于Git的参数和命令等，说明安装成功了。</p>
<ul>
<li>查看 <em>Git</em> 版本</li>
</ul>
<pre><code>git --version
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-d93c79710b9cfdfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<h4 id="创建-Git-仓库"><a href="#创建-Git-仓库" class="headerlink" title="创建 Git 仓库"></a>创建 Git 仓库</h4><p>所谓 <em>Git</em> 仓库（<em>repository</em>），也叫版本库。简单理解，就是可以被 <em>Git</em> 管理（修改，删除等）的目录。</p>
<ul>
<li>新建本地目录，并切换到新目录</li>
</ul>
<pre><code>mkdir gitFile
cd gitFile
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-86edbf8888ce2c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>将本地目录初始化为 <em>Git</em> 仓库</li>
</ul>
<pre><code>git init
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-c56d293f662bf4ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>查看 <em>Git</em> 仓库的目录</li>
</ul>
<pre><code>ls -al
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-9af646e821d36e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br>您会发现，这里多了一个 <em>.git</em> 的目录，作用是 <em>Git</em> 来跟踪管理 <em>Git</em> 仓库的；注意，如果输入的命令是 <em>ls</em> 是不会看到 <em>.git</em>，因为这个目录默认是隐藏的。</p>
<h4 id="将文件放到Git仓库（一定要在-git-init-的目录／子目录下）"><a href="#将文件放到Git仓库（一定要在-git-init-的目录／子目录下）" class="headerlink" title="将文件放到Git仓库（一定要在 git init 的目录／子目录下）"></a>将文件放到Git仓库（一定要在 <em>git init</em> 的目录／子目录下）</h4><ul>
<li>新建 <em>test.txt</em> 文件并输入内容</li>
</ul>
<pre><code>cat &gt; test.txt
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-838f0f3715084789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>将 <em>test.txt</em> 文件上传到Git仓库</li>
</ul>
<pre><code>git add test.txt 
</code></pre><ul>
<li>告知 <em>Git</em> 仓库提交了新文件，并添加标注信息</li>
</ul>
<pre><code>git commit -m &quot;My first git.&quot;

</code></pre><p><em>-m</em> 后面是 <em>commit</em> 信息。<br>很简单吧～只需要两步，就可以将文件上传到Git仓库。</p>
<ul>
<li>查看 <em>Git</em> 仓库的当前状态</li>
</ul>
<pre><code>git status

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-6e47af6a618c047d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br>倘若修改了文件，但没有提交，结果是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/659084-0910cc6291dbadfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>提交后的结果是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/659084-07671c9d269aa1b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>查看文件修改内容<br>如果修改了文件，但还没提交，可以对比文件前后的修改内容。</li>
</ul>
<pre><code>git diff test.txt

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-3373c8bc3a0b6df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>可知，文件 <em>test.txt</em> 添加了新的一行 <em>This is the third line.</em></p>
<h4 id="创建GitHub账号"><a href="#创建GitHub账号" class="headerlink" title="创建GitHub账号"></a>创建GitHub账号</h4><p>如果没有 <em>GitHub</em> 账号，得先到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>官网注册账号。注册登录为常规操作，不多说。</p>
<h4 id="SSH设置"><a href="#SSH设置" class="headerlink" title="SSH设置"></a>SSH设置</h4><p>由于Git和GitHub之间是通过SSH加密传输的，所以需要进行SSH设置。</p>
<ul>
<li>创建SSH Key（用户主目录）</li>
</ul>
<pre><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;

</code></pre><p>接下来回车默认就好了。</p>
<ul>
<li>在用户主目录下找到 <em>.ssh</em> 目录</li>
</ul>
<pre><code>ls -al | find -name &quot;*.ssh&quot;

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-0d28f60589a3fe46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>发现存在 <em>.ssh</em> 目录，切换到 <em>.ssh</em> 目录，发现文件中秘钥有 <em>id_rsa</em>（私钥）和 <em>id_rsa.pub</em>（公钥），其中是 <em>id_rsa.pub</em> 是我们所需要的<br><img src="http://upload-images.jianshu.io/upload_images/659084-b56f8d1860d46e2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>打开 <em>ip_rsa.pub</em> ，并复制</li>
</ul>
<pre><code>cat ip_rsa.pub

</code></pre><h4 id="在-GitHub-中添加-SSH-Key"><a href="#在-GitHub-中添加-SSH-Key" class="headerlink" title="在 GitHub 中添加 SSH Key"></a>在 <em>GitHub</em> 中添加 <em>SSH Key</em></h4><ul>
<li>Settings-&gt;SSH and GRG keys-&gt;new SSH key<br><img src="http://upload-images.jianshu.io/upload_images/659084-5c62e09650873795.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-25987355f4a0e8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-313107faef8abb08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-382e08b98c30ba58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>创建成功后，跳转页面中你会看到你新建的ssh key<br><img src="http://upload-images.jianshu.io/upload_images/659084-48ad323d9452d92a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
</ul>
<h4 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 <em>GitHub</em> 仓库</h4><ul>
<li>登录GitHub账号后，创建新的仓库，仓库名称看自己需要命名，其他默认就好了。我这里为了测试，就取为<strong>test</strong><br><img src="http://upload-images.jianshu.io/upload_images/659084-1ae7942e887d2f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-db087fe0ca9607ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>GitHub仓库创建成功后，会有SSH和HTTPS地址<br><img src="http://upload-images.jianshu.io/upload_images/659084-1efaa0a539fbbd68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
</ul>
<h4 id="Git-连接-GitHub，并推送本地文件到远程仓库"><a href="#Git-连接-GitHub，并推送本地文件到远程仓库" class="headerlink" title="Git 连接 GitHub，并推送本地文件到远程仓库"></a><em>Git</em> 连接 <em>GitHub</em>，并推送本地文件到远程仓库</h4><ul>
<li>在本地仓库的目录 <em>gitFile</em> 下运行命令</li>
</ul>
<pre><code>git remote add origin 仓库的SSH地址

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-955edfecc27bf5ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br>注意，这里的 <em>origin</em> 是远程仓库的名字（<em>Git</em>的默认叫法）</p>
<ul>
<li>将本地仓库 <em>Git</em> 的文件推送到远程仓库 <em>GitHub</em></li>
</ul>
<pre><code>git push -u origin master

</code></pre><p>不出意外，在GitHub的 <em>test</em> 仓库中会看到我们传送的文件<br><img src="http://upload-images.jianshu.io/upload_images/659084-3ceb742e8262ac94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<h4 id="从-GitHub-中克隆文件到本地"><a href="#从-GitHub-中克隆文件到本地" class="headerlink" title="从 GitHub 中克隆文件到本地"></a>从 <em>GitHub</em> 中克隆文件到本地</h4><ul>
<li>在 <em>GitHub</em> 中创建文件，并且复制<em>SSH</em> 地址<br><img src="http://upload-images.jianshu.io/upload_images/659084-8555c272dc15e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-29aec05f56492874.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-1e5de00c4bbe4477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>输入以下克隆命令</li>
</ul>
<pre><code>git clone SSH地址

</code></pre><p>你会发现，<em>GitHub</em> 中的目录包括你刚才新建的文件都存在本地目录中了。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2019/02/18/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul>
<li>对于一些高频触发操作的场景，我们需要加防抖操作。比如：监听页面滚动、输入实时显示搜索结果等。这些都需要加防抖操作，不然对页面性能有很大的副作用。</li>
<li>简单概括：防抖就是将高频操作优化为最后一次执行。</li>
</ul>
<p>实现：</p>
<pre><code>function debounce(fn, wait, immediate = false) {
  var timeout, result;

  timeout &amp;&amp; clearTimeout(timeout);
  var debounced = function () {
    var context = this;
    var args = arguments;

    if (immediate) { // 事件停止触发后 n 秒，触发事件立刻执行回调
      var callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait)
      if (callNow) {
        result = fn.apply(context, args);
      }
    } else { // 事件停止触发后，执行回调函数
      timeout = setTimeout(function () {
        fn.apply(context, args);
      }, wait);
    }
  }

  debounced.cancel = function () {
    clearTimeout(timeout);
    timeout = null;
  }

  return debounced;
}
</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>每段时间后执行一次，将高频转化为低频。</p>
<ul>
<li>时间戳</li>
</ul>
<pre><code>function throttle(fn, wait) {
    var previous = 0;

    return function () {
        var args = arguments;
        var context = this;
        var now = +new Date();
        if (now - previous &gt; wait) {
            fn.apply(context, args);
            previous = now;
        }
    }
}
</code></pre><ul>
<li>定时器</li>
</ul>
<pre><code>function throttle(fn, wait) {
    var timeout;

    return function() {
        var args = arguments;
        var context = this;
        if (!timeout) {
            timeout = setTimeout(function() {
                timeout = null;
                fn.apply(context, args);
            }, wait)
        }
    }
}
</code></pre>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3.0项目创建+配置+自动部署</title>
    <url>/2019/02/17/vue-cli3-0%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA-%E9%85%8D%E7%BD%AE-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul>
<li><p>安装 <strong>vue3.0</strong> 脚手架</p>
<pre><code>npm install -g @vue/cli
</code></pre></li>
<li><p>创建项目</p>
<pre><code>vue create my_project
</code></pre><p>一系列选择之后，可以保存你当前的选择配置，之后创建项目的时候就可以直接用了。</p>
</li>
<li><p>安装依赖</p>
<pre><code>cd my_project
</code></pre></li>
</ul>
<p>最后的项目目录结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-5267ed577dcb2fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p><strong>vue3.0</strong> 运行项目主要有两种方式：</p>
<ul>
<li><p>命令行方式：</p>
<pre><code>npm run serve
</code></pre></li>
<li><p>UI视图方式，这也是3.0版本的一大亮点。通过UI视图方式，可以帮助我们很多事，如：运行项目、安装依赖、安装插件等。</p>
<pre><code>vue ui
</code></pre></li>
</ul>
<h2 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h2><p>vue 已经帮我们配置了很多，额外自己又添加了一些配置；在根目录添加 <strong>vue.config.js</strong> 配置文件：</p>
<pre><code>const path = require(&#39;path&#39;);
const px2rem = require(&#39;postcss-px2rem&#39;);
const VconsoleWebpackPlugin = require(&#39;vconsole-webpack-plugin&#39;);
const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;);
// 判断是否为生产环境
const isProduction = process.env.NNODE_ENV === &#39;production&#39;;
// 路径处理函数
const resolve = name =&gt; path.resolve(__dirname, name);

module.exports = {
  publicPath: isProduction ? &#39;/production&#39; : &#39;/&#39;, // 部署应用包时的基本 URL
  productionSourceMap: !isProduction, // 生产环境不开启 source-map
  devServer: { // webpack-dev-server 的配置
    port: 8089, // 本地端口
    open: true, // 自动打开浏览器
    // proxy: { // 代理
    //   &#39;/api&#39;: {
    //     target: &#39;&lt;url&gt;&#39;,
    //     ws: true,
    //     changeOrigin: true
    //   },
    // }
  },
  css: {
    extract: isProduction, // 生产环境将 css 单独抽离成一个文件
    sourceMap: !isProduction, // 生成环境不开启 source-map
    loaderOptions: {
      postcss: {
        // 移动端使用rem
        plugins: [
          px2rem({
            remUnit: 75
          })
        ]
      },
      // 全局共享variables.scss
      sass: {
        // @/ 是 src/ 的别名
        // 所以这里假设你有 `src/variables.scss` 这个文件
        data: `@import &quot;@/variables.scss&quot;;`
      }
    }
  },
  configureWebpack: config =&gt; {
    const devPlugins = [
      new VconsoleWebpackPlugin({ // 微信移动端调试控制台
        enable: !isProduction
      })
    ];
    const prodPlugins = [
      new TerserWebpackPlugin({
        terserOptions: { // 打包时候的配置
          warnings: false,
          compress: true,
          drop_console: true,
          drop_debugger: true,
          pure_funcs: [&#39;console.log&#39;]
        }
      })
    ];
    if (isProduction) { // 生产环境
      config.optimization.minimizer = [
        ...config.optimization.minimizer,
        ...prodPlugins
      ]
    } else { // 开发环境
      config.plugins = [...config.plugins, ...devPlugins]
    }
  },
  chainWebpack: config =&gt; {
    // 自定义全局变量
    // config
    //   .plugin(&#39;define&#39;)
    //   .tap((args) =&gt; {
    //     args[0].PRODUCTION = isProduction ? JSON.stringify(&#39;&#39;) :
    //       JSON.stringify(
    //         &#39;other/&#39;,
    //       );
    //     return args;
    //   });
    // 别名设置
    config.resolve.alias
      .set(&#39;js&#39;, resolve(&#39;src/assets/js&#39;))
      .set(&#39;scss&#39;, resolve(&#39;src/assets/scss&#39;))
      .set(&#39;images&#39;, resolve(&#39;src/assets/images&#39;))
      .set(&#39;components&#39;, resolve(&#39;src/components&#39;));
  }
}
</code></pre><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p><strong>vue3.0</strong> 的路由配置已经很完善了，这里我仅仅小改动，封装了路由懒加载函数：</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import Home from &#39;./views/Home.vue&#39;

Vue.use(Router)
// 路由懒加载
// route level code-splitting
// this generates a separate chunk (about.[hash].js) for this route
// which is lazy-loaded when the route is visited.
const addRouterComponent = path =&gt; import(path);

export default new Router({
  mode: &#39;history&#39;,
  base: process.env.BASE_URL,
  routes: [{
      path: &#39;/&#39;,
      name: &#39;home&#39;,
      component: Home
    },
    {
      path: &#39;/about&#39;,
      name: &#39;about&#39;,
      component: addRouterComponent(&#39;./views/About.vue&#39;)
    }
  ]
})
</code></pre><h2 id="axios-的配置"><a href="#axios-的配置" class="headerlink" title="axios 的配置"></a>axios 的配置</h2><p>在 <strong>scr</strong> 目录下添加 <strong>api</strong> 目录，并新建两个文件：<strong>config.js</strong> 和 <strong>api.js</strong>。配置如下：</p>
<ul>
<li><strong>config.js</strong></li>
</ul>
<pre><code>import axios from &#39;axios&#39;;
import qs from &#39;qs&#39;;

axios.defaults.withCredentials = false;
// 请求拦截器
axios.interceptors.request.use(
  request =&gt; {
    request.data = request.data || {};
    const hasHttp = /^http(|s):\/\//.test(request.url);
    if (!hasHttp) { // 无 http or https 头处理
      request.url = `https://${request.url}`;
    }
    if (request.data) {
      request.data = {
        // commom: &#39;&#39;, 这里可以添加一些公共的请求参数
        data: JSON.stringify(request.data)
      };
      request.data = qs.stringify(request.data);
    }
    return request;
  },
  error =&gt; Promise.reject(error)
);
// 响应拦截器
axios.interceptors.response.use(
  response =&gt; {
    const responseData = response.data;
    if (responseData.errcode !== 0) { // 错误处理
      return Promise.reject(responseData.msg || &#39;未知错误&#39;);
    }
    responseData.result = responseData.result || {};
    return responseData;
  },
  error =&gt; Promise.reject(error)
);

export {
  axios
};
</code></pre><ul>
<li><strong>api.js</strong></li>
</ul>
<pre><code>import {
  axios
} from &#39;./config.js&#39;;

// 例子 1
export const aApi1Name = params =&gt; axios.post(url, params);
// 例子 2
export const aApi2Name = params =&gt; axios.get(url, params);
</code></pre><h2 id="打包后自动部署到服务器"><a href="#打包后自动部署到服务器" class="headerlink" title="打包后自动部署到服务器"></a>打包后自动部署到服务器</h2><p>使用的是 <strong>scp2</strong>；通过向脚本传递不同参数，部署到不同的服务器路径；在根目录添加 <strong>deploy.js</strong> 脚本。相关配置如下：</p>
<ul>
<li><strong>package.json</strong></li>
</ul>
<pre><code>&quot;buildTest&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js development&quot;,
&quot;buildProd&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js production&quot;
</code></pre><ul>
<li><strong>deploy.js</strong></li>
</ul>
<pre><code>const qs = require(&#39;qs&#39;);

// 判断是否输出帮助信息
const helpMessage = `usage: node deploy.js [deploy_target]`;
if (
  process.argv.length !== 3 ||
  process.argv[2] === &#39;-h&#39; ||
  process.argv[2] === &#39;--help&#39;
) {
  console.log(helpMessage);
  process.exit(0);
}

// 判断是否是生产环境
const isProduction = process.argv[2] === &#39;production&#39;;

// 设置部署的文件路径，正服 or 测服
let deployPath = &#39;&#39;;
if (isProduction) {
  deployPath = &#39;/production&#39;
} else {
  deployPath = &#39;/test&#39;
}

// 设置服务器服务器信息
const SERVER_INFO = {
  host: &#39;134.175.150.8&#39;,
  port: 22,
  username: &#39;&#39;,
  password: &#39;&#39;,
  path: deployPath
}

// 部署到服务器
client.scp(&#39;./dist/&#39;, SERVER_INFO, err =&gt; {
  if (err) {
    console.log(&#39;Deploy Failed!\n&#39;, err);
  }
})

console.log(`Deploy ${isProduction ? &#39;production&#39; : &#39;developemt&#39;} finished!`);
</code></pre><p>总结：通过上面的配置，基本可以实现 <strong>vue</strong> 项目从创建到配置到打包自动部署的过程。</p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2019/02/17/websocket/</url>
    <content><![CDATA[<h2 id="HTTP-HTTPS-协议"><a href="#HTTP-HTTPS-协议" class="headerlink" title="HTTP/HTTPS 协议"></a>HTTP/HTTPS 协议</h2><ul>
<li>一个 <strong>request</strong> 对应一个 <strong>response</strong>。一般使用 <strong>轮询</strong> 机制获取信息。</li>
<li>虽然后期有 <strong>keep-alive</strong>，可以一次连接中处理多个 <strong>request</strong> 合并发送，接收多个 <strong>response</strong>，对每个请求仍然需要单独发 <strong>header</strong>。</li>
<li><strong>HTTP</strong> 的 <strong>response</strong> 是被动的，通信只能由客户端发起，做不到服务端主动向客户端推送信息。</li>
<li><strong>HTTP</strong> 是无状态协议。</li>
<li>需要三次握手。</li>
<li>HTTP：TCP + HTTP</li>
<li>HTTPS：TCP + HTTP + TLS</li>
</ul>
<h4 id="ajax-轮询"><a href="#ajax-轮询" class="headerlink" title="ajax 轮询"></a>ajax 轮询</h4><p><strong>ajax 轮询</strong> 是指客户端 <strong>不断</strong> 向服务器发送资源请求 <strong>request</strong>，服务端不管有无目标资源，都会返回 <strong>response</strong> 结果。这样就要求服务器拥有更好的处理速度。</p>
<h4 id="long-poll-长轮询"><a href="#long-poll-长轮询" class="headerlink" title="long poll / 长轮询"></a>long poll / 长轮询</h4><p><strong>long poll</strong> 比 <strong>ajax 轮询</strong> 好点，<strong>不会不断</strong> 向服务器发送资源请求 <strong>request</strong>，一旦接受客户端的请求，有资源就返回；无资源就挂起，直到有资源才返回 <strong>response</strong> 结果（有且仅有返回一次）。高并发，需要服务器可以同时处理多个请求的能力。</p>
<h2 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h2><ul>
<li><strong>websocket</strong> 是 <strong>html5</strong> 出的协议。</li>
<li><strong>websocket</strong> 是一个持久化的协议，<strong>websocket</strong> 只需要一次请求（一次 <strong>HTTP 握手</strong> ），就可以得到所需的资源。</li>
<li>服务端可以 <strong>主动</strong> 向客户端推送信息，客户端也可以 <strong>主动</strong> 向服务端推送消息，实现“双向平等”，是属于服务器推送技术的一种。</li>
<li>与 <strong>HTTP</strong> 有较好的兼容性，在握手阶段采用 <strong>HTTP</strong> 协议。</li>
<li>默认端口 <strong>80</strong> and <strong>443</strong>。</li>
<li>数据格式轻量，性能开销小，通信高效，可以发送文本，也可以二进制数据。</li>
<li>没有同源策略。</li>
<li>WS：TCP + WS</li>
<li>WSS：TCP + WS + TLS</li>
</ul>
<h4 id="websocket-握手"><a href="#websocket-握手" class="headerlink" title="websocket 握手"></a>websocket 握手</h4><pre><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</code></pre><ul>
<li>Upgrade/Connection：通知服务器发起的是 <strong>wesocket</strong> 协议。</li>
<li>Sec-WebSocket-Key：浏览器随机生成的 <strong>Base64 encode</strong> 的值，用于验证服务器是不是 <strong>websocket 协议</strong>。</li>
<li>Sec-WebSocket-Protocol：用户定义的字符串，用来区分 <strong>同 url</strong> 下，不同的服务所需要的协议。</li>
<li>Sec-WebSocket-Version：协议版本。</li>
</ul>
<h4 id="服务器返回"><a href="#服务器返回" class="headerlink" title="服务器返回"></a>服务器返回</h4><pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre><ul>
<li>Upgrade/Connection：通知客户端升级的是 <strong>websocket</strong> 协议。</li>
<li>Sec-WebSocket-Accept：经服务器确认，加密后的 <strong>Sec-WebSocket-Key</strong>。</li>
<li>Sec-WebSocket-Protocol：最终使用的协议。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>ws.addEventListener(&#39;open&#39;, function () {
    console.log(&#39;Open the websocket...&#39;);
    ws.send(&#39;Hello websocket...&#39;);
});
ws.addEventListener(&#39;message&#39;, function (e) {
    console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Receive the websocket message...&#39; + e.data);
    ws.close();
    setTimeout(() =&gt; {
        console.log(&#39;Ready state: &#39; + ws.readyState);
    }, 1000)
});
ws.addEventListener(&#39;close&#39;, function () {
    console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Close the websocket...&#39;);
})
</code></pre><p>结果：<br><img src="http://upload-images.jianshu.io/upload_images/659084-021a1bb1915811bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>参考：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d06ed1bfe9c9fadb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><a href="https://www.zhihu.com/search?type=content&amp;q=websocket" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=websocket</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title>用户认证小总结</title>
    <url>/2019/02/17/%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h2><p>一般的用户认证流程如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-bdfa6d0008a02e53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<p>但是，这种模式的扩展性不好。单个服务器没问题，如果多个服务器集群，要求共享 <strong>session</strong> ，每个服务器都能访问到 <strong>session</strong> 。</p>
<ul>
<li>解决方案一：<strong>session</strong> 数据持久化，写入数据库或者其他持久层。各个服务器收到请求后，向持久层发送数据请求。<ul>
<li>缺点：工程量大。</li>
</ul>
</li>
<li>解决方案二：服务器不保存 <strong>session</strong> 数据，所有的数据保存在客户端，每次请求都发回服务器。如：JWT(Json Web Token)。</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><strong>JWT</strong> 服务器不保存 <strong>session</strong> 数据，在服务器认证之后，返回一个 <strong>JSON</strong> 对象。格式如下：</p>
<pre><code>{
    &quot;姓名&quot;: &quot;zero&quot;,
    &quot;角色&quot;: &quot;管理员&quot;,
    &quot;到期时间&quot;: &quot;2018年10月6日0点0分&quot;
}
</code></pre><p>之后，客户端与服务器的用户认证都靠这个 <strong>JSON</strong> 对象，当然，这个对象后面会加上签名，保证数据不被篡改。</p>
<h4 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h4><ul>
<li><strong>JWT</strong> 是一个很长的字符串，中间用 <strong>.</strong> 分隔，内部没有换行。</li>
<li>组成由三个部分：<strong>Header.Payload.Signature</strong><ul>
<li>Header：头部。<strong>JSON</strong> 对象，描述 <strong>JWT</strong> 的元数据。</li>
<li>Payload：负载。<strong>JSON</strong> 对象，存放实际需要传递的数据；不加密。</li>
<li>Signature：签名。对 <strong>Header</strong> 和 <strong>Payload</strong> 的签名，防止数据被篡改。</li>
</ul>
</li>
</ul>
<p>Header 格式：</p>
<pre><code>{
  &quot;alg&quot;: &quot;HS256&quot;,   // 签名的算法
  &quot;typ&quot;: &quot;JWT&quot;      // token 类型
}
</code></pre><p>Payload 七个字段：</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<h4 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h4><ul>
<li>存储在 <strong>cookie</strong> 中。</li>
<li>存储在 <strong>localStorage</strong> 中。</li>
<li>客户端每次与服务器进行通信的时候，都会带上 <strong>JWT</strong>。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title>web safe</title>
    <url>/2019/02/17/web-safe/</url>
    <content><![CDATA[<h2 id="CSRF-Cross-Site-Request-Forgery"><a href="#CSRF-Cross-Site-Request-Forgery" class="headerlink" title="CSRF : Cross Site Request Forgery"></a>CSRF : Cross Site Request Forgery</h2><p><strong>CSRF</strong> 跨站请求伪造。<br>是一种劫持受信任用户向服务器发送非预期请求的攻击方式。简而言之：用户在登录的情况下访问了钓鱼网站，钓鱼网站通过用户向其他网站发送请求，这样就达到了模拟用户的目的。具体实现如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-9ce93c3bff5d427b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h4><ul>
<li>验证码实现用户验证。验证码强制用户必须与应用进行交互，才能完成最终的请求。</li>
<li>通过 referer 实现用户验证。根据 <strong>HTTP</strong> 协议，在 <strong>HTTP</strong> 头中有一个字段叫 <strong>Referer</strong>，它记录了该 <strong>HTTP</strong> 请求的 <strong>来源地址</strong>。通过 <strong>Referer Check</strong>，可以检查请求是否来自合法的”源”。</li>
<li>通过 token 实现用户验证。</li>
<li>尽量不要在页面的链接中暴露用户隐私信息。</li>
<li>对于用户修改删除等操作最好都使用 post 操作。</li>
<li>避免全站通用的 cookie，严格设置 cookie 的域。</li>
</ul>
<h2 id="XSS-Cross-Site-Script"><a href="#XSS-Cross-Site-Script" class="headerlink" title="XSS : Cross Site Script"></a>XSS : Cross Site Script</h2><p><strong>XSS</strong> 跨站脚本攻击。<br>攻击者向用户的网站嵌入的 js 脚本代码，当用户访问该网站的时候，该 js 脚本代码就会被执行，从而达到攻击用户的目的。</p>
<h4 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h4><p>又称非持久性跨站脚本攻击。发出请求时，XSS 代码出现在 <strong>URL</strong> 中，作为输入提交到服务器端，服务器端解析后响应，XSS 随响应内容一起返回给浏览器，最后浏览器解析执行 XSS 代码。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。<br>比如：</p>
<pre><code>http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！
</code></pre><h4 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h4><p>XSS 提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交 XSS 代码。这种攻击方式的稳定性很好。<br>比如：</p>
<blockquote>
<p>攻击者在 value 填写<code>&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;</code>【或者 html 其他标签（破坏样式。。。）、一段攻击型代码】；将数据存储到数据库中；其他用户取出数据显示的时候，将会执行这些攻击性代码。</p>
</blockquote>
<h4 id="具体方式"><a href="#具体方式" class="headerlink" title="具体方式"></a>具体方式</h4><ul>
<li>攻击者向服务器注入 js 代码。</li>
<li>诱导用户访问受到攻击的网站。</li>
<li>用户访问受到攻击的网站，执行注入的 js 代码。</li>
</ul>
<h4 id="XSS-防御方式"><a href="#XSS-防御方式" class="headerlink" title="XSS 防御方式"></a>XSS 防御方式</h4><ul>
<li>HttpOnly</li>
<li>输入检查</li>
<li>输出检查</li>
</ul>
<p>参考链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/shytong/p/5308667.html" target="_blank" rel="noopener">https://www.cnblogs.com/shytong/p/5308667.html</a></li>
<li><a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">https://github.com/dwqs/blog/issues/68</a></li>
<li><a href="https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label3" target="_blank" rel="noopener">https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label3</a></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>web-safe</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>web-safe</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax和跨域总结</title>
    <url>/2019/02/17/Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Ajax（JavaScript实现）"><a href="#Ajax（JavaScript实现）" class="headerlink" title="Ajax（JavaScript实现）"></a>Ajax（JavaScript实现）</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Ajax（Async Javascript And Xml）：异步Js和Xml，意思就是用Js执行异步网络请求。作用主要是在不重新加载<strong>全部网页</strong>的情况下，对<strong>部分页面</strong>进行更新。</p>
<h4 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h4><p>除了IE5和IE6不支持之外（支持ActiveXObject对象），几乎现在所有的有内建的XMLHttpRequest对象。所以在创建请求对象之前判断下就好了：</p>
<pre><code>let xhr = null;
xhr = window.XMLHttpRequest ? new xmlHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
// 或者
if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest()
}else{
    xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)
}
</code></pre><h4 id="通过open-和send-向服务器发送请求"><a href="#通过open-和send-向服务器发送请求" class="headerlink" title="通过open()和send()向服务器发送请求"></a>通过open()和send()向服务器发送请求</h4><ul>
<li>xhr.open(method, url, async)<br>这个方法的参数分别是：method请求的类型GET或者POST；URL请求的文件在服务器上的地址；async是否异步请求true或者false（一般不设置为false）。</li>
<li>xhr.send()：发送请求。</li>
<li>xhr.setRequestHeader(header, value)：如果是POST的话，要设置发送的HTTP头，然后通过send方法发送内容。参数分别是：发送的头部名称，头部的值。一般都是固定的。</li>
</ul>
<pre><code>// 向浏览器发送请求
xhr.open(&#39;GET&#39;, &#39;./server.php&#39;, true)
// 添加HTTP头（POST方法）
xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;)   
xhr.send()
</code></pre><p>GET方法不需要参数，POST方法则需要把body参数；如果要想向服务器发送相关的参数，则通过open里面的第二个参数url进行发送，具体实现如下代码：</p>
<pre><code>url = &quot;./filePath?paramName=&quot; + paramValue + ...;
</code></pre><h4 id="判断准备状态"><a href="#判断准备状态" class="headerlink" title="判断准备状态"></a>判断准备状态</h4><pre><code>xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        ...
    }
}
</code></pre><ul>
<li>xhr.onreadystatechange方法中，每当readyState改变时，就会触发xhr.onreadystatechange事件。</li>
<li>readyState属性：存有XMLHttpRequest的状态信息。0：请求未初始化；1：服务器链接已经建立；2：请求已经接受；3：请求处理中；4：请求已完成，且响应已就绪。一共有5个状态，所以onreadystatechange事件会被触发5次。</li>
<li>实际上onreadystateschange是通过回调函数实现的，即：每当readyState的状态改变时，这个回调函数就会被执行。</li>
<li>status属性：表示响应的结果。</li>
</ul>
<p>总的代码如下：</p>
<pre><code>document.getElementById(&#39;btn&#39;).onclick = function () {
// 创建请求对象（先判断浏览器类型）
// var xhr = null;
// if (window.XMLHttpRequest) {
//     xhr = new XMLHttpRequest()
// } else {
//     xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)
// }
xhr = (window.XMLHttpRequest) ? (new XMLHttpRequest()) : (new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;))
// 判断响应状态并执行相关的操作
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        let data = xhr.responseText
        console.log(data);
        document.getElementById(&#39;myDiv&#39;).innerText = data
    }
}
// 向浏览器发送请求
let url = &quot;./server.txt&quot;
xhr.open(&#39;GET&#39;, url, true)
// 添加HTTP头（POST方法）
// xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;)
xhr.send(null);
}
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-b5b344a3944ba224.gif?imageMogr2/auto-orient/strip" alt="异步1.gif"></p>
<p>但是，由于在<strong>同源策略</strong>的作用下，浏览器只能同源的其他域的资源，先看看什么是同源策略～</p>
<h2 id="同源策略-SOP（Same-origin-policy）"><a href="#同源策略-SOP（Same-origin-policy）" class="headerlink" title="同源策略/SOP（Same origin policy）"></a>同源策略/SOP（Same origin policy）</h2><p>来自百度的解释：</p>
<blockquote>
<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能（防止CSRF/XSRF攻击：跨站请求伪造）。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。</p>
</blockquote>
<p>简单来说，就是浏览器只能请求同源的其他域的资源，即同源的网页才能相互获取资源，而不能访问其他域的资源；但是有一个例外，同源策略不会阻止动态脚本插入到文档中；其中，<strong><script>\</script></strong>是开放策略；当web网页执行一个脚本之前，会检查是否同源，只有同源才会被执行，非同源则会被拒绝访问。<br>截取网上的图片说明同源：<br><img src="http://upload-images.jianshu.io/upload_images/659084-80411ea5e317ed19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域就是突破同源策略的限制，获取其他源的资源。<br>非同源主要有三种行为会受到限制：</p>
<ul>
<li>Cookie,LocalStorage和IndexDB无法读取。</li>
<li>DOM无法获取。</li>
<li>Ajax无法获取。</li>
</ul>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP是实现跨域的常用方法，但是JSONP只能实现GET方法。实际上是是利用了浏览器允许跨域引用JavaScript资源（script标签是开放策略）。</p>
<p>下面举一个例子：我们从360浏览器首页的天气查询获取天气查询的异步请求地址；这里我们实现通过本地localhost服务器跨域请求360的天气查询，来说明JSONP怎么实现跨域。<br>我们请求资源的地址为：<br><a href="https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600" target="_blank" rel="noopener">https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600</a><br>在浏览器中打开这个地址，我们会得到这样的数据：__jsonp21__({…})。<br>解释：JSONP返回的通常是以函数的形式返回，前面这个__jsonp21__是函数名，所以我们需要在我们的代码中事先准备好名称为__jsonp21__的函数，我们对跨域请求到的数据就是放在这个函数中的，然后动态加载一个<strong>script</strong>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。</p>
<p>具体代码如下：</p>
<pre><code> // 请求的地址为：https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600

function __jsonp21__(data) {   // 将要处理了的数据放在这个函数中
    console.log(data);  // 得到的是跨域请求的数据
    let myDiv = document.getElementById(&#39;myDiv&#39;)  
    myDiv.innerHTML = data.area
}
window.onload = function () { 
    let btn = document.getElementById(&#39;btn&#39;)
    btn.addEventListener(&#39;click&#39;, function () {  
        let url = &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39;
        let scriptTag = document.createElement(&#39;script&#39;)    // 动态创建script标签 
        scriptTag.setAttribute(&#39;src&#39;, url)      // 将其他源的地址设置为动态script的src属性
        // console.log(scriptTag);  // 得到的是script标签
        document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag)  // 将动态创建的script标签添加到html页面中
    })
}
</code></pre><p>注意：数据处理的函数名要跟跨域返回的函数名一样，这样我们通过JSONP请求数据的时候，服务器才能返回数据。<br>最终结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-df752a8458c616ff.gif?imageMogr2/auto-orient/strip" alt="跨域1.gif"></p>
<p>再句一个例子：<br>请求地址是<a href="http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice" target="_blank" rel="noopener">http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice</a></p>
<pre><code>function refreshPrice(data) { 
console.log(data);
}
window.onload = function () {  
    let scriptTag = document.createElement(&#39;script&#39;)
    let url = &#39;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&#39;
    scriptTag.setAttribute(&#39;src&#39;, url)
    document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag)
}
</code></pre><h2 id="Ajax（JQuery实现）"><a href="#Ajax（JQuery实现）" class="headerlink" title="Ajax（JQuery实现）"></a>Ajax（JQuery实现）</h2><p>在JQuery中，实现Ajax主要是由<strong>$.ajax({…})</strong>方法实现。方法的常用参数有：</p>
<ul>
<li>async：是否实现异步加载，一般来说，是true。</li>
<li>type：GET或者POST。</li>
<li>url：发送请求的地址。</li>
<li>timeout：设置请求的超时时间。</li>
<li>success：请求成功后的回调函数。</li>
<li>error：请求失败后的回调函数。</li>
<li>jsonp：在一个JSONP请求中重写回调函数的名字，默认为callback，用来重新命名回调我们跨域请求时候的函数名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。</li>
<li>jsonpCallback：为JSONP请求指定一个回调函数名。 </li>
<li>dataType：预期服务器返回的数据类型。不指定的话，JQueryhi自动判断。”xml”: 返回 XML 文档，可用jQuery处理。</li>
</ul>
<blockquote>
<p>“html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行；”script”: 返回纯文本JavaScript代码。不会自动缓存结果。除非设置了”cache”参数。注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。（因为将使用DOM的 script标签来加载）；”json”: 返回JSON数据；”jsonp”: JSONP格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数；”text”: 返回纯文本字符串。</p>
</blockquote>
<p>用JQuery实现同源的Ajax请求：</p>
<pre><code>$(function () {  
    $(&#39;button&#39;).on(&#39;click&#39;, function () {  
        $.ajax({
            url: &#39;./server.txt&#39;,    // 请求地址
            type: &#39;GET&#39;,    // 请求方式
            async: true,    // 是否异步
            success: function (data) {  
                console.log(data);
            }   // 请求成功后执行的函数
        })
    })
})
</code></pre><p>实现结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-b1fcb9ed574a8a24.gif?imageMogr2/auto-orient/strip" alt="异步2.gif"></p>
<p>用JQuery实现非同源的JSONP跨域请求：</p>
<pre><code>$(function () {  
$(&#39;button&#39;).on(&#39;click&#39;, function () {  
    $.ajax({
        url: &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39;,
        type: &#39;GET&#39;,
        async: true,
        dataType: &#39;jsonp&#39;,
        jsonp: &#39;_jsonp&#39;,
        jsonpCallback: &#39;__jsonp21__&#39;,
        success: function (data) {  
            console.log(data);
            $(&#39;#myDiv&#39;).html(data.area)
        },
        error: function (err) {  
            console.log(err);
        }
    })
})
})
</code></pre><p>实现结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-14e8fc745c21ab00.gif?imageMogr2/auto-orient/strip" alt="跨域2.gif"></p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>3D立体骰子</title>
    <url>/2019/02/16/3D%E7%AB%8B%E4%BD%93%E9%AA%B0%E5%AD%90/</url>
    <content><![CDATA[<p>CSS3确实很强大，很多高大上的动画都可以实现，这里来实现下3D立方体，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-21400fd37137e37c.gif?imageMogr2/auto-orient/strip" alt="3D立方体.gif"></p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>其实，实现3D立方体需要的html十分简单，只需要一个ul标签里面包裹6个li标签，分别用来表示3D立方体的6个面[ 前，下，后，上，左，右 ]。具体代码如下:</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
    &lt;li&gt;6&lt;/li&gt;
&lt;/ul&gt;
</code></pre><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h4 id="ul"><a href="#ul" class="headerlink" title="ul"></a>ul</h4><p>基本的宽高这些就不说了；作为整个3D立方体的父级元素，需要设置positiion属性为relative，还要最重要的是设置它的动画类型tranform-style为preserve-3d，这样就可以实现它的所有子元素都进行3d动画。</p>
<h4 id="li"><a href="#li" class="headerlink" title="li"></a>li</h4><p>宽高设置为100%，position属性设置为absolute。</p>
<ul>
<li>前<br>设置背景，并且沿着Z轴移动50px，即宽高的一半(为什么得添加这个, 后面用动画进行解释说明)。</li>
<li>下<br>设置背景，沿着<strong>X轴</strong>旋转-90deg，作为底面，同样，并且沿着Z轴移动50px。</li>
<li>后<br>设置背景，沿着<strong>X轴</strong>旋转-180deg，作为后面，同样，并且沿着Z轴移动50px。</li>
<li>上<br>设置背景，沿着<strong>X轴</strong>旋转90deg，作为上面，同样，并且沿着Z轴移动50px。</li>
<li>左<br>设置背景，沿着<strong>Y轴</strong>旋转-90deg，作为左面，同样，并且沿着Z轴移动50px。</li>
<li><p>右<br>设置背景，沿着<strong>Y轴</strong>旋转90deg，作为右面，同样，并且沿着Z轴移动50px。<br><img src="http://upload-images.jianshu.io/upload_images/659084-133d15ade6726266.gif?imageMogr2/auto-orient/strip" alt="效果.gif"></p>
<h4 id="结尾说明"><a href="#结尾说明" class="headerlink" title="结尾说明"></a>结尾说明</h4><p>这里说明上面那个translate，先来看看如果不添加这个属性是怎样的效果：<br><img src="http://upload-images.jianshu.io/upload_images/659084-2e1633af2155afdb.gif?imageMogr2/auto-orient/strip" alt="动画.gif"><br>可见，所有的面都交集于立方体的中心点。由于未对6个面作任何动画处理的时候，所有的面都集合在一起。所以在面作旋转的同时需要对其进行Z轴的位移处理。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>&lt;style&gt;
  * {
      margin: 0;
      padding: 0;
  }

  body {
      background-color: black;
  }

  ul {
      list-style: none;
      width: 100px;
      height: 100px;
      position: relative;
      cursor: pointer;
      margin: 150px auto;

      transition: 1s;    /* 设置过渡时间 */
      transform-style: preserve-3d;   /* 设置所有的子元素实现3D动画 */
  }

  /* 设置鼠标悬停的动画 */
  ul:hover {
      transform: rotateX(120deg) rotateY(120deg);
  }

  ul li {
      width: 100%;
      height: 100%;
      text-align: center;
      line-height: 100px;
      font-size: 40px;
      font-weight: 700;
      position: absolute;
      top: 0px;
  }
  /* 前 */
  ul li:nth-child(1) {
      background-color: rgba(225, 0, 0, .4);
      transform: rotateX(0deg) translateZ(50px);
  }
  /* 下 */
  ul li:nth-child(2) {
      background-color: rgba(0, 255, 0, .4);
      transform: rotateX(-90deg) translateZ(50px);
  }
  /* 后 */
  ul li:nth-child(3) {
      background-color: rgba(0, 0, 255, .4);
      transform: rotateX(-180deg) translateZ(50px);
  }
  /* 上 */
  ul li:nth-child(4) {
      background-color: rgba(125, 125, 0, .4);
      transform: rotateX(90deg) translateZ(50px);
  }
  /* 左 */
  ul li:nth-child(5) {
      background-color: rgba(0, 125, 125, .4);
      transform: rotateY(-90deg) translateZ(50px);
  }
  /* 右 */
  ul li:nth-child(6) {
      background-color: rgba(10, 45, 36, .4);
      transform: rotateY(90deg) translateZ(50px);
  }
&lt;/style&gt;
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件</title>
    <url>/2019/02/16/DOM%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件就是用户或者浏览器进行的特定行为，比如：鼠标点击事件。</p>
<h2 id="事件名称"><a href="#事件名称" class="headerlink" title="事件名称"></a>事件名称</h2><p>比如：click就是一个事件名。</p>
<h2 id="事件流的执行过程"><a href="#事件流的执行过程" class="headerlink" title="事件流的执行过程"></a>事件流的执行过程</h2><p>事件流：指的是 <em>DOM</em> 事件流（多个事件按照一定顺序执行），DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。<br>事件流的执行过程：从window开始，最后回到window。<br>事件流被分为三个阶段：事件捕获（1-5），事件触发（5-6），事件冒泡（6-10）。</p>
<p>来自网上的图片：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-eb2b449c3348c5d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件流.png"></p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a><a href="#事件冒泡" title="事件冒泡"></a>事件冒泡</h4><p>来自百度的解释：</p>
<blockquote>
<p>当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。</p>
</blockquote>
<p>就比如：我们用button产生一个click事件，但是由于button按钮本身可能不能处理这个事件，就要开始传播出去这个事件。<br>实现事件冒泡的条件是：元素之间有嵌套，每个元素都有相同的事件，这样当最里层的事件触发时，这个事件就会一级一级向上传播，也就是”冒泡“。</p>
<p>举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。这样，当里层点击事件触发时，外层的点击事件也会被触发。</p>
<pre><code>&lt;div id=&quot;outer&quot;&gt;
 &lt;div id=&quot;inner&quot;&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
 window.onload = function () {
   let inner = document.getElementById(&#39;inner&#39;)
   let outer = document.getElementById(&#39;outer&#39;)
   inner.addEventListener(&#39;click&#39;, function (e) {
     console.log(&#39;inner&#39;);
   })
   outer.addEventListener(&#39;click&#39;, function () { 
     console.log(&#39;outer&#39;);
   })
 }
&lt;/script&gt;
</code></pre><p>结果为：<br><img src="http://upload-images.jianshu.io/upload_images/659084-be2355e585a26bc5?imageMogr2/auto-orient/strip" alt="事件冒泡.gif"></p>
<h5 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h5><ul>
<li>一般浏览器：event.stopPropagation()</li>
<li>IE浏览器：event.cancelBubble = true</li>
</ul>
<h5 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h5><ul>
<li>一般浏览器：event.preventDefault()</li>
<li>IE浏览器：event.returnValue = false</li>
</ul>
<h2 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h2><p>addEventListener方法用于将事件和函数进行绑定，函数为：addEventListener(event, fn, useCapture)，这些参数分别是：事件名，事件处理函数，第三个参数 <strong>useCapture</strong> 是一个布尔值，用来设置该事件的执行是在哪个阶段发生的（默认是在冒泡阶段）。</p>
<ul>
<li>true：表示该事件是在“事件捕获阶段”触发的。（由外向内）</li>
<li>false：表示该事件是在“事件冒泡阶段”触发的。（由内向外）</li>
</ul>
<p>举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。</p>
<p>将第三个参数设置为true，事件在 <strong>捕获阶段</strong> 执行：</p>
<pre><code>&lt;div id=&quot;outer&quot;&gt;
 &lt;div id=&quot;inner&quot;&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
 window.onload = function () {
 let inner = document.getElementById(&#39;inner&#39;)
 let outer = document.getElementById(&#39;outer&#39;)
 inner.addEventListener(&#39;click&#39;, function (e) {
 console.log(&#39;inner&#39;);
 }, true)
 outer.addEventListener(&#39;click&#39;, function () { 
 console.log(&#39;outer&#39;);
 }, true)
 }
&lt;/script&gt;
</code></pre><p>由于是 <strong>捕获阶段</strong> 执行，即：由外向内执行，所以结果为： outer inner。</p>
<p>结果为：<br><img src="http://upload-images.jianshu.io/upload_images/659084-82bb228984257ae1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>将第三个参数设置为false，事件在 <strong>冒泡阶段</strong> 执行，输出结果为： inner outer。<br><img src="http://upload-images.jianshu.io/upload_images/659084-1d1d0c25024cc18d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="事件处理函数-事件监听函数"><a href="#事件处理函数-事件监听函数" class="headerlink" title="事件处理函数/事件监听函数"></a>事件处理函数/事件监听函数</h2><p>事件触发后的处理函数。如：btn.onclick = fn，fn就是事件处理函数/事件监听函数。</p>
<h4 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h4><p>例如：</p>
<pre><code>&lt;button onclick = &quot;fn()&quot;&gt;click&lt;/button&gt;
</code></pre><p>这种方式的缺点是：结构和行为耦合在一起。</p>
<h4 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h4><p>形式为：ele.on + ‘事件名称’ = 事件处理函数<br>例如： ele.onclick = function() {…}，this指向当前元素。</p>
<h4 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h4><p>这种方式主要是通过这两个方法：addEventListener()，removeEventListener()<br>这种方式的优点就是：可以同一个事件处理程序绑定多个事件处理函数。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托要处理的问题是：解决事件处理程序过多的问题。简单来说，就是将很多个事件处理程序委托给一个事件处理程序，通过这个事件处理程序来管理这么多个事件处理程序。<br>好处：减少对DOM的访问，提高性能；可以对后来添加进来的元素也能绑定委托事件。</p>
<p>例如：在一个 ul 标签中有很多个 li 标签，我们的需求而是点击每一个 li 标签显示每一个 li 标签的内容。<br>如果没有使用事件委托，我们需要给每一个 li 标签都添加事件监听函数，很明显，这样的效率并不高，而且对整个网页的性能也会影响；如果我们使用事件委托，将这些 li 的事件委托给 ul 标签，这样就可以只用一个事件监听函数实现。</p>
<p>代码如下：</p>
<pre><code>&lt;ul id=&quot;list&quot;&gt; 
 &lt;li&gt;111111&lt;/li&gt;
 &lt;li&gt;222222&lt;/li&gt;
 &lt;li&gt;333333&lt;/li&gt;
 &lt;li&gt;444444&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
 window.onload = function () { 
 // 传统的方法
 // let lis = document.getElementsByTagName(&#39;li&#39;)
 // console.log(lis);
 // for(let i = 0; i &lt; lis.length; i++){
 //     lis[i].addEventListener(&#39;click&#39;, function () { 
 //         console.log(this.innerHTML);
 //     })
 // }
 // 使用事件委托
 let list = document.getElementById(&#39;list&#39;)
 list.addEventListener(&#39;click&#39;, function (e) { 
   let target = e.target
   console.log(target.innerHTML);
 }, false)
 }
&lt;/script&gt;
</code></pre><p>事件委托一般使用的是 <strong>事件冒泡阶段</strong> 进行（虽然事件捕获阶段也可以），因为事件冒泡的事件流模型被所有的主流浏览器兼容，事件冒泡的兼容性更好。</p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>px/em/rem总结</title>
    <url>/2019/02/16/px-em-rem%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>对于<strong>px</strong>，大家都不陌生。它是一个相对于屏幕的相对长度单位。</p>
<h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p><strong>em</strong>也是一个相对长度单位，但它相对的是父级元素的字体大小。<br>对于em有一个推算过程：<br>如果没有定义自己的font-size，则：浏览器默认：<em>1em = 16px</em><br>所以：<br><em>12px = 0.75em</em><br><em>10px = 0.625em</em><br>但是如果每次都这样进行计算很麻烦，而且开发效率也很低，因此为了简化计算，我们将浏览器的font-size设置为<strong>62.5%</strong>，这样：<br><strong>1em = （16px * 62.5%） = 10px； 1.2em = 12px</strong><br>依次类推，要使用em这个相对长度单位，只要我们在body标签里面设置了font-size为62.5%，这样只要就可以得到计算公式：<strong>(n)px = (n \ 10)em</strong></p>
<p>但是，em单位是相对的，不是固定的，是逐级继承的（一层一层向上计算），举个例子：<br>比如，一个div里面嵌套了一个div，这两个div都设置了font-size为1.2em，浏览器的font-size设置为62.5%，此时，最里层的div的font-size大小是：<strong>（1.2 * 1.2） = 1.44em</strong>。</p>
<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p><strong>rem</strong>也是相对长度单位，从它的单位也可以看出，它跟<strong>em</strong>比较，多了个 <strong>r</strong> 字母，它的意思就是<strong>root（根）</strong>的意思。简单来说，就是它是相对于根节点（html标签）的font-size而言的。这样子，就消除了<strong>em</strong>单位逐级继承的缺点。<br>举个例子：<br>先将<strong>html</strong>标签设置为62.5%，这样，html里面的任何子标签都是继承于这个标签，也就是说相对于这个标签。所以，不论标签中有多少级的嵌套，最里层标签的font-size的计算公式永远是：<strong>(n)px = (n \ 10)rem</strong></p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js的原型和继承</title>
    <url>/2019/02/16/js%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式在《JavaScript高级程序设计》中的定义：</p>
<blockquote>
<p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用这个对象的好处就是可以让所有对象实例共享它包含的属性和方法。</p>
</blockquote>
<p>这里还有一个__proto__属性，每一个对象都拥有这个属性，这个属性指向对应的构造函数的prototype属性。</p>
<p>通过原型对象，我们就不用将信息添加到构造函数中了。</p>
<h4 id="实例对象共享原型对象的属性"><a href="#实例对象共享原型对象的属性" class="headerlink" title="实例对象共享原型对象的属性"></a>实例对象共享原型对象的属性</h4><pre><code>function Person(){}
Person.prototype.name = &#39;A&#39;
Person.prototype.age = 1
// 实例对象共享原型对象的属性
let p1 = new Person()
console.log(p1.name, p1.age);   // A 1
let p2 = new Person()
console.log(p2.name, p2.age);   // A 1
</code></pre><h4 id="constructor（构造函数）属性"><a href="#constructor（构造函数）属性" class="headerlink" title="constructor（构造函数）属性"></a>constructor（构造函数）属性</h4><p>每个原型对象在默认情况下都会自动获取一个constructor（构造函数）属性，这个属性包含一个指针，指向这个原型所在的函数。在上面的例子中，创建Person函数后，它的prototype指向它的原型对象，这个原型对象就会获取获取constructor属性，指向Person函数。</p>
<h4 id="判断实例对象与原型对象之间的关系"><a href="#判断实例对象与原型对象之间的关系" class="headerlink" title="判断实例对象与原型对象之间的关系"></a>判断实例对象与原型对象之间的关系</h4><ul>
<li>Obj.prototype.isPrototypeOf(obj)</li>
</ul>
<pre><code>console.log(Person.prototype.isPrototypeOf(p1)) // true
</code></pre><ul>
<li>Object.getPrototypeOf(obj)：返回对象实例的原型[es5]</li>
</ul>
<pre><code>console.log(Object.getPrototypeOf(p1) == Person.prototype);   // true
console.log(Object.getPrototypeOf(p1).name);    // A
</code></pre><ul>
<li>obj.hasOwnPrototype(attr)：检测一个属性是否存在于实例中。只有当实例对象重写原型对象的属性后（非原型属性）才会返回true。</li>
</ul>
<pre><code>console.log(p1.hasOwnProperty(&#39;name&#39;)); // false
p1.name = &#39;Ertsul&#39;
console.log(p1.hasOwnProperty(&#39;name&#39;)); //true
</code></pre><ul>
<li><p>in操作符：通过in操作符和hasOwnProperty()可以判断某属性存在于实例还是原型对象中【in判断是否存在属性，hasOwnProperty()判断存在于哪里。】可以单独使用和for-in循环使用：无论属性属于实例还是原型中，都会返回true。(‘name’ in person1)</p>
</li>
<li><p>获取所有实例的属性名字，无论是否可以枚举。</p>
</li>
</ul>
<pre><code>console.log(Object.getOwnPropertyNames(p1)); // [&quot;name&quot;]
</code></pre><ul>
<li>instanceof</li>
</ul>
<pre><code>console.log(p1 instanceof Person);    // true
</code></pre><h4 id="更简单的语法"><a href="#更简单的语法" class="headerlink" title="更简单的语法"></a>更简单的语法</h4><pre><code>function Person() {  }
Person.prototype = {
 name: &#39;001&#39;
}
let p1 = new Person()
console.log(p1.name);
</code></pre><p>这里的例外是：constructor属性不再指向Person；本质上相当于完全重写了Person对象了。注：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。[详见《JavaScript高级程序设计》P156-P157，原型的动态性]</p>
<p>####搜索机制</p>
<ul>
<li>解释器会现在目标对象中搜索目标属性，如果当前对象没有目标属性，解释器继续在目标对象的原型对象中搜索。</li>
<li>通过delete只能删除对象的属性，而不能删除原型对象中的属性。</li>
</ul>
<h4 id="组合模式（默认类型）：构造函数模式-原型模式"><a href="#组合模式（默认类型）：构造函数模式-原型模式" class="headerlink" title="组合模式（默认类型）：构造函数模式 + 原型模式"></a>组合模式（默认类型）：构造函数模式 + 原型模式</h4><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><pre><code>// 父亲
function Father() { 
 this.fatherProperty = true
}
Father.prototype.getFatherValue = function () { 
 return this.fatherProperty
}
// 儿子
function Son() { 
 this.sonProperty = false
}
// 继承父亲：通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性
Son.prototype = new Father()
Son.prototype.getSonValue = function () { 
 return this.sonProperty
}

let instance = new Son()
console.log(instance.fatherProperty);   // true
</code></pre><p>上面例子中，通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性。（重写儿子的原型）。这里，儿子原型对象的[[prototype]]（注：不是prototype，[[prototype]]存在于原型中）指向的是父亲的原型对象，而父亲的原型对象的[[prototype]]指向的是Object Prototype。（由于所有函数的默认原型都是Object的实例，所以默认原型都会包含一个内部指针，指向Object.prototype）</p>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><ul>
<li>主要是为了解决因为引用类型值的原型属性会被所有实例共享的问题。</li>
<li><strong>借用构造函数/伪造对象/经典继承</strong>：在子类型构造函数的内部调用超类型构造函数。</li>
</ul>
<pre><code>// 父亲
    function Father() { 
     this.info = [&#39;Zero&#39;]
    }
    // 儿子
    function Son() { 
     // 继承父亲：在子类型构造函数的内部调用超类型构造函数
     // 《JavaScript高级程序设计》：函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call() 可以在新创建的对象上执行构造函数。 
     Father.call(this)        // 借用超类的构造函数
    }

    let f = new Father()
    f.info.push(&#39;100&#39;)
    console.log(f.info);    // [&quot;Zero&quot;, &quot;100&quot;]

    let s = new Son()
    console.log(s.info);    // [&quot;Zero&quot;]
</code></pre><p>如果在继承的时候要传递参数，则在后面添加参数即可。如：Father.call(this， param1, param2)</p>
<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>通过<strong>__proto__</strong>也可以实现子类型对超类型的继承。</p>
<pre><code>const obj = {
 num : 123 
}
const obj1 = {
 __proto__ : obj
}
console.log(obj1.num);  // 123
</code></pre><h4 id="Object-create-source"><a href="#Object-create-source" class="headerlink" title="Object.create(source)"></a>Object.create(source)</h4><pre><code>const obj = {
 num : 123 
}
const obj2 = Object.create(obj)
console.log(obj2.num);  // 123
</code></pre><h4 id="Object-assign-Object-create-obj-…"><a href="#Object-assign-Object-create-obj-…" class="headerlink" title="Object.assign(Object.create(obj), {…})"></a>Object.assign(Object.create(obj), {…})</h4><pre><code>const obj = {
 num : 123 
}
const obj3 = Object.assign(
 Object.create(obj),
 {
 num2 : 234
 }
)
console.log(obj3.num, obj3.num2);   // 123 234
</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="继承机制如下图："><a href="#继承机制如下图：" class="headerlink" title="继承机制如下图："></a>继承机制如下图：</h4><p><img src="http://upload-images.jianshu.io/upload_images/659084-862bb97f2e2fe227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="测试代码如下："><a href="#测试代码如下：" class="headerlink" title="测试代码如下："></a>测试代码如下：</h4><pre><code>// 父类
function SuperType(){
}
// 子类
function SubType(){

}
// 子类继承父类
SubType.prototype = new SuperType();
// 实例化父类和子类
let superIns = new SuperType();
let subIns = new SubType();

// 子类
console.log(SubType.prototype);     // SuperType {}
console.log(subIns.__proto__);      // SuperType {}

// 父类
console.log(SuperType.prototype);       // {constructor: ƒ} 
console.log(superIns.__proto__);        // {constructor: ƒ}

console.log(SuperType.prototype.__proto__);     
// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
// 即： Object prototype

console.log(SuperType.prototype.__proto__.constructor);
// ƒ Object() { [native code] } 即：Object
</code></pre>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js的存储和拷贝</title>
    <url>/2019/02/16/js%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Undefined</li>
<li>Null<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4>多个基本数据类型复合形成。</li>
<li>Object</li>
</ul>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><h4 id="基本数据类型的存储方式"><a href="#基本数据类型的存储方式" class="headerlink" title="基本数据类型的存储方式"></a>基本数据类型的存储方式</h4><ul>
<li>每当定义一个基本数据类型的变量，会在 <strong>栈区</strong> 开辟一个内存空间，用于存放该变量。栈区的特点是：静态分配，大小固定。</li>
<li>当一个变量通过直接复制的方式复制给另一个变量，系统会在 <strong>栈区</strong>  重新开辟一个内存空间；两个变量互不影响。</li>
</ul>
<pre><code>let num1 = 10;
let num2 = num1;
num2 = 20;
console.log(num1);     // 10 
</code></pre><h4 id="引用类型的存储方式"><a href="#引用类型的存储方式" class="headerlink" title="引用类型的存储方式"></a>引用类型的存储方式</h4><ul>
<li>每当定义一个引用类型，如：对象，会在 <strong>堆区</strong> 开辟一个内存空间；然后如果创建一个该对象的实例，会在 <strong>栈区</strong> 开辟一个内存存放该实例，该实例实际上是一个指向 <strong>堆内存</strong> 对象的指针。堆区的特点是：动态分配，大小不固定。</li>
<li>当一个实例直接复制给另一个实例，系统会在 <strong>栈区</strong>  重新开辟一个内存空间，但是新实例同样也是一个指向  <strong>堆内存</strong> 对象的指针，所以，这样的操作，这样的修改都会对新旧实例产生影响。</li>
</ul>
<pre><code>let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}

//直接复制
let obj2 = obj1;

obj2.name = &#39;Ertsul&#39;;
obj2.num[0] = &#39;一&#39;;
console.log(obj1, obj2);
// name:&quot;Ertsul&quot;
// age:22
// num:[&quot;一&quot;, &quot;2&quot;, &quot;3&quot;]
</code></pre><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>两者的区别主要在于 <strong>复制层次</strong> 的不同：</p>
<ul>
<li>浅拷贝主要复制到对象属性这一层次，如果对象里面有子对象，则无法对子对象完成复制；之后对于子对象的修改 <strong>会</strong> 影响到原复制对象。</li>
<li>深拷贝则是浅拷贝的 <strong>加强版</strong> ，可以实现对于子对象的拷贝；之后对于子对象的修改 <strong>不会</strong> 影响到原复制对象。主要实现方法有：<ul>
<li>递归</li>
<li>JSON解析<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4></li>
</ul>
</li>
</ul>
<pre><code>// 浅拷贝
function shallowCopy(source) {
    let result = {};
    for(let key in source){
        result[key] = source[key]
    }
    return result;
}
let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}

let obj2 = {};
obj2 = shallowCopy(obj1);

obj2.name = &#39;Ertsul&#39;;    // 不会产生影响
obj2.num[0] = &#39;一&#39;;      // 产生影响
console.log(&quot;obj1&quot;, obj1);
console.log(&quot;obj2&quot;, obj2);
</code></pre><p>结果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-2238425cd781911c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><pre><code>// 递归实现深拷贝
function deepCopy(source, res){
    var res = res || {};
    for(let i in source){
        if(typeof source[i] === &#39;object&#39;){
            if(source[i].constructor === Array){
                res[i] = []
            }else {
                res[i] = {}
            }
            deepCopy(source[i], res[i]);   // 递归子对象属性
        }else{
            res[i] = source[i]
        }
    }
    return res;
}

let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}

let result = {}
result = deepCopy(obj1, result);
result.name = &#39;Ertsul&#39;;
result.num[1] = &#39;二&#39;;
console.log(&quot;result&quot;, result);
console.log(&quot;obj1&quot;, obj1);
</code></pre><p>结果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-522f00e896a05506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h5><pre><code>// JSON实现深拷贝
let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}
let result1 = JSON.parse(JSON.stringify(obj1));
result1.num[2] = &#39;三&#39;;
console.log(&#39;result1&#39;, result1);
console.log(&#39;obj1&#39;, obj1);
</code></pre><p>结果如图：<br><img src="http://upload-images.jianshu.io/upload_images/659084-b747df9bb831bf93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js/es6小知识大杂烩</title>
    <url>/2019/02/16/js-es6%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
    <content><![CDATA[<h4 id="合并两个数组"><a href="#合并两个数组" class="headerlink" title="合并两个数组"></a>合并两个数组</h4><ul>
<li>数组的解构 <strong>[…arr1, …arr2]</strong></li>
<li>Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。</li>
<li>arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。</li>
</ul>
<pre><code>let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = [...arr1,  ...arr2];
console.log(arr3);
Array.prototype.push.apply(arr1,  arr2);
console.log(arr1);
</code></pre><h4 id="arguments-伪数组-转化为数组"><a href="#arguments-伪数组-转化为数组" class="headerlink" title="arguments/伪数组 转化为数组"></a>arguments/伪数组 转化为数组</h4><ul>
<li>[…arguments]</li>
<li>Array.prototype.slice.call(arguments)</li>
</ul>
<pre><code>(function Fn() {
    let arr = [...arguments, &#39;Ertsul&#39;];
    console.log(arr);
})(&#39;zero&#39;);
(function Fn1() {
    let arr = Array.prototype.slice.call(arguments);
    console.log(arr);
})(&#39;zero&#39;);
</code></pre><h4 id="判断字符类型"><a href="#判断字符类型" class="headerlink" title="判断字符类型"></a>判断字符类型</h4><ul>
<li>Object.prototype.toString.call()</li>
<li>typeof</li>
<li>instanceof</li>
</ul>
<h4 id="创建实例的方法"><a href="#创建实例的方法" class="headerlink" title="创建实例的方法"></a>创建实例的方法</h4><ul>
<li>字面量 let obj = {…}</li>
<li>new Object()构造函数</li>
<li>构造函数</li>
<li>Object.create()</li>
<li>工厂模式</li>
</ul>
<pre><code>// 字面量
let obj1 = {
    name: &#39;zero&#39;,
    age: 22
};
// Object 构造函数
let obj2 = new Object();
obj2.name = &#39;zero&#39;;
console.log(obj2.name);
// 工厂模式
function Person(name) {
    let obj = new Object();
    obj.name = name;
    return obj;
}
let p1 = Person(&#39;zero&#39;);
console.log(p1.name);
// 构造函数
function Animal(name) {
    this.name = name;
}
let a2 = new Animal(&#39;dog&#39;);
console.log(a2.name);
</code></pre><h4 id="数组的拆解-flat"><a href="#数组的拆解-flat" class="headerlink" title="数组的拆解 flat"></a>数组的拆解 flat</h4><pre><code>let arr2 = [1, [2, 3, [100, 8989]], [4, 5, 6, 7, 8]];
const flat = arr =&gt; arr.toString().split(&#39;,).map(item =&gt; +item);
console.log(flat(arr2)); // [1, 2, 3, 100, 8989, 4, 5, 6, 7, 8]
</code></pre><h4 id="继承的方法-–-8种"><a href="#继承的方法-–-8种" class="headerlink" title="继承的方法 – 8种"></a>继承的方法 – 8种</h4><ul>
<li>通过原型继承<ul>
<li>缺点：引用类型存在共享问题。</li>
</ul>
</li>
</ul>
<pre><code>function Fn1() { ... }
function Fn2() { ... }
Fn2.prototype = new Fn1();
</code></pre><ul>
<li>构造函数：通过 <strong>call</strong> 更改 <strong>this</strong> 指向；实际上是调用了父类的构造函数。<ul>
<li>缺点：父类中的方法（构造函数中）子类不可见。</li>
</ul>
</li>
</ul>
<pre><code>function Fn1() { ... }
function Fn2() { 
  Fn1.call(this);   // 将 this 绑定到 Fn1
}
</code></pre><pre><code>function SuperType(){

}
SuperType.prototype.sayHi = function(){
    console.log(&#39;Hi&#39;);
}

function subType(){
    SuperType.call(this);
}

let superIns = new SuperType();
superIns.sayHi();   // Hi

let subIns = new subType();
subIns.sayHi();     // Uncaught TypeError
</code></pre><ul>
<li>组合继承（原型 + 构造）<br>属性通过构造函数继承；方法通过原型继承。记得要更改 <strong>Fn2.prototype.constructor</strong> 的指向，指向子类。</li>
</ul>
<pre><code>// 组合继承
function Fn1() {
    this.name = &#39;zero&#39;
}

Fn1.prototype.sayName = function () {
    console.log(this.name);
};

function Fn2() {
    // 继承属性
    Fn1.call(this);
    this.age = 22;
}
// 继承方法
Fn2.prototype = new Fn1();
Fn2.prototype.constructor = Fn2;   // 需要修复构造函数指向

Fn2.prototype.sayAge = function () {
    console.log(this.age);
};

let f = new Fn2();
f.sayName();
f.sayAge();
</code></pre><ul>
<li>实例继承<br>在一个函数内实例化，然后添加新属性，并返回该对象。</li>
</ul>
<pre><code>function Fn() { ... }
function Fn2(name) {
 let obj = new Fn();
 obj.name = name;
 return obj;
}
</code></pre><ul>
<li>原型式继承<br>将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。</li>
</ul>
<pre><code>function SuperType(name) {
    this.name = name
}

function Object(o){
    function F(){}
    F.prototype = o;
    return new F();
}

let subType = Object(new SuperType(&#39;zero&#39;));
console.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__
</code></pre><ul>
<li>拷贝继承<br>将原型/父类上的属性全部拷贝到子类上。</li>
</ul>
<pre><code>// 拷贝继承
function Fn1() {
    this.name = &#39;zero&#39;;
    this.age = 22
}
function Fn2() {
    let f1 = new Fn1();
    // 注意这里要用 in 操作符
    for (let item in f1) {
        Fn2.prototype[item] = f1[item];
    }
    Fn2.prototype.ownFun = function () {
        console.log(&#39;my own function.&#39;);
    }
}

let f = new Fn2();
console.log(f.name + &quot;, &quot; + f.age);
f.ownFun();
</code></pre><ul>
<li>寄生组合式模型<ul>
<li>通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。</li>
<li>通过构造函数实现属性的继承。</li>
</ul>
</li>
</ul>
<pre><code>// 寄生组合式继承
function inheritPrototype(subType, superType) {
    // 创建对象：新建的对象指向父类的原型
    let prototype = Object(superType.prototype);
    // 增强对象：新建对象的 constructor 指向子类
    prototype.constructor = subType;
    // 指定对象：子类的原型指向新建对象
    subType.prototype = prototype;
}

function Fn1() {
    this.name = &#39;Ertsul&#39;;
}

Fn1.prototype.sayName = function () {
    console.log(this.name);
};

function Fn2() {
    Fn1.call(this);
    this.age = 22;
}

inheritPrototype(Fn2, Fn1);

Fn2.prototype.sayAge = function () {
    console.log(this.age);
};

let f = new Fn2();
f.sayName();f.sayAge();
</code></pre><ul>
<li>es6 的 extends </li>
</ul>
<pre><code>// class
class F1 {
    constructor(name) {
        this.name = name;
    }
}

class F2 extends F1 {
    constructor(name, age){
        super(name);    // 调用父类的构造函数
        this.age = age;
    }
    showMsg(){
        console.log(this.name + &#39;, &#39; + this.age);
    }
}

let p = new F2(&#39;zero&#39;, 22);
p.showMsg();  // zero, 22
</code></pre><h4 id="比较两个对象是否相等"><a href="#比较两个对象是否相等" class="headerlink" title="比较两个对象是否相等"></a>比较两个对象是否相等</h4><ul>
<li>遍历对象对象进行判断。</li>
<li>将对象转化为字符串进行判断。</li>
</ul>
<pre><code>let obj1 = {
    name: &#39;a&#39;,
    age: 1
}
let obj2 = obj1;
let obj3 = {
    name: &#39;a&#39;,
    age: 2
}
console.log(JSON.stringify(obj1));
console.log(JSON.parse(JSON.stringify(obj1)));
console.log(JSON.stringify(obj1) == JSON.stringify(obj2));  // true
console.log(JSON.stringify(obj1) == JSON.stringify(obj3));  // false    
</code></pre><h4 id="封装一个时间函数，时间通过-time-传递，回调函数通过-then-函数执行"><a href="#封装一个时间函数，时间通过-time-传递，回调函数通过-then-函数执行" class="headerlink" title="封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行"></a>封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行</h4><pre><code>function time(time){
    return new Promise((resolve, reject) =&gt; {
        setTimeout(resolve, time);
    })
}

let t = new time(5000);
t.then((a, b) =&gt; {
    console.log(&#39;time&#39;);
})
</code></pre><h4 id="原型相关的API"><a href="#原型相关的API" class="headerlink" title="原型相关的API"></a>原型相关的API</h4><ul>
<li>Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例</li>
<li>Object.getPrototypeOf(p1)：获取原型</li>
<li>p1.hasOwnProperty(‘name’)：判断某个属性是否属于某个实例（只能获取属性实例）</li>
<li>in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中）</li>
</ul>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}

let p1 = new Person(&#39;Ertsul&#39;, 22);
console.log(Person.prototype);      // constructor f
console.log(Person.prototype.constructor);  // Person
console.log(Person.prototype.__proto__);    // constructor 的原型
console.log(p1.__proto__);      // // constructor f

console.log(Person.prototype.isPrototypeOf(p1));    // true
console.log(Person.isPrototypeOf(p1));      // false
console.log(Object.getPrototypeOf(p1));     // constructor f

console.log(p1.hasOwnProperty(&#39;name&#39;));     // true 存在实例中

Person.prototype.num = 100

console.log(p1.hasOwnProperty(&#39;num&#39;));      // fasle    存在原型中

console.log(&#39;num&#39; in p1);   // true 不管是实例还是原型中
</code></pre><h4 id="js-判断数组类型"><a href="#js-判断数组类型" class="headerlink" title="js 判断数组类型"></a>js 判断数组类型</h4><ul>
<li>arr instanceof Array</li>
<li>arr.constructor === Array</li>
</ul>
<pre><code>let arr = [1, 2, 3];
let obj = {}
function judgeFn(arr){
    // return arr.constructor === Array ? true : false
    return arr instanceof Array ? true : false
}
console.log(judgeFn(arr));  // true
console.log(judgeFn(obj )); // false
</code></pre><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><pre><code>/* 日期格式化 */
function formatNumber(num) {
    const n = `${num}`;        // 转化为字符串
    return n[1] ? n : `0${n}`;
}
function formatTime(date){
    // 年 月 日
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    // 时 分 秒
    const hour = date.getHours();
    const minute = date.getMinutes();
    const second = date.getSeconds();

    return `${[year, month, day].map(formatNumber).join(&#39;-&#39;)} ${[hour, minute, second].map(formatNumber).join(&#39;:&#39;)}`
}
let time = new Date();
console.log(time);        // Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间)
let t1 = formatTime(time);
console.log(t1);        // 2018-08-14 16:52:06
</code></pre><h4 id="字符串转化为标准日期格式"><a href="#字符串转化为标准日期格式" class="headerlink" title="字符串转化为标准日期格式"></a>字符串转化为标准日期格式</h4><pre><code>/* 字符串转化为标准日期格式 */
function time2string(str) {
    const chunks = str.split(&#39; &#39;);
    const date = chunks[0].split(&#39;-&#39;);
    const time = chunks[1].split(&#39;:&#39;);

    return new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]);
}
let str = &quot;2018-08-14 23:59:59&quot;;
let t2 = time2string(str);
console.log(t2);    // Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间)
</code></pre><h4 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h4><pre><code>/* 防抖节流 debounce throttle */
// 防抖 - 连续快速触发的解决方案
function debounce(fn, wait) {
    let timeout = null;    // 初始化 timer 定时器
    return function (){
        timeout &amp;&amp; clearTimeout(timeout);    // 清空定时器
        timeout = setTimeout(fn, wait);        // 设置定时器
    }
}
// 节流 - 一定时间内请求一次 -- 定时器法
function throttle1(fn, wait) {
    let timer = null;    // 初始化 timer 定时器
    return function () {
        let context = this;        // 保存上下文 this
        let args = arguments;    // 记录参数
        if(!timer) {    // 定时器为空
            timer = setTimeout(() =&gt; {
                fn.apply(context, args);
                timer = null;    // 清空定时器
            }, wait);
        }
    }
}
// 节流 - 一定时间内请求一次 -- 时间戳法
function throttle2(fn, wait) {
    let prev = Date.now();    // 记录前一个时间
    return function () {
        let context = this;        // 保存上下文 this
        let args = arguments;    // 记录参数
        let now = Date.now();     // 记录当前时间
        if(now - prev &gt;= wait){        // 时间戳大于设置的时间
            fn.apply(context, args);
            prev = Date.now();    // 记录前一个时间
        }
    }
}

// window.addEventListener(&#39;scroll&#39;, debounce(() =&gt; {
 //    console.log(Math.random());
// }, 500));
// window.addEventListener(&#39;scroll&#39;, throttle1(() =&gt; {
//     console.log(Math.random());
// }, 1000));
window.addEventListener(&#39;scroll&#39;, throttle2(() =&gt; {
    console.log(Math.random());
}, 1000))
</code></pre><ul>
<li>JSON.stringfy(obj, [replace, space])<ul>
<li>巧用第二个参数，可以实现json对象的过滤替换。</li>
<li>第三个参数，是缩进的空格数。    </li>
<li>如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。</li>
</ul>
</li>
</ul>
<pre><code>let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    hobby: &#39;ball&#39;
};

let str1 = JSON.stringify(obj1);
console.log(str1, typeof str1, str1.constructor === String);    // {&quot;name&quot;:&quot;zero&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;} string true
let str2 = JSON.stringify(obj1, (key, value) =&gt; {
    if(value === &#39;zero&#39;) {
        return &#39;Ertsul.&#39;
    }else {
        return value;
    }
});
console.log(str2);  // {&quot;name&quot;:&quot;Ertsul.&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;}

let obj2 = {
    num: 100,
    toJSON(){
        return &#39;apple&#39;
    }
};

let str3 = JSON.stringify(obj2);
console.log(str3);  // apple
</code></pre><ul>
<li>数组的 sort()<br>sort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。<br>如果要对数组的数字进行排序，则需要：<blockquote>
<p>array.sort((val1, val2) =&gt; {return val - val2});</p>
</blockquote>
</li>
</ul>
<p>通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。</p>
<pre><code>let arr10 = [1, 2, 19, 12, 22];
console.log(arr10.sort()); // [1, 12, 19, 2, 22]
console.log(arr10.sort((val1, val2) =&gt; {  // [1, 2, 12, 19, 22]
  return val1 - val2;
}));  
</code></pre><ul>
<li>reduce函数<blockquote>
<p>reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。</p>
</blockquote>
</li>
</ul>
<p>其完整的函数为： </p>
<pre><code>arr.reduce((prev, next, cur, srcArr) =&gt; {
  ......
}, initVal)
</code></pre><ul>
<li>prev: 上次返回的值</li>
<li>next: 下一个数组元素的值</li>
<li>cur: 当前数组元素的索引值</li>
<li>scrArr: 源数组</li>
<li>initVal: 设置第一次的 <strong>prev</strong></li>
</ul>
<p>例子 1：</p>
<pre><code>let arr = [&#39;apple&#39;, &#39;pear&#39;, &#39;bananas&#39;];
arr.reduce((prev, next, cur, arr) =&gt; {
  console.warn(prev, next, cur, arr);
  return next;
}, &#39;fruit&#39;)
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-65c2bd1bf155dfaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>例子 2：统计一个数组中单词出现的次数</p>
<pre><code>// 统计数组中单词出现的次数
let arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;bananas&quot;, &quot;bananas&quot;];
function getCount(arr) {
  return arr.reduce((prev, next, cur) =&gt; {
    prev[next] = (prev[next] + 1) || 1
    return prev;
  }, {})
}
console.warn(getCount(arr));  // {apple: 2, orange: 3, pear: 1, bananas: 2}
</code></pre><ul>
<li>Object.seal()<br>防止对象纂改：不能添加也不能删除属性</li>
</ul>
<pre><code>let obj = {
  name: &#39;Ersul&#39;
}
Object.seal(obj); // 防止对象纂改：不能删除也不能添加属性
delete obj.name;
console.warn(obj.name); // Ertsul
obj.age = 22;
console.warn(obj.age); // undefined
</code></pre><ul>
<li>Object.freeze()<br>冻结对象，不能修改对象任何属性的值。如若</li>
</ul>
<pre><code>let obj = {
  name: &#39;Ersul&#39;
}

Object.freeze(obj); // 冻结对象，不能修改属性的值
obj.name = &#39;Zero&#39;;
console.warn(obj.name); // Ertsul
</code></pre><ul>
<li>数组字符串的相互转化</li>
</ul>
<pre><code>// 数组 --&gt; 字符串 : join()
let arr3 = [1, 2, 3, 4, 5];
console.log(arr3.join(&#39;-&#39;));
// 字符串 --&gt; 数组 : split()
let str = &#39;apple,pear,bananas&#39;;
console.log(str.split(&#39;,&#39;));
</code></pre>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习笔记</title>
    <url>/2019/02/16/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><ul>
<li>新建项目文件夹</li>
<li>npm init</li>
<li><p>设置项目目录结构，结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-bd9163add73e9ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p><strong>build</strong> 目录是 webpack 打包后的生成目录，<strong>index.html</strong> 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。</p>
</li>
<li><strong>src</strong> 目录是项目源文件，<strong>template.html</strong> 是 html 文件模板。</li>
<li><strong>webpack.config.js</strong> 是配置 <strong>webpack</strong> 的总文件。</li>
</ul>
<pre><code>module.exports = { ... }
</code></pre><h2 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式 mode"></a>模式 mode</h2><pre><code>mode: &quot;development&quot;, // development or production
</code></pre><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口 entry"></a>入口 entry</h2><p>设置打包的入口文件, entry: filepath</p>
<pre><code>entry: &quot;./src/index.js&quot;, // 入口
</code></pre><h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出 output"></a>输出 output</h2><p>设置打包后的输出文件，output: { … }</p>
<pre><code>output: { // 输出
  filename: &quot;bundle.[hash:8].js&quot;,
  path: path.resolve(__dirname + &#39;/build&#39;),
  // publicPath: &quot;http://&quot;, // 公共路径前缀
},
</code></pre><p>注：</p>
<ul>
<li><strong>path</strong> 后面应是绝对路径。</li>
<li><strong>bundle.[hash:8].js</strong> 中的 <strong>[hash:8]</strong> 可以在每次打包后都在文件后面追加 hash 值。</li>
</ul>
<p>通过上面三项，可以实现一个简单的 <strong>webpack</strong> 打包配置。在 <strong>package.json</strong> 添加脚本或直接执行 <strong>./node_modules/.bin/webpack</strong> 即可实现打包：</p>
<pre><code>&quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;,
</code></pre><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack 开发服务器，用于开发时候的配置：</p>
<ul>
<li>yarn add taco –dev webpack-dev-server / npm install –save-dev webpack-dev-server</li>
<li>基本配置如下：</li>
</ul>
<pre><code>devServer: { // 开发服务器
  port: 3001,
  contentBase: path.resolve(__dirname + &#39;/build&#39;), // 本地服务器目录
  progress: true, // 进度条
  open: true, // 自动打开浏览器
  compress: true, // 压缩
  // 1. 代理
  proxy: {
    &quot;/api&quot;: {
      target: &quot;&quot;,
      pathRewrite: {
        &quot;/api&quot;: &quot;&quot;
      }
    }
  },
  // 2. 用 express 内置钩子模拟数据
  before(app) {
    app.get(&quot;/api&quot;, (req, res) =&gt; { ... })
  },
  // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件
},
},
</code></pre><ul>
<li>在 <strong>package.json</strong> 添加脚本即可：</li>
</ul>
<pre><code>&quot;dev&quot;: &quot;webpack-dev-server&quot;
</code></pre><h2 id="source-map-amp-amp-eval-source-map-amp-amp-cheap-module-source-map-amp-amp-cheap-module-eval-source-map"><a href="#source-map-amp-amp-eval-source-map-amp-amp-cheap-module-source-map-amp-amp-cheap-module-eval-source-map" class="headerlink" title="source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map"></a>source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map</h2><p>作用：源码映射，报错时显示出错的位置。</p>
<ul>
<li>source-map：会单独生成一个 <strong>sourcemap</strong> 文件；会显示行列。</li>
<li>eval-source-map：不会单独生成一个 <strong>sourcemap</strong> 文件，会将生成的 <strong>sourcemap</strong> 放到打包后的 <strong>html</strong> 文件；会显示行和列。</li>
<li>cheap-module-source-map：会生成 <strong>sourcemap</strong> 文件，不会显示列。</li>
<li>cheap-module-eval-source-map：不会生成 <strong>sourcemap</strong> 文件，集成在 <strong>html</strong> 文件中，不会显示列。</li>
</ul>
<pre><code>devtool: &quot;source-map&quot;, // 源码映射
</code></pre><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>作用：监控代码实时变化，进行编译打包。</p>
<pre><code>watch: true, // 监控代码实时变化，进行编译打包
watchOptions: {
  poll: 1000, // 多毫秒监控一次
  aggreatement: 500, // 防抖
  ignored: &quot;node_modules&quot; // 忽略文件夹
},
</code></pre><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>作用：解析第三方包</p>
<pre><code>resolve: { // 解析 第三方包
  modules: [
    path.resolve(&quot;node_modules&quot;), // 在当前目录下查找模块 
    path.resolve(&quot;other_modules&quot;), // 在其他目录下查找模块 
  ],
  // 自动添加扩展名，主要是 import 时候使用, 依次解析
  extensions: [&quot;.js&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.vue&quot;],
  // 比如引用 bootstrap 的 css 样式
  // 方式一： bootstrap 的主入口
  mainFields: [&quot;style&quot;, &quot;main&quot;],
  // 方式二：别名  
  // alias: {
  //   bootstrap: &quot;bootstrap/dist/css/bootstrap.css&quot;
  // }
},
</code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>webpack 的插件配置是一个数组，里面存放着各种各样的插件。</p>
<pre><code>plugins: [
 new pluginName(...)
]
</code></pre><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>插件作用：打包时候自动根据 <strong>html</strong> 模板生成目标 <strong>html</strong> 文件，自动生成目标打包目录；另外，可配置 <strong>html</strong> 的相关打包配置，如：压缩，去双引号等。</p>
<pre><code>new HtmlWebpackPlugin({
  filename: &quot;index.html&quot;, // 目标文件名称
  template: path.resolve(__dirname + &#39;/src/template.html&#39;), // 模板文件
  minify: { // 压缩配置
    removeAttributeQuotes: true, // 去双引号
    collapseWhitespace: true, // 不换行
  },
  hash: true // 生成 hash 戳
})
</code></pre><h4 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h4><p>作用：将生成的 <strong>css样式</strong> 抽离成一个 <strong>css文件</strong>，并将该样式文件引进目标 <strong>html</strong> 文件中。</p>
<pre><code>plugins: [ // 插件
  new MiniCssExtractPlugin({
    filename: &quot;main.css&quot;,
  })
],
module: { // 模块
  rules: [{
    test: /\.css$/,
    use: [
      // {
      //   loader: &quot;style-loader&quot;,
      //   options: {
      //     insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级
      //   }
      // },
      MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序
      &quot;css-loader&quot;
    ]
  }]
}
</code></pre><p>注：这里抽离出来的 <strong>main.css</strong> 文件并没有压缩，要通过手动添加以下两个插件到优化项：</p>
<ul>
<li>optimize-css-assets-webpack-plugin</li>
<li>uglifyjs-webpack-plugin</li>
</ul>
<pre><code>optimization: { // 优化项
  minimizer: [
    new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件
    new UglifyjsWebpackPlugin({
      cache: true,
      parallel: true,
    }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置
  ]
},
</code></pre><h4 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h4><p>插件作用：压缩抽离出来的 <strong>main.css</strong> 文件。但是，使用了 <strong>optimize-css-assets-webpack-plugin</strong> 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 <strong>uglifyjs-webpack-plugin</strong> 。</p>
<h4 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h4><p>插件作用：压缩打包后的 <strong>js</strong> 文件。</p>
<h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h4><p>作用：清理文件</p>
<pre><code>plugins: [
 new CleanWebpackPlugin(&quot;./build&quot;)
]
</code></pre><h4 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h4><p>作用：将某些文件拷贝到打包后的文件夹。</p>
<pre><code>new CopyWebpackPlugin([
  {from: &quot;./copy&quot;, to: &quot;./&quot;}
])
</code></pre><h4 id="banner-plugin"><a href="#banner-plugin" class="headerlink" title="banner-plugin"></a>banner-plugin</h4><p>作用：版权声明，是 <strong>webpack</strong> 的内置模块。</p>
<pre><code>new webpack.BannerPlugin(&quot;@copyright by Ertsul&quot;)
</code></pre><h4 id="webpack-DefinePlugin-…"><a href="#webpack-DefinePlugin-…" class="headerlink" title="webpack.DefinePlugin({ … })"></a>webpack.DefinePlugin({ … })</h4><p>作用：定义环境变量。</p>
<pre><code>plugins: [
  new webpack.DefinePlugin({
    DEV: JSON.stringify(&quot;development&quot;),
    PRO: JSON.stringify(&quot;production&quot;)
  })
]
</code></pre><h4 id="webpacfk-IgnorePlugin"><a href="#webpacfk-IgnorePlugin" class="headerlink" title="webpacfk.IgnorePlugin()"></a>webpacfk.IgnorePlugin()</h4><p>作用：忽略模块的引进</p>
<pre><code>plugins: [
  new webpack.IgnorePlugin(/\./locale/, /moment/)
]
</code></pre><p>注：如果直接使用 <strong>DEV: ‘development’</strong> 的话，会把 <strong>DEV</strong> 直接替换为 <strong>引号内部的内容</strong>。如：<strong>console.log(DEV)</strong>，会变成 <strong>console.log(dev)</strong>，最后的结果是 <strong>undefined</strong>。所以，需要通过 <strong>JSON.stringfy()</strong> 进行转化。</p>
<h2 id="模块-module"><a href="#模块-module" class="headerlink" title="模块 module"></a>模块 module</h2><p>模块主要是各种 <strong>loader</strong>，作用：解析各种类型的文件。</p>
<pre><code>module: { 
 rules: [
   {
     test: regx,
     use: [loadName]
   }
 ]
}
</code></pre><h4 id="css-loader-style-loader"><a href="#css-loader-style-loader" class="headerlink" title="css-loader / style-loader"></a>css-loader / style-loader</h4><ul>
<li>css-loader：主要是用于解析在 <strong>css</strong> 文件中通过 <strong>@import</strong> 方式引进其他的 <strong>css</strong> 文件。</li>
<li>style-loader: 主要是用于将 <strong>js</strong> 文件中通过 <strong>require</strong> 方式引进的 <strong>css</strong> 文件插入到目标 <strong>html</strong> 文件的 <strong>head</strong> 中（插到最后，层级最高）。</li>
</ul>
<pre><code>// 数组方式
module: { // 模块
  rules: [{
    test: /\.css$/, // 正则
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;] // loader 数组
  }]
}
// 对象方式
module: { // 模块
  rules: [{
    test: /\.css$/, // 正则
    use: [
      {
        loader: &quot;style-loader&quot;,
        options: {
          insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级
        }
      }, 
      &quot;css-loader&quot;
    ]
  }]
}
</code></pre><p>注：<strong>loader</strong> 是从右向左、从下到上的执行顺序，故：<strong>use: [“style-loader”, “css-loader”]</strong></p>
<h4 id="postcss-loader-autoprefixer"><a href="#postcss-loader-autoprefixer" class="headerlink" title="postcss-loader + autoprefixer"></a>postcss-loader + autoprefixer</h4><p>这两个的配合使用可以自动添加 <strong>css</strong> 的浏览器前缀。</p>
<ul>
<li>autoprefixer：自动添加 <strong>css</strong> 的浏览器前缀。</li>
<li>postcss-loader：loader 处理 autoprefixer。</li>
</ul>
<pre><code>// 使用 postcss-loader 
module: { // 模块
  rules: [{
    test: /\.css$/,
    use: [
      // {
      //   loader: &quot;style-loader&quot;,
      //   options: {
      //     insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级
      //   }
      // },
      MiniCssExtractPlugin.loader,
      &quot;css-loader&quot;,
      &quot;postcss-loader&quot; // 注意顺序
    ]
  }]
}
</code></pre><ul>
<li>根目录下新建 postcss.config.js 文件</li>
</ul>
<pre><code>module.exports = {
  plugins: [
    require(&quot;autoprefixer&quot;)
  ]
}
</code></pre><h4 id="babel-loader-babel-core-babel-preset-env"><a href="#babel-loader-babel-core-babel-preset-env" class="headerlink" title="babel-loader + @babel/core + @babel/preset-env"></a>babel-loader + @babel/core + @babel/preset-env</h4><p>作用：转化 es6 语法</p>
<pre><code>module: { // 模块
  rules: [{
    test: /\.js$/,
    use: {
      loader: &quot;babel-loader&quot;,
      options: { // 用 babel-loader 需要把 es6 转化为 es5
        presets: [
          &quot;@babel/preset-env&quot;, // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块
        ],
        // plugins: [...] // 其他的小插件
      }
    }
  }]
}
</code></pre><h4 id="expose-loader"><a href="#expose-loader" class="headerlink" title="expose-loader"></a>expose-loader</h4><p>作用：暴露全局的 <strong>loader</strong>，暴露到 <strong>window</strong> 上。</p>
<pre><code>// 一般情况
import $ from &#39;jquery&#39;;
console.log(window.$); // undefined
// 内联 loader 方式
import $ from &#39;expose-loader?$!jquery&#39;;
console.log(window.$);
// 其他方式：在每个模块中注入
new webpack.ProvidePlugin({
  $: &quot;jquery&quot;
})
console.log($);
console.log(window.$); // undefined
</code></pre><h4 id="file-loader-amp-amp-url-loader-amp-amp-html-withimg-loader"><a href="#file-loader-amp-amp-url-loader-amp-amp-html-withimg-loader" class="headerlink" title="file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader"></a>file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader</h4><p>在 <strong>webpack</strong> 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。</p>
<ul>
<li>file-loader：<strong>js</strong> 文件中通过 <strong>import</strong> 方式引进图片。</li>
<li>html-withimg-loader：<strong>html</strong> 文件中通过 <strong>scr</strong> 方式引进图片。</li>
<li>在 <strong>css</strong> 中使用图片，<strong>style-loader</strong> 已经做了处理。</li>
<li>url-loader：将图片转化为 <strong>base64</strong></li>
</ul>
<pre><code>module: {
  rules: [
    {
      test: /\.(png|jpg|gif)$/,
      use: {
        loader: &quot;url-loader&quot;,
        options: {
          limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader
          // publicPath: &quot;http://&quot;, // 公共路径前缀
        }
      }
    },
    {
      test: /\.html$/,
      use: [&quot;html-withimg-loader&quot;]
    }
  ]
}
</code></pre><p>`</p>
<h2 id="模块-module-–-noParse"><a href="#模块-module-–-noParse" class="headerlink" title="模块 module – noParse"></a>模块 module – noParse</h2><p>作用：不解析指定包的依赖关系。</p>
<pre><code>module: {
  noParse: /jquery/
}
</code></pre><h2 id="模块-module-–-exclude"><a href="#模块-module-–-exclude" class="headerlink" title="模块 module – exclude"></a>模块 module – exclude</h2><p>作用：排除</p>
<pre><code>module: {
  exclude: /node_module/
}
</code></pre><h2 id="模块-module-–-include"><a href="#模块-module-–-include" class="headerlink" title="模块 module – include"></a>模块 module – include</h2><p>作用：包含</p>
<pre><code>module: {
  include: /src/
}
</code></pre><h2 id="区分不同环境，实现开发和生产配置的分离"><a href="#区分不同环境，实现开发和生产配置的分离" class="headerlink" title="区分不同环境，实现开发和生产配置的分离"></a>区分不同环境，实现开发和生产配置的分离</h2><p>将 <strong>webpack</strong> 的配置文件划分为以下文件：</p>
<ul>
<li>webpack.base.js：基本、共有的配置。</li>
<li>webpack.dev.js：开发配置。</li>
<li>webpack.prod.js：生产配置。</li>
</ul>
<p>使用 <strong>webpack-merger</strong> 插件：</p>
<ul>
<li>安装 <strong>webpack-merge</strong> 插件；</li>
<li>引进目标模块</li>
</ul>
<pre><code>import { smart } from &quot;webpack-merge&quot;;
</code></pre><ul>
<li>使用</li>
</ul>
<pre><code>const base = require(&quot;webpack.base.js);

module.exports = smart(base, {
  ...
})
</code></pre><h2 id="webpack-自带优化"><a href="#webpack-自带优化" class="headerlink" title="webpack 自带优化"></a>webpack 自带优化</h2><ul>
<li><strong>import</strong> 语法（生成环境），<strong>tree-shaking</strong> 自动删除没有用到的代码；</li>
<li><strong>es6</strong> 模块会把语法放到 <strong>default</strong> 上；</li>
<li>自动省略可以简化的代码；</li>
<li><strong>scope hosting</strong>，作用域提升。</li>
</ul>
<h2 id="webpack-懒加载"><a href="#webpack-懒加载" class="headerlink" title="webpack 懒加载"></a>webpack 懒加载</h2><ul>
<li>通过 <strong>import</strong> 实现（该语法内部由 <strong>jsonp</strong> 实现），返回的是一个 <strong>promise</strong>。</li>
<li>要在 <strong>babel-loader</strong> 中添加 <strong>@babel/plugin-syntax-dynamic-import</strong> 插件。</li>
<li><strong>vue</strong> 和 <strong>react</strong> 的l懒加载都是这样实现的。</li>
</ul>
<pre><code>/*
* 模拟点击加载 source.js 的内容
*/
// 1
{
  loader: &#39;babel-loader&#39;,
  options: {
    presets: [
      &#39;@babel/preset-env&#39;
    ],
    plugins: [
      &#39;@babel/plugin-syntax-dynamic-import&#39;
    ]
  },
}
// 2
let btn = document.createElement(&#39;button&#39;);
btn.innerHTML = &#39;btn&#39;;
btn.addEventListener(&#39;click&#39;, function () {
  // 内部由 jsonp 实现动态加载文件
  import(&#39;./source.js&#39;)
    .then(data =&gt; {
      console.log(data);
    })
})
document.body.appendChild(btn);

</code></pre><p>点击按钮后结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-fa79ce43578285a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="热更新-热替换-Hot-Module-Replacement-HMR"><a href="#热更新-热替换-Hot-Module-Replacement-HMR" class="headerlink" title="热更新 / 热替换 / Hot Module Replacement / HMR"></a>热更新 / 热替换 / Hot Module Replacement / HMR</h2><p>热更新：页面只更新改动的模块。</p>
<ul>
<li><strong>devServer</strong> 开始 <strong>hot</strong> 热更新模块。</li>
<li>使用 <strong>webpack</strong> 内置热更新插件。<ul>
<li>NamedModulesPlugin</li>
<li>HotModuleReplacementPlugin</li>
</ul>
</li>
</ul>
<pre><code>// devServer 配置
devServer: {
  port: 8089,
  contentBase: path.resolve(__dirname + &#39;/dist/&#39;),
  compress: true,
  progress: true,
  // open: true
  hot: true, // 开启热更新，只更新更改的模块
},
// 添加插件
plugins: [
  new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径
  new webpack.HotModuleReplacementPlugin(), // 热更新
]
</code></pre><ul>
<li>使用热更新</li>
</ul>
<pre><code>import source from &#39;./source.js&#39;;

console.log(source);

// 添加热更新操作，不然不会实现热更新
if (module.hot) {
module.hot.accept(&#39;./source.js&#39;, () =&gt; {
  require(&#39;./source.js&#39;);
})
</code></pre><h2 id="多线程打包"><a href="#多线程打包" class="headerlink" title="多线程打包"></a>多线程打包</h2><p>使用 <strong>happypack</strong> 可以实现多线程打包。</p>
<ul>
<li>安装并引进 <strong>happypack</strong>;</li>
<li>改写 <strong>module</strong>;</li>
<li><strong>plugin</strong> 配置。</li>
</ul>
<pre><code>// 改写 module
module: {
  rules: [
    {
      test: /\.js$/,
      // use: {
      //   loader: &#39;babel-loader&#39;,
      //   options: {
      //     presets: [
      //       &#39;@babel/preset-env&#39;
      //     ]
      //   }
      // }
      use: {
        loader: &#39;Happypack/loader?id=js&#39;,
      }
    },
  ]
}
// plugin 配置
plugins: [
  new Happypack({
    id: &#39;js&#39;,
    use: [
      {
        loader: &#39;babel-loader&#39;,
        options: {
          presets: [
            &#39;@babel/preset-env&#39;
          ]
        }
      }
    ]
  }),
]
</code></pre><h2 id="多页面打包"><a href="#多页面打包" class="headerlink" title="多页面打包"></a>多页面打包</h2><pre><code>const path = require(&quot;path&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

module.exports = {
  mode: &quot;production&quot;,
  entry: {
    home: &quot;./src/home.js&quot;,
    about: &quot;./src/about.js&quot;,
    other: &quot;./src/other.js&quot;
  },
  output: {
    path: path.resolve(__dirname + &quot;/build/&quot;),
    filename: &quot;[name].js&quot;,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname + &quot;/src/template.html&quot;),
      filename: &quot;home.html&quot;,
      chunks: [&quot;home&quot;]
    }),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname + &quot;/src/template.html&quot;),
      filename: &quot;other.html&quot;,
      chunks: [&quot;other&quot;]
    }),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname + &quot;/src/template.html&quot;),
      filename: &quot;about.html&quot;,
      chunks: [&quot;about&quot;]
    }),
  ]
}
</code></pre><h2 id="多页面打包抽离公共代码块"><a href="#多页面打包抽离公共代码块" class="headerlink" title="多页面打包抽离公共代码块"></a>多页面打包抽离公共代码块</h2><p>打包 <strong>多页面</strong> 需要将公共的代码块抽离出来进行优化：</p>
<pre><code>optimation: {
  splitChunks: {  // 分割代码块
    cacheGroups: {  // 缓存组
      common: {  // 公共的模块
        chunks: &#39;initial&#39;,  // 从哪里开始，initial 即：入口
        miniSize: 0,  // 大小大于多少字节的时候抽离
        miniChunks: 2  // 引用多少次的时候抽离
      },
      vender: {  // 第三方模块
        priority: 1,  // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用
        test: /node_modules/,  // 抽离出来
        chunks: &#39;initial&#39;,  // 从哪里开始，initial 即：入口
        miniSize: 0,  // 大小大于多少字节的时候抽离
        miniChunks: 2  // 引用多少次的时候抽离
      }
    }
  }
}
</code></pre><h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><p><strong>webpack</strong> 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 <strong>Tapable</strong>，通过 <strong>Tapable</strong> 实现各种钩子（如同步钩子异步钩子）。而 <strong>Tapable</strong> 核心是依赖于 <strong>发布订阅者模式</strong>。</p>
<ul>
<li>同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 <strong>tap</strong> 注册。</li>
</ul>
<p>使用：</p>
<pre><code>const { SyncHook } = require(&#39;tapable&#39;);

class Hook {
  constructor() {
    this.hooks = {
      arch: new SyncHook([&#39;name&#39;])
    }
  }
  tap() { // 注册监听事件
    this.hooks.arch.tap(&#39;vue&#39;, (name) =&gt; {
      console.log(&#39;vue&#39;, name);
    })
    this.hooks.arch.tap(&#39;react&#39;, (name) =&gt; {
      console.log(&#39;react&#39;, name);
    })
  }
  start() { // 开始
    this.hooks.arch.call(&#39;Ertsul&#39;)
  }
}
let h = new Hook();
h.tap();
h.start();
</code></pre><ul>
<li>异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 <strong>tapAsync</strong> 注册。</li>
</ul>
<p>setTimeout()方式使用：</p>
<pre><code>const { AsyncParallelHook } = require(&#39;tapable&#39;);

class AsyncHook {
  constructor() {
    this.hooks = {
      arch: new AsyncParallelHook([&#39;name&#39;])
    }
  }
  tap() {
    this.hooks.arch.tapAsync(&#39;vue&#39;, (name, cb) =&gt; {
      setTimeout(() =&gt; {
        console.log(&#39;vue&#39;, name);
        cb &amp;&amp; cb();
      }, 1000)
    })
    this.hooks.arch.tapAsync(&#39;react&#39;, (name, cb) =&gt; {
      setTimeout(() =&gt; {
        console.log(&#39;react&#39;, name);
        cb &amp;&amp; cb();
      }, 1000)
    })
  }
  start() {
    this.hooks.arch.callAsync(&#39;Ertsul&#39;, () =&gt; {
      console.log(&#39;All finished!&#39;);
    })
  }
}

const a = new AsyncHook();
a.tap();
a.start();
</code></pre><p>Promise()方式使用：</p>
<pre><code>const { AsyncParallelHook } = require(&#39;tapable&#39;);

class AsyncHook {
  constructor() {
    this.hooks = {
      arch: new AsyncParallelHook([&#39;name&#39;])
    }
  }
  tap() {
    this.hooks.arch.tapPromise(&#39;vue&#39;, (name) =&gt; {
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          console.log(&#39;vue&#39;, name);
          resolve();
        }, 1000)
      })
    })
    this.hooks.arch.tapPromise(&#39;react&#39;, (name) =&gt; {
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          console.log(&#39;react&#39;, name);
          resolve();
        }, 1000)
      })
    })
  }
  start() {
    this.hooks.arch.promise(&#39;Ertsul&#39;).then(() =&gt; {
      console.log(&#39;hook all finished!&#39;);
    })
  }
}

const a = new AsyncHook();
a.tap();
a.start();
</code></pre><h4 id="Synchook-同步钩子"><a href="#Synchook-同步钩子" class="headerlink" title="Synchook 同步钩子"></a>Synchook 同步钩子</h4><p>实现：</p>
<pre><code>class Synchook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tap(name, task) { //  注册事件
    this.tasks.push(task);
  }
  call(...args) { // 发布事件
    this.tasks.forEach(task =&gt; {
      task(...args);
    })
  }
}

let hook = new Synchook([&#39;Synchook&#39;]);
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
})
hook.tap(&#39;react&#39;, (name) =&gt; {
  console.log(&#39;react&#39;, name);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-1d12026d2f938c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="SyncBailHook-同步熔断钩子"><a href="#SyncBailHook-同步熔断钩子" class="headerlink" title="SyncBailHook 同步熔断钩子"></a>SyncBailHook 同步熔断钩子</h4><p>Synchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。</p>
<p>实现：</p>
<pre><code>// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数
class Syncbailhook {
  constructor(args) {
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    let ret = &#39;&#39;; // 当前函数的返回值
    let index = 0; // 当前任务数组的索引
    do {
      ret = this.tasks[index++](...args);
    } while (ret === undefined &amp;&amp; index &lt; this.tasks.length)
  }
}

let hook = new Syncbailhook([&#39;Syncbailhook&#39;]);
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
})
hook.tap(&#39;react&#39;, (name) =&gt; {
  console.log(&#39;react&#39;, name);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-3a46a477c8b08d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="SyncWaterfallHook-同步瀑布钩子"><a href="#SyncWaterfallHook-同步瀑布钩子" class="headerlink" title="SyncWaterfallHook 同步瀑布钩子"></a>SyncWaterfallHook 同步瀑布钩子</h4><p>Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。</p>
<p>实现：</p>
<pre><code>/**
 * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系
 * 上一个函数的执行返回结果在当前函数的输入
 */
class Syncwaterfallhook {
  constructor(args) {
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    let [first, ...others] = this.tasks;
    let ret = first(...args);
    others.reduce((prev, current) =&gt; {
      return current(prev);
    }, ret)
  }
}

let hook = new Syncwaterfallhook([&#39;Syncwaterfallhook&#39;]);
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
  return &#39;vue learnt&#39;;
})
hook.tap(&#39;react&#39;, (data) =&gt; {
  console.log(&#39;react&#39;, data);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-5ccbc856cac523cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="SyncLoopHook-同步循环钩子"><a href="#SyncLoopHook-同步循环钩子" class="headerlink" title="SyncLoopHook 同步循环钩子"></a>SyncLoopHook 同步循环钩子</h4><p>同步循环钩子回让某个函数执行一定的次数。</p>
<p>实现：</p>
<pre><code>// Tapable Syncloophook 同步循环钩子
class Syncloophook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tap(name, task) { //  注册事件
    this.tasks.push(task);
  }
  call(...args) { // 发布事件
    this.tasks.forEach(task =&gt; {
      let ret = &#39;&#39;;
      do {
        ret = task(...args);
      } while (ret != undefined);
    })
  }
}

let hook = new Syncloophook([&#39;Syncloophook&#39;]);
const total = 3;
let index = 0;
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
  return ++index === total ? undefined : &#39;continue&#39;;
})
hook.tap(&#39;react&#39;, (name) =&gt; {
  console.log(&#39;react&#39;, name);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-fd5d933715541d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="AsyncParallelHook-异步并发钩子-回调函数方式"><a href="#AsyncParallelHook-异步并发钩子-回调函数方式" class="headerlink" title="AsyncParallelHook 异步并发钩子 回调函数方式"></a>AsyncParallelHook 异步并发钩子 回调函数方式</h4><p>实现：</p>
<pre><code>// Tapable Asynchook 异步钩子
class asyncparallelhook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tapAsync(name, task) { //  注册事件
    this.tasks.push(task);
  }
  callAsync(...args) { // 发布事件
    let finalCallback = args.pop();
    let index = 0;
    const done = () =&gt; {
      index++;
      if (index === this.tasks.length) {
        finalCallback();
      }
    }
    this.tasks.forEach(task =&gt; {
      task(...args, done);
    })
  }
}

let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]);
hook.tapAsync(&#39;vue&#39;, (name, cb) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#39;vue&#39;, name);
    cb &amp;&amp; cb();
  }, 1000)
})
hook.tapAsync(&#39;react&#39;, (name, cb) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#39;react&#39;, name);
    cb &amp;&amp; cb();
  }, 1000)
})
hook.callAsync(&#39;Ertsul&#39;, () =&gt; {
  console.log(&#39;All hook finished!&#39;);
});
</code></pre><h4 id="AsyncParallelHook-异步并发钩子-Promise方式"><a href="#AsyncParallelHook-异步并发钩子-Promise方式" class="headerlink" title="AsyncParallelHook 异步并发钩子 Promise方式"></a>AsyncParallelHook 异步并发钩子 Promise方式</h4><p>实现：</p>
<pre><code>// Tapable Asynchook 异步钩子
class asyncparallelhook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tapPromise(name, task) { //  注册事件
    this.tasks.push(task);
  }
  promise(...args) { // 发布事件
    let tasks = this.tasks.map(task =&gt; task(...args));
    return Promise.all(tasks);
  }
}

let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]);
hook.tapPromise(&#39;vue&#39;, (name) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#39;vue&#39;, name);
      resolve();
    }, 1000)
  })
})
hook.tapPromise(&#39;react&#39;, (name) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#39;react&#39;, name);
      resolve();
    }, 1000)
  })
})
hook.promise(&#39;Ertsul&#39;).then(() =&gt; {
  console.log(&#39;All hooks finished!&#39;);
})
</code></pre><h4 id="AsyncSeriesHook-异步串行钩子"><a href="#AsyncSeriesHook-异步串行钩子" class="headerlink" title="AsyncSeriesHook 异步串行钩子"></a>AsyncSeriesHook 异步串行钩子</h4><h4 id="AsyncWaterfallHook-异步瀑布流钩子"><a href="#AsyncWaterfallHook-异步瀑布流钩子" class="headerlink" title="AsyncWaterfallHook 异步瀑布流钩子"></a>AsyncWaterfallHook 异步瀑布流钩子</h4>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
