<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>广度优先搜索 BFS 和深度优先搜索 DFS</title>
    <url>/2019/12/14/%E5%B9%BF%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-BFS-%E5%92%8C%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E6%90%9C%E7%B4%A2-DFS/</url>
    <content><![CDATA[<p>最近在写 <code>virtual dom</code> 方面的逻辑，用到 <code>BFS</code> 和 <code>DFS</code>。总结一波~😀</p>
<p><code>Virtual Dom</code> 的示例 <code>json</code> 如下：</p>
<pre><code class="javascript">const vNode = {
  node: &quot;root&quot;,
  child: [
    {
      node: &quot;element1&quot;,
      chlid: [
        {
          node: &quot;element3&quot;
        },
        {
          node: &quot;element4&quot;
        }
      ]
    },
    {
      node: &quot;element2&quot;
    }
  ]
};

</code></pre>
<p><code>Virtual Dom</code> 的树如下：</p>
<p><img src="https://i.loli.net/2019/12/13/Li2XeM8a46u3jZV.png" alt="image.png"></p>
<h3 id="广度优先搜索-BFS"><a href="#广度优先搜索-BFS" class="headerlink" title="广度优先搜索  BFS"></a>广度优先搜索  BFS</h3><p><code>BFS</code> ：逐层访问节点，从左到右访问完成一层访问后，访问下一层，且每个节点只访问一次。</p>
<p>上面的树用 <code>BFS</code> 顺序就是：<code>root</code> -&gt; <code>element1</code> -&gt; <code>element2</code> -&gt; <code>element3</code> -&gt; <code>element4</code>。</p>
<p>实现思路：</p>
<ul>
<li>设置队列 <code>queue</code>，就将<strong>根节点</strong>添加到队列 <code>queue</code>；</li>
<li>判断当队列 <code>queue</code> 是否为空，不为空则弹出队头节点 <code>currentNode</code>；</li>
<li>将队头节点 <code>currentNode</code> 添加到结果队列 <code>lists</code>；</li>
<li>判断队头节点 <code>currentNode</code> 是否有子节点，有则将子节点<strong>从左到右</strong>依次添加到队列 <code>queue</code>；</li>
<li>重复步骤2~4。</li>
</ul>
<p>简单理解就是：</p>
<ul>
<li>根节点进队列；</li>
<li>判断队头节点是否子节点，有则将子节点<strong>从左到右</strong>依次进队列，队头节点出队列。</li>
<li>重复2。</li>
</ul>
<p>用 <code>js</code> 代码实现如下：（注意：判断条件为队列长度）</p>
<pre><code class="javascript">/**
 * BFS 非递归写法
 * @param {*} root 根节点
 */
const BFS = root =&gt; {
  if (Object.prototype.toString.call(root) != &#39;[object Object]&#39;) {
    throw(new Error(&#39;root 类型错误！&#39;));
    return;
  }
  let resLists = []; // 存放 BFS 节点队列
  if (!Object.keys(root).length) {
    return lists;
  }
  let queue = []; // 临时队列，每遇到一个节点就存放进队列
  queue.unshift(root);
  while (queue.length) {
    // queue 队列不为空，遍历临时队列
    let currentNode = queue.pop(); // 弹出临时队列的一个节点
    const hasChild =
      currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点
    if (hasChild) {
      const childrenNodes = currentNode.child; // 子节点数组
      for (let i = 0, len = childrenNodes.length; i &lt; len; i++) {
        const currentChildNode = childrenNodes[i]; // 当前子节点
        queue.unshift(currentChildNode); // 添加到队列
      }
    }
    resLists.push(currentNode); // 当前节点存放到 BFS 节点队列
  }
  return resLists;
};
</code></pre>
<p>结果如下：</p>
<p><img src="https://i.loli.net/2019/12/13/fQRoxlaeU1mXEku.png" alt="image.png"></p>
<h3 id="深度优先搜索-DFS"><a href="#深度优先搜索-DFS" class="headerlink" title="深度优先搜索  DFS"></a>深度优先搜索  DFS</h3><p> <code>DFS</code>：对每一个可能的分支路径深入到不能再深入为止，且每个节点只访问一次。</p>
<p>上面的树用 <code>BFS</code> 顺序就是：<code>root</code>  -&gt; <code>element1</code> -&gt; <code>element3</code> -&gt; <code>element4</code> -&gt; <code>element2</code>。</p>
<p>实现思路1（非递归）:</p>
<ul>
<li>根节点进栈 <code>stack</code>；</li>
<li>判断栈 <code>stack</code> 是否为空，判断栈顶元素是否有有子节点，有则将栈顶元素的子节点<strong>从右到左</strong>依次进栈；</li>
<li>弹出栈顶元素，存进 <code>lists</code>;</li>
<li>重复2~3；</li>
</ul>
<p>简单理解就是：</p>
<ul>
<li>根节点进栈；</li>
<li>弹出栈顶元素，判断栈顶元素是否子节点，有则将子节点<strong>从右到左</strong>依次进栈；</li>
<li>重复2。</li>
</ul>
<p>代码如下：（注意：判断条件为栈长度）</p>
<pre><code class="javascript">const DFS = root =&gt; {
  if (Object.prototype.toString.call(root) != &quot;[object Object]&quot;) {
    throw new Error(&quot;root 类型错误！&quot;);
  }
  let resLists = []; // 存放 BFS 节点队列
  if (!Object.keys(root).length) {
    return lists;
  }
  let stack = []; // 栈，每遇到一个节点就存放进栈
  stack.push(root);
  while (stack.length) {
    let currentNode = stack.pop(); // 弹出栈顶元素
    const hasChild =
      currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点
    if (hasChild) {
      const childrenNodes = currentNode.child; // 子节点数组
      for (let i = childrenNodes.length - 1; i &gt;= 0; i--) {
        const currentChildNode = childrenNodes[i]; // 当前子节点
        stack.push(currentChildNode); // 添加到队列
      }
    }
    resLists.push(currentNode); // 当前节点存放到 DFS 结果列表
  }
  return resLists;
};
</code></pre>
<p>实现思路2（递归）：</p>
<ul>
<li>当前节点入栈 <code>stack</code>；</li>
<li>判断当前节点是否有子节点；</li>
<li>有子节点：<ul>
<li>将子节点从右到左依次进行递归；（栈是先进后出 ）</li>
<li>所有子节点递归结束，当前节点出栈；</li>
</ul>
</li>
<li>无：<ul>
<li>当前节点出栈。</li>
</ul>
</li>
</ul>
<p>代码实现如下：（注意：判断关键为节点是否有子节点）</p>
<pre><code class="javascript">var stack = []; // 栈
var lists = []; // 存放 DFS 节点
/**
 * 全局变量实现
 * @param {*} currentNode : 当前节点
 */
const DFS = currentNode =&gt; {
  let hasChild =
    currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点

  stack.push(currentNode); // 推入栈
  if (hasChild) {
    let len = currentNode.child.length;
    for (let i = len - 1; i &gt;= 0; i--) {
      const currentChildNode = currentNode.child[i]; // 当前子节点
      DFS(currentChildNode); // 递归
    }
    lists.unshift(stack.pop()); // 出栈
  } else {
    lists.unshift(stack.pop()); // 出栈
  }
};
</code></pre>
<pre><code class="javascript">/**
 * 非全局变量方式实现
 * @param {*} currentNode : 当前节点
 * @param {*} cache : 缓存栈和节点
 */
const DFS = (currentNode = {}, cache = { lists: [], stack: [] }) =&gt; {
  if (Object.prototype.toString.call(currentNode) != &quot;[object Object]&quot;) {
    throw new Error(&quot;root 类型错误！&quot;);
  }
  let hasChild =
    currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点

  let { lists, stack } = cache;

  stack.push(currentNode); // 推入栈
  if (hasChild) {
    let len = currentNode.child.length;
    for (let i = len - 1; i &gt;= 0; i--) { // 注意这里要从右向左循环，因为 stack 是先进后出
      const currentChildNode = currentNode.child[i]; // 当前子节点
      const {
        lists: newLists,
        stack: newStack
      } = DFS(currentChildNode, {
        lists,
        stack
      }); // 递归
      lists = newLists; // 更新 lists
      stack = newStack; // 更新栈
    }
    lists.unshift(stack.pop()); // 出栈
  } else {
    lists.unshift(stack.pop()); // 出栈
  }
  // 函数返回结果，如果栈中还有节点，证明还没回溯完成，则返回缓存；否则函数执行结束
  const res = stack.length
    ? {
        lists: lists,
        stack: stack
      }
    : lists;
  return res;
};
</code></pre>
<p>结果如下：</p>
<p><img src="https://i.loli.net/2019/12/13/WoE4fxkBRCs3NOd.png" alt="image.png"></p>
]]></content>
      <tags>
        <tag>算法</tag>
      </tags>
  </entry>
  <entry>
    <title>小程序工程化</title>
    <url>/2019/11/05/%E5%B0%8F%E7%A8%8B%E5%BA%8F%E5%B7%A5%E7%A8%8B%E5%8C%96/</url>
    <content><![CDATA[<h2 id="gulp"><a href="#gulp" class="headerlink" title="gulp"></a><em>gulp</em></h2><p><a href="https://www.gulpjs.com.cn/" target="_blank" rel="noopener">👉官方文档传送门</a></p>
<h2 id="gulp-编译项目"><a href="#gulp-编译项目" class="headerlink" title="gulp 编译项目"></a><em>gulp</em> 编译项目</h2><p>日常进行小程序开发，遇到的问题有：</p>
<ul>
<li>如果在微信开发者工具进行开发的话，效率低；</li>
<li>不支持 <em>less</em> css预编译器 ；</li>
<li><em>autoprefixer</em> ；</li>
<li>…</li>
</ul>
<p>考虑到小程序是多页面应用，我们只要在 <em>src</em> 目录添加小程序初始化时所需要的相关配置文件，然后通过 <em>gulp</em> 将 <em>src</em> 下的代码搬移到 <em>dist</em> 打包目录即可。</p>
<h3 id="项目结构"><a href="#项目结构" class="headerlink" title="项目结构"></a>项目结构</h3><pre><code>└───gulpTask 目录：主要存放 gulp 代码逻辑
|     └───baseConfig.js // gulp 路径和 blob 配置信息
|     └───clean.js // 清理 dist nodejs 脚本文件
|     └───taskControler.js // gulp 任务定义
|───src
|     └───common // 公共代码
|         └───less
|             └───...
|         └───js
|             └───...
|     └───components // 组件
|             └───...
|     └───pages // 页面
|             └───...
|     └───router // 路由
|             └───router.js // 路由处理逻辑
|             └───routerPath.js // 路由表
|     └───api // 请求数据接口统一处理
|             └───api.js
|     └───http // http 网络请求
|             └───baseConfig.js // 基本配置
|             └───devConfig.js // 开发基本配置
|             └───prodConfig.js // 生产基本配置
|             └───request.js // 请求处理逻辑
|    └───app.js
|    └───app.json
|    └───project.config.json
|    └───sitemap.json
└───.eslintrc // eslint 配置
└───.gitignore // git 配置
└───gulpfile.js // gulp 主入口
└───package.json
└───README.md
</code></pre><h3 id="gulp-配置文件-baseConfig-js"><a href="#gulp-配置文件-baseConfig-js" class="headerlink" title="gulp 配置文件 baseConfig.js"></a><em>gulp</em> 配置文件 <em>baseConfig.js</em></h3><p>将 <em>gulp</em> 相关路径和 <em>blob</em> 配置信息统一在 <em>baseConfig.js</em> 中进行配置。</p>
<pre><code class="javascript">const path = require(&quot;path&quot;);

const srcPath = path.resolve(__dirname, &quot;../src&quot;);
const distPath = path.resolve(__dirname, &quot;../dist&quot;);
const isDev = process.argv.includes(&quot;--development&quot;);

module.exports = {
  isDev, // 当前环境
  srcPath, // src 源路径
  distPath, // dist 编译目标路径
  basePath: [
    srcPath
  ],
  otherPath: [
    srcPath,
    `!${srcPath}/**/**/*.less`,
    `!${srcPath}/**/**/*.wxml`,
    `!${srcPath}/**/**/*.json`,
    `!${srcPath}/**/**/*.js`,
    `!${srcPath}/static/icons/*.jpg`,
    `!${srcPath}/static/icons/*.png`,
    `!${srcPath}/static/images/*.jpg`,
    `!${srcPath}/static/images/*.png`,
  ],
  lessPath: [ // less blob
    `${srcPath}/**/**/*.less`,
  ],
  jsPath: [ // js blob
    `${srcPath}/**/**/*.js`,
  ],
  wxmlPath: [ // wxml blob
    `${srcPath}/**/**/*.wxml`,
  ],
  jsonPath: [ // json blob
    `${srcPath}/**/**/*.json`,
  ],
  lessImportPath: [
    `${srcPath}/common/less/*.less`
  ],
  iconPath: [
    `${srcPath}/static/icons/*.jpg`,
    `${srcPath}/static/icons/*.png`
  ],
  imagePath: [
    `${srcPath}/static/images/*.jpg`,
    `${srcPath}/static/images/*.gif`,
    `${srcPath}/static/images/*.png`
  ]
}
</code></pre>
<h3 id="gulp-开发流程"><a href="#gulp-开发流程" class="headerlink" title="gulp 开发流程"></a><em>gulp</em> 开发流程</h3><p>主要流程如下：</p>
<p><img src="https://i.loli.net/2019/11/05/yxatp6HzRUAm9G4.png" alt="image-20191105174239088.png"></p>
<h4 id="gulp-的各个任务：（taskControler-js-文件）"><a href="#gulp-的各个任务：（taskControler-js-文件）" class="headerlink" title="gulp 的各个任务：（taskControler.js 文件）"></a><em>gulp</em> 的各个任务：（<em>taskControler.js</em> 文件）</h4><ul>
<li><p>每次进行 <em>gulp</em> 任务前都要清空 <em>dist</em> 打包后的目录。主要代码如下：</p>
<pre><code class="javascript">task(&quot;clean:dist&quot;, done =&gt; {
    // console.log(&quot;:::: clean:dist&quot;);

    src(baseConfig.distPath, {
        read: true,
        allowEmpty: true,
    })
        .pipe(clean())

    done();
})
</code></pre>
<p>但是，上面这样处理会有问题：第二次运行 <em>gulp</em> 命名的时候会有文件权限等问题。故：<em>dist</em> 文件的处理通过 <em>nodejs</em> 进行处理。</p>
<pre><code class="javascript">// gulp-clean 清空 dist 命令会有权限等一系列问题，故：直接用 node 进行删除 dist
const path = require(&quot;path&quot;);
const chalk = require(&quot;chalk&quot;);
const rimraf = require(&quot;rimraf&quot;);

const distPath = path.resolve(__dirname, &#39;../dist&#39;);
rimraf(distPath, err =&gt; {
  if (err) {
    console.log(chalk.red(err));
  }
})
</code></pre>
<p>然后在 <em>package.json</em> 中配置脚本命令：</p>
<pre><code class="json">&quot;scripts&quot;: {
    &quot;build:dev&quot;: &quot;node gulpTask/clean.js &amp;&amp; gulp dev --development&quot;,
    &quot;build:prod&quot;: &quot;node gulpTask/clean.js &amp;&amp; gulp prod --production&quot;
},
</code></pre>
<p>这样每次执行 <em>gulp</em> 命令前都会删除 <em>dist</em> 目录。</p>
</li>
<li><p>处理 <em>less</em> 文件。需要解决的问题有：</p>
<ul>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
<li>自动添加属性前缀，<em>autoperfixer</em>；</li>
<li>将 <em>less</em> 文件的后缀更改为 <em>wxss</em>；</li>
<li>将 <em>less</em> 文件内部的 <em>@import</em> 引用文件的后缀更改为 <em>wxss</em>。</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:less&quot;, done =&gt; {
    // console.log(&quot;:::: compile:less&quot;);

    src(baseConfig.lessPath, {
        base: &quot;src&quot;
    })
        .pipe(changed(baseConfig.distPath))
        .pipe(gulpif(!this.isDev, cleanCss()))
        .pipe(autoprefixer())
    // .pipe(less({
    //   paths: baseConfig.lessImportPath,
    //   plugins: [autoprefix]
    // }))
        .pipe(rename(function (path) { // 更改 .less 文件后缀为 .wxss
        path.extname = &quot;.wxss&quot;;
    }))
        .pipe(replace(/\.less/g, &quot;.wxss&quot;)) // 修改 less 文件内部的引用 .less 文件后缀为 .wxss
        .pipe(dest(baseConfig.distPath));

    done();
})
</code></pre>
<p>这里遇到一个坑，用 l<em>ess-plugin-autoprefix @import</em> 会有问题，<em>@import</em> 语句会被删除。后面改用 <em>gulp-autoprefixer</em>。</p>
</li>
<li><p>处理 <em>js</em> 文件。需要解决的问题有：</p>
<ul>
<li><em>eslint</em> 代码格式检查；</li>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:js&quot;, done =&gt; {
  // console.log(&quot;:::: compile:js&quot;);

  src(baseConfig.jsPath, {
      base: &quot;src&quot;
    })
    .pipe(changed(baseConfig.distPath))
    // .pipe(babel({ // 先通过 babel 转化语法然后才能进行压缩 --&gt; 微信开发者工具有 es6 转 es5 功能
    //   presets: [&quot;@babel/env&quot;]
    // }))
    .pipe(eslint())
    // .pipe(eslint.format())
    .pipe(gulpif(!this.isDev, uglify()))
    .pipe(dest(baseConfig.distPath));

  done();
})
</code></pre>
<p>这里原本加了 <em>babel</em> 进行 <em>es6</em> 到 <em>es5</em> 的转化，但是微信开发者工具本身就有这个功能，故去除。另一个坑是，用 <em>gulp-uglify</em> 不能进行 <em>es6</em> 代码的压缩，要用 <em>gulp-uglify-es</em> 。</p>
</li>
<li><p>处理 <em>wxml</em> 文件。需要解决的问题有：</p>
<ul>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:wxml&quot;, done =&gt; {
  // console.log(&quot;:::: compile:wxml&quot;);

  src(baseConfig.wxmlPath, {
      base: &quot;src&quot;
    })
    .pipe(changed(baseConfig.distPath))
    .pipe(gulpif(!this.isDev, htmlmin({
      collapseWhitespace: true
    })))
    .pipe(dest(baseConfig.distPath));

  done();
})
</code></pre>
</li>
<li><p>处理 <em>json</em> 文件。需要解决的问题有：</p>
<ul>
<li>开发环境不压缩代码，生产环境压缩代码；</li>
</ul>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:json&quot;, done =&gt; {
  // console.log(&quot;:::: compile:json&quot;);

  src(baseConfig.jsonPath, {
      base: &quot;src&quot;
    })
    .pipe(changed(baseConfig.distPath))
    .pipe(gulpif(!this.isDev, prettyData({
      type: &quot;minify&quot;,
      preserveComments: true,
      extensions: {
        &quot;json&quot;: &quot;json&quot;,
      }
    })))
    .pipe(dest(baseConfig.distPath));

  done();
})
</code></pre>
</li>
<li><p>其他所有文件。</p>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;compile:other&quot;, done =&gt; {
      // console.log(&quot;:::: compile:other&quot;);

      src(baseConfig.otherPath, {
          base: &quot;src&quot;
        })
        .pipe(changed(baseConfig.distPath))
        .pipe(dest(baseConfig.distPath));

      done();
    })
</code></pre>
</li>
<li><p>图片压缩。</p>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;minify:image&quot;, async done =&gt; {
  // console.log(&quot;:::: minify:image&quot;);

  src(baseConfig.imagePath, {
      base: &quot;src&quot;
    })
    .pipe(imagemin([imagemin.optipng(), imagemin.gifsicle(), imagemin.jpegtran()]))
    .pipe(dest(baseConfig.distPath))

  done();
})
</code></pre>
</li>
<li><p>开发环境开启监控 <em>watch</em>。</p>
<p>主要代码如下：</p>
<pre><code class="javascript">task(&quot;watch&quot;, done =&gt; {
  // console.log(&quot;:::: compile:other&quot;);

  watch(baseConfig.basePath, {
    base: &quot;src&quot;
  }, series(&quot;compile:less&quot;, &quot;compile:js&quot;, &quot;compile:wxml&quot;, &quot;compile:json&quot;, &quot;compile:other&quot;, &quot;minify:image&quot;))

  done();
})
</code></pre>
</li>
<li><p>最后，将任务进行 <em>id</em> 绑定处理，还有不同环境的区分。主要代码如下：</p>
<pre><code class="javascript">task(&quot;default&quot;, parallel(&quot;compile:less&quot;, &quot;compile:js&quot;, &quot;compile:wxml&quot;, &quot;compile:json&quot;, &quot;compile:other&quot;, &quot;minify:image&quot;));
task(`dev-${id}`, series(&quot;default&quot;, &quot;watch&quot;));
task(`prod-${id}`, series(&quot;default&quot;));
</code></pre>
</li>
</ul>
<h4 id="gulp-入口文件处理：（gulpfile-js-文件）"><a href="#gulp-入口文件处理：（gulpfile-js-文件）" class="headerlink" title="gulp 入口文件处理：（gulpfile.js 文件）"></a><em>gulp</em> 入口文件处理：（<em>gulpfile.js</em> 文件）</h4><p>主要是对不同环境的区分，还有 <em>taskControler.js</em> 定义的各个任务进行引用。主要代码如下：</p>
<pre><code class="javascript">const {
  task,
  series
} = require(&quot;gulp&quot;);
const TaskControler = require(&quot;./gulpTask/taskControler&quot;);
// 项目 ID
const id = require(&quot;./package.json&quot;).name || &quot;min-program&quot;;

new TaskControler(id);

/*---------- 相关的 gulp 任务 ----------*/

// dev 开发环境任务
task(&quot;dev&quot;, series(`dev-${id}`));

// prod 生产环境任务
task(&quot;prod&quot;, series(`prod-${id}`));
</code></pre>
<p>接着，只需要执行 <code>npm run build:dev</code>或 <code>npm run build:prod</code>，然后将生成的 <em>dist</em> 目录丢到微信开发者工具即可。</p>
<h2 id="路由封装"><a href="#路由封装" class="headerlink" title="路由封装"></a>路由封装</h2><ul>
<li><p>路由表文件</p>
<pre><code class="javascript">/**
 * 路由路径
 */
const routerPath = {
  index: &quot;/pages/index/index&quot;,
  detail: &quot;/pages/detail/detail&quot;,
}

module.exports = routerPath;
</code></pre>
</li>
<li><p>路由逻辑处理</p>
<p>最后使用路由的方式为：</p>
<pre><code class="javascript">app.Router.push({
    path: &#39;detail&#39;,
    query: {
        name: &#39;Ertsul&#39;,
        age: 23
    }
})
</code></pre>
<p>需要处理的问题有：路由参数转化为小程序的格式、有参无参路由。</p>
<p>路由参数转化为小程序的格式。</p>
<pre><code class="javascript">/**
 * 处理路由参数，拼接成字符串形式
 * @param {*} queryObj ： 路由参数
 */
function dealQuery(queryObj) {
  let tempArr = [];
  for (let key in queryObj) {
    if (queryObj.hasOwnProperty(key)) {
      const value = queryObj[key];
      const item = `${key}=${value}`;
      tempArr.push(item);
    }
  }
  return &quot;?&quot; + tempArr.join(&quot;&amp;&quot;);
}
</code></pre>
<p>封装一个对象，添加 <em>push</em> 对外暴露的方法，添加内部跳转的方法。</p>
<pre><code class="javascript">let Router = {
  /**
   * 
   * @param {String} param0 : 路径
   * @param {Object} param1 : 参数
   * @param {String} param2 : 类型，redirectTo/reLaunch/back/navigateTo
   */
  push({
    path = &quot;&quot;,
    query = {},
    type = &quot;navigateTo&quot;
  }) {
    if (!path) {
      return;
    }
    // 获取对应的小程序路径
    let url = routerPath[path] || routerPath[&#39;index&#39;];
    let params = &quot;&quot;;
    // 处理 query 
    if (Object.keys(query) &amp;&amp; Object.prototype.toString.call(query) == &#39;[object Object]&#39;) {
      params = dealQuery(query);
    } else {
      console.error(&quot;路由参数类型错误！&quot;);
      return;
    }
    url += params;
    this.to(url, type); // 执行跳转
  },
  /**
   * 
   * @param {*} url : 路径 + 参数
   * @param {*} type : 类型，redirectTo/reLaunch/back/navigateTo
   */
  to(url, type = &quot;&quot;) {
    switch (type) {
      case &quot;redirectTo&quot;:
        wx.redirectTo({
          url
        });
        break;
      case &quot;reLaunch&quot;:
        wx.reLaunch({
          url
        });
        break;
      case &quot;back&quot;:
        wx.navigateBack({
          delta: 1
        });
        break;
      case &quot;navigateTo&quot;:
        wx.navigateTo({
          url
        });
        break;
    }
  }
}
</code></pre>
<p>最后将 <em>Router</em> 对象挂载到 <em>app</em> 对象。</p>
<pre><code class="javascript">const Router = require(&quot;./router/router&quot;);

//app.js
App({
  Router,
  ...
})
</code></pre>
</li>
</ul>
<h2 id="http-封装及其接口统一管理"><a href="#http-封装及其接口统一管理" class="headerlink" title="http 封装及其接口统一管理"></a>http 封装及其接口统一管理</h2><p><em>http</em> 封装，可以添加一些请求公共参数等。核心代码为：</p>
<pre><code class="javascript">function request({
  url = &#39;&#39;,
  data = {},
  method = &#39;POST&#39;,
  header = {
    &#39;content-type&#39;: &#39;application/json&#39; // 默认值
  }
}) {
  return new Promise(async (resolve, reject) =&gt; {
    wx.request({
      url,
      data,
      method,
      header,
      success(res) {
        resolve(res);
      },
      fail(err) {
        reject(err);
      }
    })
  })
}
</code></pre>
<p>接口统一管理。接口统一管理有利于后期维护。</p>
<pre><code class="javascript">const request = require(&#39;../http/request&#39;);
const baseConfig = require(&#39;../http/baseConfig&#39;);

// get 例子
const getList = request({
  method: &#39;GET&#39;,
  url: baseConfig.baseUrl + &#39;/list?page=1&amp;size=10&#39;,
})

// post 例子
const updateInfo = request({
  method: &#39;POST&#39;,
  url: baseConfig.baseUrl + &#39;/updateInfo&#39;,
  data: {
    name: &#39;Ertsul&#39;,
    age: 23
  }
})

module.exports = {
  getList,
  updateInfo
}
</code></pre>
]]></content>
      <categories>
        <category>minapp</category>
      </categories>
      <tags>
        <tag>minapp</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 操作（补充）</title>
    <url>/2019/10/12/Git-%E6%93%8D%E4%BD%9C%EF%BC%88%E8%A1%A5%E5%85%85%EF%BC%89/</url>
    <content><![CDATA[<h2 id="cherry-pick"><a href="#cherry-pick" class="headerlink" title="cherry-pick"></a>cherry-pick</h2><p><em>cherry-pick</em> 可以将分支 <em>B</em> 的任何<strong>一个</strong> <em>commit</em> 合并到分支 <em>A</em>。</p>
<p><strong>情景</strong>：<em>dev</em> 分支有两个 <em>commit</em>，分别是：创建 <em>b.txt</em> 文件 <em>commitB</em>、创建 <em>c.txt</em> 文件 <em>commitC</em>。现在我们只想要合并 <em>commitAB 到 </em>master<em> 分支。下面是 </em>master<em> 和 </em>dev* 两个分支的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-049b7c95c62a3131.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d46ecad032fee3ba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果直接用 <em>git merge</em> 会将 <em>commitC</em> 也合并到 <em>master</em>，这不是我们想要的结果。这时候，<em>cherry-pick</em> 就派上用场了。用法如下：</p>
<ul>
<li>切换到目标分支。</li>
<li><em>cherry-pick</em> 待合并的 <em>commitID</em>。</li>
</ul>
<p>上面的情景，只需要：</p>
<pre><code class="powershell">git checkout master
git cherry-pick 8f2aa26
</code></pre>
<p>结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-4c396adb0bb8588a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>不过，<em>cherry-pick</em> 只能合并单个指定的 <em>commit</em>。☞ <a href="http://git-scm.com/docs/git-cherry-pick" target="_blank" rel="noopener">cherry-pick 更多操作</a></p>
<h2 id="rebase"><a href="#rebase" class="headerlink" title="rebase"></a>rebase</h2><p><em>rebase变基</em> 是 <em>Git</em> 中整合来自不同分支修改的一种操作。（另一种是 <em>merge</em>）</p>
<p><strong>情景1</strong>：<em>dev</em> 分支有两个 <em>commit</em> ，分别是：创建 <em>d.txt</em> 文件 <em>commitD</em>、创建 <em>e.txt</em> 文件 <em>commitE</em>。现在我们想要将 <em>dev</em> 分支的所有 <em>commit</em> 合并到 <em>master</em>。下面是 <em>dev</em> 分支的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-293e36b78fb47d5a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>想要通过 <em>rebase</em> 变基将 <em>commit</em> 合并到 <em>master</em>，只需要：</p>
<ul>
<li>将 <em>dev</em> 分支变基到 <em>master</em> 分支。</li>
<li>切换到 <em>master</em> 分支。</li>
<li>执行 <em>merge</em> 操作。</li>
</ul>
<pre><code class="powershell">git rebase master
git checkout master 
git merge --no-ff dev
</code></pre>
<p>最后结果如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-0417d63fc36aef1f.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1570868576457.png"></p>
<p>通过 <em>rebase</em> 合并分支跟 <em>merge</em> 合并是不一样的。☞ <a href="[http://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA](http://git-scm.com/book/zh/v2/Git-分支-变基">点击查看区别</a>)</p>
<p><strong>情景2</strong>：<em>dev</em> 分支上有四个 <em>commit</em>，顺序分别是：创建 <em>f.txt</em> 文件 <em>commitF</em>、增加 <em>f.txt</em> 文件内容 <em>commitF1</em>、创建 <em>g.txt</em> 文件 <em>commitG</em>、增加 <em>g.txt</em> 文件内容 <em>commitG1</em>。现在只想要将 <em>dev</em> 分支上关于文件 <em>f.txt</em> 的所有操作合并到 <em>master</em> 分支。下面是 <em>dev</em> 分支的情况：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-b9f954b059404b15.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现在只想要将 <em>dev</em> 分支上关于文件 <em>f.txt</em> 的所有操作合并到 <em>master</em> 分支，需要：</p>
<ul>
<li>以 <em>f.txt</em> 的最后一个修改的 <em>commitID</em> 新建一个分支 <em>dev-temp</em>。</li>
<li>将以 <em>dev-temp</em> 分支上关于 <em>f.txt</em> 的第一个修改的 <em>commitID</em> <em>rabase</em> 变基到 <em>master</em> 分支。</li>
<li>切换到 <em>master</em> 分支。</li>
<li><em>merge</em> <em>dev-temp</em> 分支到 <em>master</em> 分支。</li>
</ul>
<pre><code class="powershell">git checkout -b dev-temp 884c858
git rebase --onto master 3b0bfd7^
git checkout master 
git merge --no-ff dev-temp
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-e52de0c710b4437c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><strong>情景3</strong>：<em>dev</em> 分支上有四个 <em>commit</em>，顺序分别是：创建 <em>i.txt</em> 文件 <em>commitI</em>、增加 <em>i.txt</em> 文件内容 <em>commitI1</em>、创建 <em>j.txt</em> 文件 <em>commitJ</em>、增加 <em>j.txt</em> 文件内容 <em>commitJ1</em>。现在只想要将 <em>dev</em> 分支上关于文件 <em>j.txt</em> 的所有操作合并到 <em>master</em> 分支。下面是 <em>dev</em> 分支的情况：（其实跟上面的情况和操作一样）</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-59f2f8f60f66ef93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>现在只想要将 <em>dev</em> 分支上关于文件 <em>j.txt</em> 的所有操作合并到 <em>master</em> 分支，需要：</p>
<ul>
<li>以 <em>j.txt</em> 的最后一个修改的 <em>commitID</em> 新建一个分支 <em>dev-temp1</em>。</li>
<li>将以 <em>dev-temp1</em> 分支上关于 <em>j.txt</em> 的第一个修改的 <em>commitID</em> <em>rabase</em> 变基到 <em>master</em> 分支。</li>
<li>切换到 <em>master</em> 分支。</li>
<li><em>merge</em> <em>dev-temp1</em> 分支到 <em>master</em> 分支。</li>
</ul>
<pre><code class="powershell">git checkout -b dev-temp1 54ea4bd
git rebase --onto master e31249b^
git checkout master 
git merge --no-ff dev-temp1
</code></pre>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-8507dd6818db90d9.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><a href="[http://git-scm.com/book/zh/v2/Git-%E5%88%86%E6%94%AF-%E5%8F%98%E5%9F%BA](http://git-scm.com/book/zh/v2/Git-分支-变基">rebase更多操作</a>)</p>
<h2 id="合并多个-commit-为一个-commit"><a href="#合并多个-commit-为一个-commit" class="headerlink" title="合并多个 commit 为一个 commit"></a>合并多个 commit 为一个 commit</h2><p>合并多个 <em>commit</em> 为一个 <em>commit</em> 同样需要 <em>rebase</em>。</p>
<p>如下图：要将最新的两个 <em>commit</em> 合并为一个 <em>commit</em>。具体操作如下：</p>
<ul>
<li><p>找到这三个 <em>commit</em> 的前一个 <em>commit</em> 的 <em>commitID</em>，执行 <code>git rebase -i commitID</code></p>
</li>
<li><p>这时候会进入 <em>vi</em> 编辑。</p>
<ul>
<li><code>pick</code> 的意思是要会执行这个 <em>commit</em></li>
<li><code>squash</code> 的意思是这个 commit 会被合并到前一个 <em>commit</em></li>
</ul>
</li>
<li><p>之后会进入 <em>vi</em> 编辑 <em>commit</em> 信息。只需要将原先的 <em>commit</em> 信息注释，在顶部添加新的 <em>commit</em> 信息。</p>
</li>
<li><p>完成。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-a8a97ecd1b5c4901.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-5528059b7ca9273d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d173423d001b4e65.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d7e5d016bfa4b80b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-cb502bcc195b4fba.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<h2 id="删除分支"><a href="#删除分支" class="headerlink" title="删除分支"></a>删除分支</h2><p>删除分支包括删除本地分支和远程分支：</p>
<ul>
<li>删除本地分支<ul>
<li>如本地分支不是打开状态，则：<code>git branch -d branchName</code></li>
<li>如本地分支是打开状态，则：<code>git branch -D branchName</code></li>
</ul>
</li>
<li>删除远程分支<ul>
<li><code>git push origin --delete branchName</code></li>
</ul>
</li>
</ul>
<h2 id="恢复分支"><a href="#恢复分支" class="headerlink" title="恢复分支"></a>恢复分支</h2><p>恢复分支，我们只需要以之前分支的 <em>commitID</em> 新开一个分支即可。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-a2e8638e3cc8a3ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>如果不记得 <em>commitID</em>，可以通过 <em>git reflog</em> 进行查看。</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-ba394e5b699ff0f0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="1570871432663.png"></p>
<h2 id="撤销本地修改"><a href="#撤销本地修改" class="headerlink" title="撤销本地修改"></a>撤销本地修改</h2><ul>
<li><p>撤销指定本地文件的修改（未提交状态）：<code>git checkout -- fileName</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-75f7a0a74ac422d1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p>撤销本地的所有修改（未提交状态）：<code>git reset --hard</code></p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-0359a8aee6d9ae94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
</ul>
<h2 id="其他基本操作"><a href="#其他基本操作" class="headerlink" title="其他基本操作"></a>其他基本操作</h2><ul>
<li>生成本地的 <em>key</em>，并添加到远程仓库</li>
</ul>
<pre><code>ssh-keygen -t rsa
</code></pre><ul>
<li>初始化本地目录</li>
</ul>
<pre><code>git init
</code></pre><ul>
<li>添加到本地仓库</li>
</ul>
<pre><code>git add filename
</code></pre><ul>
<li>提交到仓库（<em>git</em> 提交的是修改）</li>
</ul>
<pre><code>git commit -m &quot;description&quot;
</code></pre><ul>
<li>查看仓库状态</li>
</ul>
<pre><code>git status
</code></pre><ul>
<li>查看不同点</li>
</ul>
<pre><code>git diff filename
</code></pre><ul>
<li>版本回退</li>
</ul>
<pre><code>git reset --hard
</code></pre><ul>
<li>第一分支 <em>master</em> 创建分支 <em>v1</em> （<em>HEAD</em> 指向当前分支）</li>
</ul>
<pre><code>// 创建并指向新分支
git checkout -b v1 
// 分步执行
git branch v1
git checkouut v1
</code></pre><ul>
<li>合并到当前分支</li>
</ul>
<pre><code>git merge v1
</code></pre><ul>
<li>删除指定分支</li>
</ul>
<pre><code>git branch -d v1
</code></pre><ul>
<li>指定分支将远程仓库的代码拉到本地</li>
</ul>
<pre><code>git clone gitAddress -b branchName
</code></pre><ul>
<li>将本地的代码提交到远程仓库</li>
</ul>
<pre><code>git pull    //获取最新的更改
git add modefied_filename
git commit -m &quot;description&quot;
git push  // 推送
</code></pre><ul>
<li>冲突解决<br>可以用上面的方法解决就解决，不行的话就用下面的方法：<ul>
<li>用远程仓库的代码完全覆盖本地代码。</li>
</ul>
</li>
</ul>
<pre><code>git reset --hard // 版本回退
git pull

</code></pre><ul>
<li>修改 commit 提交的内容</li>
</ul>
<pre><code>git commit --amend

</code></pre><ul>
<li>打印 log 数量</li>
</ul>
<pre><code>git log -p -3

</code></pre><ul>
<li>文件被添加到暂存区，撤销该文件到工作目录</li>
</ul>
<pre><code>git reset HEAD fliename

</code></pre><ul>
<li>工作目的删除文件后，还有在暂存区中删除该文件</li>
</ul>
<pre><code>rm filename
git rm filename

</code></pre><ul>
<li>撤销对当前文件的修改，恢复到上一次快照的状态</li>
</ul>
<pre><code>git checkout -- filename

</code></pre><ul>
<li><em>HEAD</em> 指针指向当前的分支，提交后都会快进（<em>fast-forward</em> ：指针右移）。</li>
<li><em>rebase</em> 合并分支<br>变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。</li>
</ul>
<pre><code>git checkout dev
......修改......
git add filename
git commit -m &quot;......&quot;
git rebase master
git checkout master
git merge dev

</code></pre>]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>Git 操作</title>
    <url>/2019/10/12/Git-%E6%93%8D%E4%BD%9C/</url>
    <content><![CDATA[<p>想必每个开发者对Git并不陌生，先来看看官方对于Git的定义：</p>
<blockquote>
<p>Git是一个免费和开源的分布式版本控制系统，旨在快速和有效率地处理从大到小的项目。</p>
</blockquote>
<h4 id="安装-Git-和查看-Git-版本"><a href="#安装-Git-和查看-Git-版本" class="headerlink" title="安装 Git 和查看 Git 版本"></a>安装 Git 和查看 Git 版本</h4><ul>
<li>安装（仅说明在 <em>Linux</em> 系统下的安装，若您是windows系统，直接官网下载安装就行~）</li>
</ul>
<pre><code>sudo apt install git
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-1b4d4c825d3e9cf1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>由于我之前已经安装过了，所以这里升级等都是 <em>0</em>。</p>
<ul>
<li>查看是否安装成功</li>
</ul>
<pre><code>git
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-b029bb624636ebb1.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>输入git命令后，出现一系列关于Git的参数和命令等，说明安装成功了。</p>
<ul>
<li>查看 <em>Git</em> 版本</li>
</ul>
<pre><code>git --version
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-d93c79710b9cfdfd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<h4 id="创建-Git-仓库"><a href="#创建-Git-仓库" class="headerlink" title="创建 Git 仓库"></a>创建 Git 仓库</h4><p>所谓 <em>Git</em> 仓库（<em>repository</em>），也叫版本库。简单理解，就是可以被 <em>Git</em> 管理（修改，删除等）的目录。</p>
<ul>
<li>新建本地目录，并切换到新目录</li>
</ul>
<pre><code>mkdir gitFile
cd gitFile
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-86edbf8888ce2c68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>将本地目录初始化为 <em>Git</em> 仓库</li>
</ul>
<pre><code>git init
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-c56d293f662bf4ac.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>查看 <em>Git</em> 仓库的目录</li>
</ul>
<pre><code>ls -al
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-9af646e821d36e81.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br>您会发现，这里多了一个 <em>.git</em> 的目录，作用是 <em>Git</em> 来跟踪管理 <em>Git</em> 仓库的；注意，如果输入的命令是 <em>ls</em> 是不会看到 <em>.git</em>，因为这个目录默认是隐藏的。</p>
<h4 id="将文件放到Git仓库（一定要在-git-init-的目录／子目录下）"><a href="#将文件放到Git仓库（一定要在-git-init-的目录／子目录下）" class="headerlink" title="将文件放到Git仓库（一定要在 git init 的目录／子目录下）"></a>将文件放到Git仓库（一定要在 <em>git init</em> 的目录／子目录下）</h4><ul>
<li>新建 <em>test.txt</em> 文件并输入内容</li>
</ul>
<pre><code>cat &gt; test.txt
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-838f0f3715084789.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>将 <em>test.txt</em> 文件上传到Git仓库</li>
</ul>
<pre><code>git add test.txt 
</code></pre><ul>
<li>告知 <em>Git</em> 仓库提交了新文件，并添加标注信息</li>
</ul>
<pre><code>git commit -m &quot;My first git.&quot;

</code></pre><p><em>-m</em> 后面是 <em>commit</em> 信息。<br>很简单吧～只需要两步，就可以将文件上传到Git仓库。</p>
<ul>
<li>查看 <em>Git</em> 仓库的当前状态</li>
</ul>
<pre><code>git status

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-6e47af6a618c047d.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br>倘若修改了文件，但没有提交，结果是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/659084-0910cc6291dbadfc.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>提交后的结果是这样的：<br><img src="http://upload-images.jianshu.io/upload_images/659084-07671c9d269aa1b8.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>查看文件修改内容<br>如果修改了文件，但还没提交，可以对比文件前后的修改内容。</li>
</ul>
<pre><code>git diff test.txt

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-3373c8bc3a0b6df4.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<p>可知，文件 <em>test.txt</em> 添加了新的一行 <em>This is the third line.</em></p>
<h4 id="创建GitHub账号"><a href="#创建GitHub账号" class="headerlink" title="创建GitHub账号"></a>创建GitHub账号</h4><p>如果没有 <em>GitHub</em> 账号，得先到<a href="https://github.com/" target="_blank" rel="noopener">GitHub</a>官网注册账号。注册登录为常规操作，不多说。</p>
<h4 id="SSH设置"><a href="#SSH设置" class="headerlink" title="SSH设置"></a>SSH设置</h4><p>由于Git和GitHub之间是通过SSH加密传输的，所以需要进行SSH设置。</p>
<ul>
<li>创建SSH Key（用户主目录）</li>
</ul>
<pre><code>ssh-keygen -t rsa -C &quot;你的邮箱&quot;

</code></pre><p>接下来回车默认就好了。</p>
<ul>
<li>在用户主目录下找到 <em>.ssh</em> 目录</li>
</ul>
<pre><code>ls -al | find -name &quot;*.ssh&quot;

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-0d28f60589a3fe46.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<ul>
<li>发现存在 <em>.ssh</em> 目录，切换到 <em>.ssh</em> 目录，发现文件中秘钥有 <em>id_rsa</em>（私钥）和 <em>id_rsa.pub</em>（公钥），其中是 <em>id_rsa.pub</em> 是我们所需要的<br><img src="http://upload-images.jianshu.io/upload_images/659084-b56f8d1860d46e2c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>打开 <em>ip_rsa.pub</em> ，并复制</li>
</ul>
<pre><code>cat ip_rsa.pub

</code></pre><h4 id="在-GitHub-中添加-SSH-Key"><a href="#在-GitHub-中添加-SSH-Key" class="headerlink" title="在 GitHub 中添加 SSH Key"></a>在 <em>GitHub</em> 中添加 <em>SSH Key</em></h4><ul>
<li>Settings-&gt;SSH and GRG keys-&gt;new SSH key<br><img src="http://upload-images.jianshu.io/upload_images/659084-5c62e09650873795.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-25987355f4a0e8cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-313107faef8abb08.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-382e08b98c30ba58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>创建成功后，跳转页面中你会看到你新建的ssh key<br><img src="http://upload-images.jianshu.io/upload_images/659084-48ad323d9452d92a.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
</ul>
<h4 id="创建-GitHub-仓库"><a href="#创建-GitHub-仓库" class="headerlink" title="创建 GitHub 仓库"></a>创建 <em>GitHub</em> 仓库</h4><ul>
<li>登录GitHub账号后，创建新的仓库，仓库名称看自己需要命名，其他默认就好了。我这里为了测试，就取为<strong>test</strong><br><img src="http://upload-images.jianshu.io/upload_images/659084-1ae7942e887d2f50.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-db087fe0ca9607ae.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>GitHub仓库创建成功后，会有SSH和HTTPS地址<br><img src="http://upload-images.jianshu.io/upload_images/659084-1efaa0a539fbbd68.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
</ul>
<h4 id="Git-连接-GitHub，并推送本地文件到远程仓库"><a href="#Git-连接-GitHub，并推送本地文件到远程仓库" class="headerlink" title="Git 连接 GitHub，并推送本地文件到远程仓库"></a><em>Git</em> 连接 <em>GitHub</em>，并推送本地文件到远程仓库</h4><ul>
<li>在本地仓库的目录 <em>gitFile</em> 下运行命令</li>
</ul>
<pre><code>git remote add origin 仓库的SSH地址

</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-955edfecc27bf5ef.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br>注意，这里的 <em>origin</em> 是远程仓库的名字（<em>Git</em>的默认叫法）</p>
<ul>
<li>将本地仓库 <em>Git</em> 的文件推送到远程仓库 <em>GitHub</em></li>
</ul>
<pre><code>git push -u origin master

</code></pre><p>不出意外，在GitHub的 <em>test</em> 仓库中会看到我们传送的文件<br><img src="http://upload-images.jianshu.io/upload_images/659084-3ceb742e8262ac94.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<h4 id="从-GitHub-中克隆文件到本地"><a href="#从-GitHub-中克隆文件到本地" class="headerlink" title="从 GitHub 中克隆文件到本地"></a>从 <em>GitHub</em> 中克隆文件到本地</h4><ul>
<li>在 <em>GitHub</em> 中创建文件，并且复制<em>SSH</em> 地址<br><img src="http://upload-images.jianshu.io/upload_images/659084-8555c272dc15e144.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-29aec05f56492874.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"><br><img src="http://upload-images.jianshu.io/upload_images/659084-1e5de00c4bbe4477.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></li>
<li>输入以下克隆命令</li>
</ul>
<pre><code>git clone SSH地址

</code></pre><p>你会发现，<em>GitHub</em> 中的目录包括你刚才新建的文件都存在本地目录中了。</p>
]]></content>
      <categories>
        <category>Git</category>
      </categories>
      <tags>
        <tag>Git</tag>
      </tags>
  </entry>
  <entry>
    <title>防抖和节流</title>
    <url>/2019/02/18/%E9%98%B2%E6%8A%96%E5%92%8C%E8%8A%82%E6%B5%81/</url>
    <content><![CDATA[<h2 id="防抖"><a href="#防抖" class="headerlink" title="防抖"></a>防抖</h2><ul>
<li>对于一些高频触发操作的场景，我们需要加防抖操作。比如：监听页面滚动、输入实时显示搜索结果等。这些都需要加防抖操作，不然对页面性能有很大的副作用。</li>
<li>简单概括：防抖就是将高频操作优化为最后一次执行。</li>
</ul>
<p>实现：</p>
<pre><code>function debounce(fn, wait, immediate = false) {
  var timeout, result;

  timeout &amp;&amp; clearTimeout(timeout);
  var debounced = function () {
    var context = this;
    var args = arguments;

    if (immediate) { // 事件停止触发后 n 秒，触发事件立刻执行回调
      var callNow = !timeout;
      timeout = setTimeout(function () {
        timeout = null;
      }, wait)
      if (callNow) {
        result = fn.apply(context, args);
      }
    } else { // 事件停止触发后，执行回调函数
      timeout = setTimeout(function () {
        fn.apply(context, args);
      }, wait);
    }
  }

  debounced.cancel = function () {
    clearTimeout(timeout);
    timeout = null;
  }

  return debounced;
}
</code></pre><h2 id="节流"><a href="#节流" class="headerlink" title="节流"></a>节流</h2><p>每段时间后执行一次，将高频转化为低频。</p>
<ul>
<li>时间戳</li>
</ul>
<pre><code>function throttle(fn, wait) {
    var previous = 0;

    return function () {
        var args = arguments;
        var context = this;
        var now = +new Date();
        if (now - previous &gt; wait) {
            fn.apply(context, args);
            previous = now;
        }
    }
}
</code></pre><ul>
<li>定时器</li>
</ul>
<pre><code>function throttle(fn, wait) {
    var timeout;

    return function() {
        var args = arguments;
        var context = this;
        if (!timeout) {
            timeout = setTimeout(function() {
                timeout = null;
                fn.apply(context, args);
            }, wait)
        }
    }
}
</code></pre>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>vue-cli3.0项目创建+配置+自动部署</title>
    <url>/2019/02/17/vue-cli3-0%E9%A1%B9%E7%9B%AE%E5%88%9B%E5%BB%BA-%E9%85%8D%E7%BD%AE-%E8%87%AA%E5%8A%A8%E9%83%A8%E7%BD%B2/</url>
    <content><![CDATA[<h2 id="创建项目"><a href="#创建项目" class="headerlink" title="创建项目"></a>创建项目</h2><ul>
<li><p>安装 <strong>vue3.0</strong> 脚手架</p>
<pre><code>npm install -g @vue/cli
</code></pre></li>
<li><p>创建项目</p>
<pre><code>vue create my_project
</code></pre><p>一系列选择之后，可以保存你当前的选择配置，之后创建项目的时候就可以直接用了。</p>
</li>
<li><p>安装依赖</p>
<pre><code>cd my_project
</code></pre></li>
</ul>
<p>最后的项目目录结构如下：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-5267ed577dcb2fc6.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="运行项目"><a href="#运行项目" class="headerlink" title="运行项目"></a>运行项目</h2><p><strong>vue3.0</strong> 运行项目主要有两种方式：</p>
<ul>
<li><p>命令行方式：</p>
<pre><code>npm run serve
</code></pre></li>
<li><p>UI视图方式，这也是3.0版本的一大亮点。通过UI视图方式，可以帮助我们很多事，如：运行项目、安装依赖、安装插件等。</p>
<pre><code>vue ui
</code></pre></li>
</ul>
<h2 id="webpack-配置"><a href="#webpack-配置" class="headerlink" title="webpack 配置"></a>webpack 配置</h2><p>vue 已经帮我们配置了很多，额外自己又添加了一些配置；在根目录添加 <strong>vue.config.js</strong> 配置文件：</p>
<pre><code>const path = require(&#39;path&#39;);
const px2rem = require(&#39;postcss-px2rem&#39;);
const VconsoleWebpackPlugin = require(&#39;vconsole-webpack-plugin&#39;);
const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;);
// 判断是否为生产环境
const isProduction = process.env.NNODE_ENV === &#39;production&#39;;
// 路径处理函数
const resolve = name =&gt; path.resolve(__dirname, name);

module.exports = {
  publicPath: isProduction ? &#39;/production&#39; : &#39;/&#39;, // 部署应用包时的基本 URL
  productionSourceMap: !isProduction, // 生产环境不开启 source-map
  devServer: { // webpack-dev-server 的配置
    port: 8089, // 本地端口
    open: true, // 自动打开浏览器
    // proxy: { // 代理
    //   &#39;/api&#39;: {
    //     target: &#39;&lt;url&gt;&#39;,
    //     ws: true,
    //     changeOrigin: true
    //   },
    // }
  },
  css: {
    extract: isProduction, // 生产环境将 css 单独抽离成一个文件
    sourceMap: !isProduction, // 生成环境不开启 source-map
    loaderOptions: {
      postcss: {
        // 移动端使用rem
        plugins: [
          px2rem({
            remUnit: 75
          })
        ]
      },
      // 全局共享variables.scss
      sass: {
        // @/ 是 src/ 的别名
        // 所以这里假设你有 `src/variables.scss` 这个文件
        data: `@import &quot;@/variables.scss&quot;;`
      }
    }
  },
  configureWebpack: config =&gt; {
    const devPlugins = [
      new VconsoleWebpackPlugin({ // 微信移动端调试控制台
        enable: !isProduction
      })
    ];
    const prodPlugins = [
      new TerserWebpackPlugin({
        terserOptions: { // 打包时候的配置
          warnings: false,
          compress: true,
          drop_console: true,
          drop_debugger: true,
          pure_funcs: [&#39;console.log&#39;]
        }
      })
    ];
    if (isProduction) { // 生产环境
      config.optimization.minimizer = [
        ...config.optimization.minimizer,
        ...prodPlugins
      ]
    } else { // 开发环境
      config.plugins = [...config.plugins, ...devPlugins]
    }
  },
  chainWebpack: config =&gt; {
    // 自定义全局变量
    // config
    //   .plugin(&#39;define&#39;)
    //   .tap((args) =&gt; {
    //     args[0].PRODUCTION = isProduction ? JSON.stringify(&#39;&#39;) :
    //       JSON.stringify(
    //         &#39;other/&#39;,
    //       );
    //     return args;
    //   });
    // 别名设置
    config.resolve.alias
      .set(&#39;js&#39;, resolve(&#39;src/assets/js&#39;))
      .set(&#39;scss&#39;, resolve(&#39;src/assets/scss&#39;))
      .set(&#39;images&#39;, resolve(&#39;src/assets/images&#39;))
      .set(&#39;components&#39;, resolve(&#39;src/components&#39;));
  }
}
</code></pre><h2 id="路由配置"><a href="#路由配置" class="headerlink" title="路由配置"></a>路由配置</h2><p><strong>vue3.0</strong> 的路由配置已经很完善了，这里我仅仅小改动，封装了路由懒加载函数：</p>
<pre><code>import Vue from &#39;vue&#39;
import Router from &#39;vue-router&#39;
import Home from &#39;./views/Home.vue&#39;

Vue.use(Router)
// 路由懒加载
// route level code-splitting
// this generates a separate chunk (about.[hash].js) for this route
// which is lazy-loaded when the route is visited.
const addRouterComponent = path =&gt; import(path);

export default new Router({
  mode: &#39;history&#39;,
  base: process.env.BASE_URL,
  routes: [{
      path: &#39;/&#39;,
      name: &#39;home&#39;,
      component: Home
    },
    {
      path: &#39;/about&#39;,
      name: &#39;about&#39;,
      component: addRouterComponent(&#39;./views/About.vue&#39;)
    }
  ]
})
</code></pre><h2 id="axios-的配置"><a href="#axios-的配置" class="headerlink" title="axios 的配置"></a>axios 的配置</h2><p>在 <strong>scr</strong> 目录下添加 <strong>api</strong> 目录，并新建两个文件：<strong>config.js</strong> 和 <strong>api.js</strong>。配置如下：</p>
<ul>
<li><strong>config.js</strong></li>
</ul>
<pre><code>import axios from &#39;axios&#39;;
import qs from &#39;qs&#39;;

axios.defaults.withCredentials = false;
// 请求拦截器
axios.interceptors.request.use(
  request =&gt; {
    request.data = request.data || {};
    const hasHttp = /^http(|s):\/\//.test(request.url);
    if (!hasHttp) { // 无 http or https 头处理
      request.url = `https://${request.url}`;
    }
    if (request.data) {
      request.data = {
        // commom: &#39;&#39;, 这里可以添加一些公共的请求参数
        data: JSON.stringify(request.data)
      };
      request.data = qs.stringify(request.data);
    }
    return request;
  },
  error =&gt; Promise.reject(error)
);
// 响应拦截器
axios.interceptors.response.use(
  response =&gt; {
    const responseData = response.data;
    if (responseData.errcode !== 0) { // 错误处理
      return Promise.reject(responseData.msg || &#39;未知错误&#39;);
    }
    responseData.result = responseData.result || {};
    return responseData;
  },
  error =&gt; Promise.reject(error)
);

export {
  axios
};
</code></pre><ul>
<li><strong>api.js</strong></li>
</ul>
<pre><code>import {
  axios
} from &#39;./config.js&#39;;

// 例子 1
export const aApi1Name = params =&gt; axios.post(url, params);
// 例子 2
export const aApi2Name = params =&gt; axios.get(url, params);
</code></pre><h2 id="打包后自动部署到服务器"><a href="#打包后自动部署到服务器" class="headerlink" title="打包后自动部署到服务器"></a>打包后自动部署到服务器</h2><p>使用的是 <strong>scp2</strong>；通过向脚本传递不同参数，部署到不同的服务器路径；在根目录添加 <strong>deploy.js</strong> 脚本。相关配置如下：</p>
<ul>
<li><strong>package.json</strong></li>
</ul>
<pre><code>&quot;buildTest&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js development&quot;,
&quot;buildProd&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js production&quot;
</code></pre><ul>
<li><strong>deploy.js</strong></li>
</ul>
<pre><code>const qs = require(&#39;qs&#39;);

// 判断是否输出帮助信息
const helpMessage = `usage: node deploy.js [deploy_target]`;
if (
  process.argv.length !== 3 ||
  process.argv[2] === &#39;-h&#39; ||
  process.argv[2] === &#39;--help&#39;
) {
  console.log(helpMessage);
  process.exit(0);
}

// 判断是否是生产环境
const isProduction = process.argv[2] === &#39;production&#39;;

// 设置部署的文件路径，正服 or 测服
let deployPath = &#39;&#39;;
if (isProduction) {
  deployPath = &#39;/production&#39;
} else {
  deployPath = &#39;/test&#39;
}

// 设置服务器服务器信息
const SERVER_INFO = {
  host: &#39;134.175.150.8&#39;,
  port: 22,
  username: &#39;&#39;,
  password: &#39;&#39;,
  path: deployPath
}

// 部署到服务器
client.scp(&#39;./dist/&#39;, SERVER_INFO, err =&gt; {
  if (err) {
    console.log(&#39;Deploy Failed!\n&#39;, err);
  }
})

console.log(`Deploy ${isProduction ? &#39;production&#39; : &#39;developemt&#39;} finished!`);
</code></pre><p>总结：通过上面的配置，基本可以实现 <strong>vue</strong> 项目从创建到配置到打包自动部署的过程。</p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>Vue</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>Vue</tag>
      </tags>
  </entry>
  <entry>
    <title>websocket</title>
    <url>/2019/02/17/websocket/</url>
    <content><![CDATA[<h2 id="HTTP-HTTPS-协议"><a href="#HTTP-HTTPS-协议" class="headerlink" title="HTTP/HTTPS 协议"></a>HTTP/HTTPS 协议</h2><ul>
<li>一个 <strong>request</strong> 对应一个 <strong>response</strong>。一般使用 <strong>轮询</strong> 机制获取信息。</li>
<li>虽然后期有 <strong>keep-alive</strong>，可以一次连接中处理多个 <strong>request</strong> 合并发送，接收多个 <strong>response</strong>，对每个请求仍然需要单独发 <strong>header</strong>。</li>
<li><strong>HTTP</strong> 的 <strong>response</strong> 是被动的，通信只能由客户端发起，做不到服务端主动向客户端推送信息。</li>
<li><strong>HTTP</strong> 是无状态协议。</li>
<li>需要三次握手。</li>
<li>HTTP：TCP + HTTP</li>
<li>HTTPS：TCP + HTTP + TLS</li>
</ul>
<h4 id="ajax-轮询"><a href="#ajax-轮询" class="headerlink" title="ajax 轮询"></a>ajax 轮询</h4><p><strong>ajax 轮询</strong> 是指客户端 <strong>不断</strong> 向服务器发送资源请求 <strong>request</strong>，服务端不管有无目标资源，都会返回 <strong>response</strong> 结果。这样就要求服务器拥有更好的处理速度。</p>
<h4 id="long-poll-长轮询"><a href="#long-poll-长轮询" class="headerlink" title="long poll / 长轮询"></a>long poll / 长轮询</h4><p><strong>long poll</strong> 比 <strong>ajax 轮询</strong> 好点，<strong>不会不断</strong> 向服务器发送资源请求 <strong>request</strong>，一旦接受客户端的请求，有资源就返回；无资源就挂起，直到有资源才返回 <strong>response</strong> 结果（有且仅有返回一次）。高并发，需要服务器可以同时处理多个请求的能力。</p>
<h2 id="websocket-协议"><a href="#websocket-协议" class="headerlink" title="websocket 协议"></a>websocket 协议</h2><ul>
<li><strong>websocket</strong> 是 <strong>html5</strong> 出的协议。</li>
<li><strong>websocket</strong> 是一个持久化的协议，<strong>websocket</strong> 只需要一次请求（一次 <strong>HTTP 握手</strong> ），就可以得到所需的资源。</li>
<li>服务端可以 <strong>主动</strong> 向客户端推送信息，客户端也可以 <strong>主动</strong> 向服务端推送消息，实现“双向平等”，是属于服务器推送技术的一种。</li>
<li>与 <strong>HTTP</strong> 有较好的兼容性，在握手阶段采用 <strong>HTTP</strong> 协议。</li>
<li>默认端口 <strong>80</strong> and <strong>443</strong>。</li>
<li>数据格式轻量，性能开销小，通信高效，可以发送文本，也可以二进制数据。</li>
<li>没有同源策略。</li>
<li>WS：TCP + WS</li>
<li>WSS：TCP + WS + TLS</li>
</ul>
<h4 id="websocket-握手"><a href="#websocket-握手" class="headerlink" title="websocket 握手"></a>websocket 握手</h4><pre><code>GET /chat HTTP/1.1
Host: server.example.com
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==
Sec-WebSocket-Protocol: chat, superchat
Sec-WebSocket-Version: 13
</code></pre><ul>
<li>Upgrade/Connection：通知服务器发起的是 <strong>wesocket</strong> 协议。</li>
<li>Sec-WebSocket-Key：浏览器随机生成的 <strong>Base64 encode</strong> 的值，用于验证服务器是不是 <strong>websocket 协议</strong>。</li>
<li>Sec-WebSocket-Protocol：用户定义的字符串，用来区分 <strong>同 url</strong> 下，不同的服务所需要的协议。</li>
<li>Sec-WebSocket-Version：协议版本。</li>
</ul>
<h4 id="服务器返回"><a href="#服务器返回" class="headerlink" title="服务器返回"></a>服务器返回</h4><pre><code>HTTP/1.1 101 Switching Protocols
Upgrade: websocket
Connection: Upgrade
Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=
Sec-WebSocket-Protocol: chat
</code></pre><ul>
<li>Upgrade/Connection：通知客户端升级的是 <strong>websocket</strong> 协议。</li>
<li>Sec-WebSocket-Accept：经服务器确认，加密后的 <strong>Sec-WebSocket-Key</strong>。</li>
<li>Sec-WebSocket-Protocol：最终使用的协议。</li>
</ul>
<h4 id="代码实现"><a href="#代码实现" class="headerlink" title="代码实现"></a>代码实现</h4><pre><code>ws.addEventListener(&#39;open&#39;, function () {
    console.log(&#39;Open the websocket...&#39;);
    ws.send(&#39;Hello websocket...&#39;);
});
ws.addEventListener(&#39;message&#39;, function (e) {
    console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Receive the websocket message...&#39; + e.data);
    ws.close();
    setTimeout(() =&gt; {
        console.log(&#39;Ready state: &#39; + ws.readyState);
    }, 1000)
});
ws.addEventListener(&#39;close&#39;, function () {
    console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Close the websocket...&#39;);
})
</code></pre><p>结果：<br><img src="http://upload-images.jianshu.io/upload_images/659084-021a1bb1915811bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>参考：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-d06ed1bfe9c9fadb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<ul>
<li><a href="https://www.zhihu.com/search?type=content&amp;q=websocket" target="_blank" rel="noopener">https://www.zhihu.com/search?type=content&amp;q=websocket</a></li>
<li><a href="http://www.ruanyifeng.com/blog/2017/05/websocket.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2017/05/websocket.html</a></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title>用户认证小总结</title>
    <url>/2019/02/17/%E7%94%A8%E6%88%B7%E8%AE%A4%E8%AF%81%E5%B0%8F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="用户认证"><a href="#用户认证" class="headerlink" title="用户认证"></a>用户认证</h2><p>一般的用户认证流程如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-bdfa6d0008a02e53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800" alt="image.png"></p>
<p>但是，这种模式的扩展性不好。单个服务器没问题，如果多个服务器集群，要求共享 <strong>session</strong> ，每个服务器都能访问到 <strong>session</strong> 。</p>
<ul>
<li>解决方案一：<strong>session</strong> 数据持久化，写入数据库或者其他持久层。各个服务器收到请求后，向持久层发送数据请求。<ul>
<li>缺点：工程量大。</li>
</ul>
</li>
<li>解决方案二：服务器不保存 <strong>session</strong> 数据，所有的数据保存在客户端，每次请求都发回服务器。如：JWT(Json Web Token)。</li>
</ul>
<h2 id="JWT"><a href="#JWT" class="headerlink" title="JWT"></a>JWT</h2><p><strong>JWT</strong> 服务器不保存 <strong>session</strong> 数据，在服务器认证之后，返回一个 <strong>JSON</strong> 对象。格式如下：</p>
<pre><code>{
    &quot;姓名&quot;: &quot;zero&quot;,
    &quot;角色&quot;: &quot;管理员&quot;,
    &quot;到期时间&quot;: &quot;2018年10月6日0点0分&quot;
}
</code></pre><p>之后，客户端与服务器的用户认证都靠这个 <strong>JSON</strong> 对象，当然，这个对象后面会加上签名，保证数据不被篡改。</p>
<h4 id="JWT-的数据结构"><a href="#JWT-的数据结构" class="headerlink" title="JWT 的数据结构"></a>JWT 的数据结构</h4><ul>
<li><strong>JWT</strong> 是一个很长的字符串，中间用 <strong>.</strong> 分隔，内部没有换行。</li>
<li>组成由三个部分：<strong>Header.Payload.Signature</strong><ul>
<li>Header：头部。<strong>JSON</strong> 对象，描述 <strong>JWT</strong> 的元数据。</li>
<li>Payload：负载。<strong>JSON</strong> 对象，存放实际需要传递的数据；不加密。</li>
<li>Signature：签名。对 <strong>Header</strong> 和 <strong>Payload</strong> 的签名，防止数据被篡改。</li>
</ul>
</li>
</ul>
<p>Header 格式：</p>
<pre><code>{
  &quot;alg&quot;: &quot;HS256&quot;,   // 签名的算法
  &quot;typ&quot;: &quot;JWT&quot;      // token 类型
}
</code></pre><p>Payload 七个字段：</p>
<ul>
<li>iss (issuer)：签发人</li>
<li>exp (expiration time)：过期时间</li>
<li>sub (subject)：主题</li>
<li>aud (audience)：受众</li>
<li>nbf (Not Before)：生效时间</li>
<li>iat (Issued At)：签发时间</li>
<li>jti (JWT ID)：编号</li>
</ul>
<h4 id="JWT-的使用方式"><a href="#JWT-的使用方式" class="headerlink" title="JWT 的使用方式"></a>JWT 的使用方式</h4><ul>
<li>存储在 <strong>cookie</strong> 中。</li>
<li>存储在 <strong>localStorage</strong> 中。</li>
<li>客户端每次与服务器进行通信的时候，都会带上 <strong>JWT</strong>。</li>
</ul>
<p>参考：</p>
<ul>
<li><a href="http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html" target="_blank" rel="noopener">http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html</a></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
      </tags>
  </entry>
  <entry>
    <title>web safe</title>
    <url>/2019/02/17/web-safe/</url>
    <content><![CDATA[<h2 id="CSRF-Cross-Site-Request-Forgery"><a href="#CSRF-Cross-Site-Request-Forgery" class="headerlink" title="CSRF : Cross Site Request Forgery"></a>CSRF : Cross Site Request Forgery</h2><p><strong>CSRF</strong> 跨站请求伪造。<br>是一种劫持受信任用户向服务器发送非预期请求的攻击方式。简而言之：用户在登录的情况下访问了钓鱼网站，钓鱼网站通过用户向其他网站发送请求，这样就达到了模拟用户的目的。具体实现如下图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-9ce93c3bff5d427b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="防御手段"><a href="#防御手段" class="headerlink" title="防御手段"></a>防御手段</h4><ul>
<li>验证码实现用户验证。验证码强制用户必须与应用进行交互，才能完成最终的请求。</li>
<li>通过 referer 实现用户验证。根据 <strong>HTTP</strong> 协议，在 <strong>HTTP</strong> 头中有一个字段叫 <strong>Referer</strong>，它记录了该 <strong>HTTP</strong> 请求的 <strong>来源地址</strong>。通过 <strong>Referer Check</strong>，可以检查请求是否来自合法的”源”。</li>
<li>通过 token 实现用户验证。</li>
<li>尽量不要在页面的链接中暴露用户隐私信息。</li>
<li>对于用户修改删除等操作最好都使用 post 操作。</li>
<li>避免全站通用的 cookie，严格设置 cookie 的域。</li>
</ul>
<h2 id="XSS-Cross-Site-Script"><a href="#XSS-Cross-Site-Script" class="headerlink" title="XSS : Cross Site Script"></a>XSS : Cross Site Script</h2><p><strong>XSS</strong> 跨站脚本攻击。<br>攻击者向用户的网站嵌入的 js 脚本代码，当用户访问该网站的时候，该 js 脚本代码就会被执行，从而达到攻击用户的目的。</p>
<h4 id="反射型-XSS-攻击"><a href="#反射型-XSS-攻击" class="headerlink" title="反射型 XSS 攻击"></a>反射型 XSS 攻击</h4><p>又称非持久性跨站脚本攻击。发出请求时，XSS 代码出现在 <strong>URL</strong> 中，作为输入提交到服务器端，服务器端解析后响应，XSS 随响应内容一起返回给浏览器，最后浏览器解析执行 XSS 代码。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。<br>比如：</p>
<pre><code>http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！
</code></pre><h4 id="存储型-XSS-攻击"><a href="#存储型-XSS-攻击" class="headerlink" title="存储型 XSS 攻击"></a>存储型 XSS 攻击</h4><p>XSS 提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交 XSS 代码。这种攻击方式的稳定性很好。<br>比如：</p>
<blockquote>
<p>攻击者在 value 填写<code>&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;</code>【或者 html 其他标签（破坏样式。。。）、一段攻击型代码】；将数据存储到数据库中；其他用户取出数据显示的时候，将会执行这些攻击性代码。</p>
</blockquote>
<h4 id="具体方式"><a href="#具体方式" class="headerlink" title="具体方式"></a>具体方式</h4><ul>
<li>攻击者向服务器注入 js 代码。</li>
<li>诱导用户访问受到攻击的网站。</li>
<li>用户访问受到攻击的网站，执行注入的 js 代码。</li>
</ul>
<h4 id="XSS-防御方式"><a href="#XSS-防御方式" class="headerlink" title="XSS 防御方式"></a>XSS 防御方式</h4><ul>
<li>HttpOnly</li>
<li>输入检查</li>
<li>输出检查</li>
</ul>
<p>参考链接：</p>
<ul>
<li><a href="https://www.cnblogs.com/shytong/p/5308667.html" target="_blank" rel="noopener">https://www.cnblogs.com/shytong/p/5308667.html</a></li>
<li><a href="https://github.com/dwqs/blog/issues/68" target="_blank" rel="noopener">https://github.com/dwqs/blog/issues/68</a></li>
<li><a href="https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label3" target="_blank" rel="noopener">https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label3</a></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>web-safe</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>web-safe</tag>
      </tags>
  </entry>
  <entry>
    <title>Ajax和跨域总结</title>
    <url>/2019/02/17/Ajax%E5%92%8C%E8%B7%A8%E5%9F%9F%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="Ajax（JavaScript实现）"><a href="#Ajax（JavaScript实现）" class="headerlink" title="Ajax（JavaScript实现）"></a>Ajax（JavaScript实现）</h2><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>Ajax（Async Javascript And Xml）：异步Js和Xml，意思就是用Js执行异步网络请求。作用主要是在不重新加载<strong>全部网页</strong>的情况下，对<strong>部分页面</strong>进行更新。</p>
<h4 id="创建XMLHttpRequest对象"><a href="#创建XMLHttpRequest对象" class="headerlink" title="创建XMLHttpRequest对象"></a>创建XMLHttpRequest对象</h4><p>除了IE5和IE6不支持之外（支持ActiveXObject对象），几乎现在所有的有内建的XMLHttpRequest对象。所以在创建请求对象之前判断下就好了：</p>
<pre><code>let xhr = null;
xhr = window.XMLHttpRequest ? new xmlHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;)
// 或者
if(window.XMLHttpRequest){
    xhr = new XMLHttpRequest()
}else{
    xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)
}
</code></pre><h4 id="通过open-和send-向服务器发送请求"><a href="#通过open-和send-向服务器发送请求" class="headerlink" title="通过open()和send()向服务器发送请求"></a>通过open()和send()向服务器发送请求</h4><ul>
<li>xhr.open(method, url, async)<br>这个方法的参数分别是：method请求的类型GET或者POST；URL请求的文件在服务器上的地址；async是否异步请求true或者false（一般不设置为false）。</li>
<li>xhr.send()：发送请求。</li>
<li>xhr.setRequestHeader(header, value)：如果是POST的话，要设置发送的HTTP头，然后通过send方法发送内容。参数分别是：发送的头部名称，头部的值。一般都是固定的。</li>
</ul>
<pre><code>// 向浏览器发送请求
xhr.open(&#39;GET&#39;, &#39;./server.php&#39;, true)
// 添加HTTP头（POST方法）
xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;)   
xhr.send()
</code></pre><p>GET方法不需要参数，POST方法则需要把body参数；如果要想向服务器发送相关的参数，则通过open里面的第二个参数url进行发送，具体实现如下代码：</p>
<pre><code>url = &quot;./filePath?paramName=&quot; + paramValue + ...;
</code></pre><h4 id="判断准备状态"><a href="#判断准备状态" class="headerlink" title="判断准备状态"></a>判断准备状态</h4><pre><code>xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        ...
    }
}
</code></pre><ul>
<li>xhr.onreadystatechange方法中，每当readyState改变时，就会触发xhr.onreadystatechange事件。</li>
<li>readyState属性：存有XMLHttpRequest的状态信息。0：请求未初始化；1：服务器链接已经建立；2：请求已经接受；3：请求处理中；4：请求已完成，且响应已就绪。一共有5个状态，所以onreadystatechange事件会被触发5次。</li>
<li>实际上onreadystateschange是通过回调函数实现的，即：每当readyState的状态改变时，这个回调函数就会被执行。</li>
<li>status属性：表示响应的结果。</li>
</ul>
<p>总的代码如下：</p>
<pre><code>document.getElementById(&#39;btn&#39;).onclick = function () {
// 创建请求对象（先判断浏览器类型）
// var xhr = null;
// if (window.XMLHttpRequest) {
//     xhr = new XMLHttpRequest()
// } else {
//     xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)
// }
xhr = (window.XMLHttpRequest) ? (new XMLHttpRequest()) : (new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;))
// 判断响应状态并执行相关的操作
xhr.onreadystatechange = function () {
    if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) {
        let data = xhr.responseText
        console.log(data);
        document.getElementById(&#39;myDiv&#39;).innerText = data
    }
}
// 向浏览器发送请求
let url = &quot;./server.txt&quot;
xhr.open(&#39;GET&#39;, url, true)
// 添加HTTP头（POST方法）
// xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;)
xhr.send(null);
}
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-b5b344a3944ba224.gif?imageMogr2/auto-orient/strip" alt="异步1.gif"></p>
<p>但是，由于在<strong>同源策略</strong>的作用下，浏览器只能同源的其他域的资源，先看看什么是同源策略～</p>
<h2 id="同源策略-SOP（Same-origin-policy）"><a href="#同源策略-SOP（Same-origin-policy）" class="headerlink" title="同源策略/SOP（Same origin policy）"></a>同源策略/SOP（Same origin policy）</h2><p>来自百度的解释：</p>
<blockquote>
<p>同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能（防止CSRF/XSRF攻击：跨站请求伪造）。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。</p>
</blockquote>
<p>简单来说，就是浏览器只能请求同源的其他域的资源，即同源的网页才能相互获取资源，而不能访问其他域的资源；但是有一个例外，同源策略不会阻止动态脚本插入到文档中；其中，<strong><script>\</script></strong>是开放策略；当web网页执行一个脚本之前，会检查是否同源，只有同源才会被执行，非同源则会被拒绝访问。<br>截取网上的图片说明同源：<br><img src="http://upload-images.jianshu.io/upload_images/659084-80411ea5e317ed19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400" alt="image.png"></p>
<h2 id="跨域"><a href="#跨域" class="headerlink" title="跨域"></a>跨域</h2><p>跨域就是突破同源策略的限制，获取其他源的资源。<br>非同源主要有三种行为会受到限制：</p>
<ul>
<li>Cookie,LocalStorage和IndexDB无法读取。</li>
<li>DOM无法获取。</li>
<li>Ajax无法获取。</li>
</ul>
<h4 id="JSONP"><a href="#JSONP" class="headerlink" title="JSONP"></a>JSONP</h4><p>JSONP是实现跨域的常用方法，但是JSONP只能实现GET方法。实际上是是利用了浏览器允许跨域引用JavaScript资源（script标签是开放策略）。</p>
<p>下面举一个例子：我们从360浏览器首页的天气查询获取天气查询的异步请求地址；这里我们实现通过本地localhost服务器跨域请求360的天气查询，来说明JSONP怎么实现跨域。<br>我们请求资源的地址为：<br><a href="https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600" target="_blank" rel="noopener">https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600</a><br>在浏览器中打开这个地址，我们会得到这样的数据：__jsonp21__({…})。<br>解释：JSONP返回的通常是以函数的形式返回，前面这个__jsonp21__是函数名，所以我们需要在我们的代码中事先准备好名称为__jsonp21__的函数，我们对跨域请求到的数据就是放在这个函数中的，然后动态加载一个<strong>script</strong>节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。</p>
<p>具体代码如下：</p>
<pre><code> // 请求的地址为：https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600

function __jsonp21__(data) {   // 将要处理了的数据放在这个函数中
    console.log(data);  // 得到的是跨域请求的数据
    let myDiv = document.getElementById(&#39;myDiv&#39;)  
    myDiv.innerHTML = data.area
}
window.onload = function () { 
    let btn = document.getElementById(&#39;btn&#39;)
    btn.addEventListener(&#39;click&#39;, function () {  
        let url = &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39;
        let scriptTag = document.createElement(&#39;script&#39;)    // 动态创建script标签 
        scriptTag.setAttribute(&#39;src&#39;, url)      // 将其他源的地址设置为动态script的src属性
        // console.log(scriptTag);  // 得到的是script标签
        document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag)  // 将动态创建的script标签添加到html页面中
    })
}
</code></pre><p>注意：数据处理的函数名要跟跨域返回的函数名一样，这样我们通过JSONP请求数据的时候，服务器才能返回数据。<br>最终结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-df752a8458c616ff.gif?imageMogr2/auto-orient/strip" alt="跨域1.gif"></p>
<p>再句一个例子：<br>请求地址是<a href="http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice" target="_blank" rel="noopener">http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice</a></p>
<pre><code>function refreshPrice(data) { 
console.log(data);
}
window.onload = function () {  
    let scriptTag = document.createElement(&#39;script&#39;)
    let url = &#39;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&#39;
    scriptTag.setAttribute(&#39;src&#39;, url)
    document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag)
}
</code></pre><h2 id="Ajax（JQuery实现）"><a href="#Ajax（JQuery实现）" class="headerlink" title="Ajax（JQuery实现）"></a>Ajax（JQuery实现）</h2><p>在JQuery中，实现Ajax主要是由<strong>$.ajax({…})</strong>方法实现。方法的常用参数有：</p>
<ul>
<li>async：是否实现异步加载，一般来说，是true。</li>
<li>type：GET或者POST。</li>
<li>url：发送请求的地址。</li>
<li>timeout：设置请求的超时时间。</li>
<li>success：请求成功后的回调函数。</li>
<li>error：请求失败后的回调函数。</li>
<li>jsonp：在一个JSONP请求中重写回调函数的名字，默认为callback，用来重新命名回调我们跨域请求时候的函数名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。</li>
<li>jsonpCallback：为JSONP请求指定一个回调函数名。 </li>
<li>dataType：预期服务器返回的数据类型。不指定的话，JQueryhi自动判断。”xml”: 返回 XML 文档，可用jQuery处理。</li>
</ul>
<blockquote>
<p>“html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行；”script”: 返回纯文本JavaScript代码。不会自动缓存结果。除非设置了”cache”参数。注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。（因为将使用DOM的 script标签来加载）；”json”: 返回JSON数据；”jsonp”: JSONP格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数；”text”: 返回纯文本字符串。</p>
</blockquote>
<p>用JQuery实现同源的Ajax请求：</p>
<pre><code>$(function () {  
    $(&#39;button&#39;).on(&#39;click&#39;, function () {  
        $.ajax({
            url: &#39;./server.txt&#39;,    // 请求地址
            type: &#39;GET&#39;,    // 请求方式
            async: true,    // 是否异步
            success: function (data) {  
                console.log(data);
            }   // 请求成功后执行的函数
        })
    })
})
</code></pre><p>实现结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-b1fcb9ed574a8a24.gif?imageMogr2/auto-orient/strip" alt="异步2.gif"></p>
<p>用JQuery实现非同源的JSONP跨域请求：</p>
<pre><code>$(function () {  
$(&#39;button&#39;).on(&#39;click&#39;, function () {  
    $.ajax({
        url: &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39;,
        type: &#39;GET&#39;,
        async: true,
        dataType: &#39;jsonp&#39;,
        jsonp: &#39;_jsonp&#39;,
        jsonpCallback: &#39;__jsonp21__&#39;,
        success: function (data) {  
            console.log(data);
            $(&#39;#myDiv&#39;).html(data.area)
        },
        error: function (err) {  
            console.log(err);
        }
    })
})
})
</code></pre><p>实现结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-14e8fc745c21ab00.gif?imageMogr2/auto-orient/strip" alt="跨域2.gif"></p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>3D立体骰子</title>
    <url>/2019/02/16/3D%E7%AB%8B%E4%BD%93%E9%AA%B0%E5%AD%90/</url>
    <content><![CDATA[<p>CSS3确实很强大，很多高大上的动画都可以实现，这里来实现下3D立方体，效果图如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-21400fd37137e37c.gif?imageMogr2/auto-orient/strip" alt="3D立方体.gif"></p>
<h2 id="html"><a href="#html" class="headerlink" title="html"></a>html</h2><p>其实，实现3D立方体需要的html十分简单，只需要一个ul标签里面包裹6个li标签，分别用来表示3D立方体的6个面[ 前，下，后，上，左，右 ]。具体代码如下:</p>
<pre><code>&lt;ul&gt;
    &lt;li&gt;1&lt;/li&gt;
    &lt;li&gt;2&lt;/li&gt;
    &lt;li&gt;3&lt;/li&gt;
    &lt;li&gt;4&lt;/li&gt;
    &lt;li&gt;5&lt;/li&gt;
    &lt;li&gt;6&lt;/li&gt;
&lt;/ul&gt;
</code></pre><h2 id="CSS3"><a href="#CSS3" class="headerlink" title="CSS3"></a>CSS3</h2><h4 id="ul"><a href="#ul" class="headerlink" title="ul"></a>ul</h4><p>基本的宽高这些就不说了；作为整个3D立方体的父级元素，需要设置positiion属性为relative，还要最重要的是设置它的动画类型tranform-style为preserve-3d，这样就可以实现它的所有子元素都进行3d动画。</p>
<h4 id="li"><a href="#li" class="headerlink" title="li"></a>li</h4><p>宽高设置为100%，position属性设置为absolute。</p>
<ul>
<li>前<br>设置背景，并且沿着Z轴移动50px，即宽高的一半(为什么得添加这个, 后面用动画进行解释说明)。</li>
<li>下<br>设置背景，沿着<strong>X轴</strong>旋转-90deg，作为底面，同样，并且沿着Z轴移动50px。</li>
<li>后<br>设置背景，沿着<strong>X轴</strong>旋转-180deg，作为后面，同样，并且沿着Z轴移动50px。</li>
<li>上<br>设置背景，沿着<strong>X轴</strong>旋转90deg，作为上面，同样，并且沿着Z轴移动50px。</li>
<li>左<br>设置背景，沿着<strong>Y轴</strong>旋转-90deg，作为左面，同样，并且沿着Z轴移动50px。</li>
<li><p>右<br>设置背景，沿着<strong>Y轴</strong>旋转90deg，作为右面，同样，并且沿着Z轴移动50px。<br><img src="http://upload-images.jianshu.io/upload_images/659084-133d15ade6726266.gif?imageMogr2/auto-orient/strip" alt="效果.gif"></p>
<h4 id="结尾说明"><a href="#结尾说明" class="headerlink" title="结尾说明"></a>结尾说明</h4><p>这里说明上面那个translate，先来看看如果不添加这个属性是怎样的效果：<br><img src="http://upload-images.jianshu.io/upload_images/659084-2e1633af2155afdb.gif?imageMogr2/auto-orient/strip" alt="动画.gif"><br>可见，所有的面都交集于立方体的中心点。由于未对6个面作任何动画处理的时候，所有的面都集合在一起。所以在面作旋转的同时需要对其进行Z轴的位移处理。</p>
<h4 id="代码"><a href="#代码" class="headerlink" title="代码"></a>代码</h4><pre><code>&lt;style&gt;
  * {
      margin: 0;
      padding: 0;
  }

  body {
      background-color: black;
  }

  ul {
      list-style: none;
      width: 100px;
      height: 100px;
      position: relative;
      cursor: pointer;
      margin: 150px auto;

      transition: 1s;    /* 设置过渡时间 */
      transform-style: preserve-3d;   /* 设置所有的子元素实现3D动画 */
  }

  /* 设置鼠标悬停的动画 */
  ul:hover {
      transform: rotateX(120deg) rotateY(120deg);
  }

  ul li {
      width: 100%;
      height: 100%;
      text-align: center;
      line-height: 100px;
      font-size: 40px;
      font-weight: 700;
      position: absolute;
      top: 0px;
  }
  /* 前 */
  ul li:nth-child(1) {
      background-color: rgba(225, 0, 0, .4);
      transform: rotateX(0deg) translateZ(50px);
  }
  /* 下 */
  ul li:nth-child(2) {
      background-color: rgba(0, 255, 0, .4);
      transform: rotateX(-90deg) translateZ(50px);
  }
  /* 后 */
  ul li:nth-child(3) {
      background-color: rgba(0, 0, 255, .4);
      transform: rotateX(-180deg) translateZ(50px);
  }
  /* 上 */
  ul li:nth-child(4) {
      background-color: rgba(125, 125, 0, .4);
      transform: rotateX(90deg) translateZ(50px);
  }
  /* 左 */
  ul li:nth-child(5) {
      background-color: rgba(0, 125, 125, .4);
      transform: rotateY(-90deg) translateZ(50px);
  }
  /* 右 */
  ul li:nth-child(6) {
      background-color: rgba(10, 45, 36, .4);
      transform: rotateY(90deg) translateZ(50px);
  }
&lt;/style&gt;
</code></pre></li>
</ul>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>DOM事件</title>
    <url>/2019/02/16/DOM%E4%BA%8B%E4%BB%B6/</url>
    <content><![CDATA[<h2 id="事件"><a href="#事件" class="headerlink" title="事件"></a>事件</h2><p>事件就是用户或者浏览器进行的特定行为，比如：鼠标点击事件。</p>
<h2 id="事件名称"><a href="#事件名称" class="headerlink" title="事件名称"></a>事件名称</h2><p>比如：click就是一个事件名。</p>
<h2 id="事件流的执行过程"><a href="#事件流的执行过程" class="headerlink" title="事件流的执行过程"></a>事件流的执行过程</h2><p>事件流：指的是 <em>DOM</em> 事件流（多个事件按照一定顺序执行），DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。<br>事件流的执行过程：从window开始，最后回到window。<br>事件流被分为三个阶段：事件捕获（1-5），事件触发（5-6），事件冒泡（6-10）。</p>
<p>来自网上的图片：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-eb2b449c3348c5d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="事件流.png"></p>
<h4 id="事件冒泡"><a href="#事件冒泡" class="headerlink" title="事件冒泡"></a><a href="#事件冒泡" title="事件冒泡"></a>事件冒泡</h4><p>来自百度的解释：</p>
<blockquote>
<p>当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。</p>
</blockquote>
<p>就比如：我们用button产生一个click事件，但是由于button按钮本身可能不能处理这个事件，就要开始传播出去这个事件。<br>实现事件冒泡的条件是：元素之间有嵌套，每个元素都有相同的事件，这样当最里层的事件触发时，这个事件就会一级一级向上传播，也就是”冒泡“。</p>
<p>举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。这样，当里层点击事件触发时，外层的点击事件也会被触发。</p>
<pre><code>&lt;div id=&quot;outer&quot;&gt;
 &lt;div id=&quot;inner&quot;&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
 window.onload = function () {
   let inner = document.getElementById(&#39;inner&#39;)
   let outer = document.getElementById(&#39;outer&#39;)
   inner.addEventListener(&#39;click&#39;, function (e) {
     console.log(&#39;inner&#39;);
   })
   outer.addEventListener(&#39;click&#39;, function () { 
     console.log(&#39;outer&#39;);
   })
 }
&lt;/script&gt;
</code></pre><p>结果为：<br><img src="http://upload-images.jianshu.io/upload_images/659084-be2355e585a26bc5?imageMogr2/auto-orient/strip" alt="事件冒泡.gif"></p>
<h5 id="阻止事件冒泡"><a href="#阻止事件冒泡" class="headerlink" title="阻止事件冒泡"></a>阻止事件冒泡</h5><ul>
<li>一般浏览器：event.stopPropagation()</li>
<li>IE浏览器：event.cancelBubble = true</li>
</ul>
<h5 id="阻止默认事件"><a href="#阻止默认事件" class="headerlink" title="阻止默认事件"></a>阻止默认事件</h5><ul>
<li>一般浏览器：event.preventDefault()</li>
<li>IE浏览器：event.returnValue = false</li>
</ul>
<h2 id="addEventListener的第三个参数"><a href="#addEventListener的第三个参数" class="headerlink" title="addEventListener的第三个参数"></a>addEventListener的第三个参数</h2><p>addEventListener方法用于将事件和函数进行绑定，函数为：addEventListener(event, fn, useCapture)，这些参数分别是：事件名，事件处理函数，第三个参数 <strong>useCapture</strong> 是一个布尔值，用来设置该事件的执行是在哪个阶段发生的（默认是在冒泡阶段）。</p>
<ul>
<li>true：表示该事件是在“事件捕获阶段”触发的。（由外向内）</li>
<li>false：表示该事件是在“事件冒泡阶段”触发的。（由内向外）</li>
</ul>
<p>举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。</p>
<p>将第三个参数设置为true，事件在 <strong>捕获阶段</strong> 执行：</p>
<pre><code>&lt;div id=&quot;outer&quot;&gt;
 &lt;div id=&quot;inner&quot;&gt;
 &lt;/div&gt;
&lt;/div&gt;

&lt;script&gt;
 window.onload = function () {
 let inner = document.getElementById(&#39;inner&#39;)
 let outer = document.getElementById(&#39;outer&#39;)
 inner.addEventListener(&#39;click&#39;, function (e) {
 console.log(&#39;inner&#39;);
 }, true)
 outer.addEventListener(&#39;click&#39;, function () { 
 console.log(&#39;outer&#39;);
 }, true)
 }
&lt;/script&gt;
</code></pre><p>由于是 <strong>捕获阶段</strong> 执行，即：由外向内执行，所以结果为： outer inner。</p>
<p>结果为：<br><img src="http://upload-images.jianshu.io/upload_images/659084-82bb228984257ae1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>将第三个参数设置为false，事件在 <strong>冒泡阶段</strong> 执行，输出结果为： inner outer。<br><img src="http://upload-images.jianshu.io/upload_images/659084-1d1d0c25024cc18d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="事件处理函数-事件监听函数"><a href="#事件处理函数-事件监听函数" class="headerlink" title="事件处理函数/事件监听函数"></a>事件处理函数/事件监听函数</h2><p>事件触发后的处理函数。如：btn.onclick = fn，fn就是事件处理函数/事件监听函数。</p>
<h4 id="HTML事件处理程序"><a href="#HTML事件处理程序" class="headerlink" title="HTML事件处理程序"></a>HTML事件处理程序</h4><p>例如：</p>
<pre><code>&lt;button onclick = &quot;fn()&quot;&gt;click&lt;/button&gt;
</code></pre><p>这种方式的缺点是：结构和行为耦合在一起。</p>
<h4 id="DOM0级事件处理程序"><a href="#DOM0级事件处理程序" class="headerlink" title="DOM0级事件处理程序"></a>DOM0级事件处理程序</h4><p>形式为：ele.on + ‘事件名称’ = 事件处理函数<br>例如： ele.onclick = function() {…}，this指向当前元素。</p>
<h4 id="DOM2级事件处理程序"><a href="#DOM2级事件处理程序" class="headerlink" title="DOM2级事件处理程序"></a>DOM2级事件处理程序</h4><p>这种方式主要是通过这两个方法：addEventListener()，removeEventListener()<br>这种方式的优点就是：可以同一个事件处理程序绑定多个事件处理函数。</p>
<h2 id="事件委托"><a href="#事件委托" class="headerlink" title="事件委托"></a>事件委托</h2><p>事件委托要处理的问题是：解决事件处理程序过多的问题。简单来说，就是将很多个事件处理程序委托给一个事件处理程序，通过这个事件处理程序来管理这么多个事件处理程序。<br>好处：减少对DOM的访问，提高性能；可以对后来添加进来的元素也能绑定委托事件。</p>
<p>例如：在一个 ul 标签中有很多个 li 标签，我们的需求而是点击每一个 li 标签显示每一个 li 标签的内容。<br>如果没有使用事件委托，我们需要给每一个 li 标签都添加事件监听函数，很明显，这样的效率并不高，而且对整个网页的性能也会影响；如果我们使用事件委托，将这些 li 的事件委托给 ul 标签，这样就可以只用一个事件监听函数实现。</p>
<p>代码如下：</p>
<pre><code>&lt;ul id=&quot;list&quot;&gt; 
 &lt;li&gt;111111&lt;/li&gt;
 &lt;li&gt;222222&lt;/li&gt;
 &lt;li&gt;333333&lt;/li&gt;
 &lt;li&gt;444444&lt;/li&gt;
&lt;/ul&gt;

&lt;script&gt;
 window.onload = function () { 
 // 传统的方法
 // let lis = document.getElementsByTagName(&#39;li&#39;)
 // console.log(lis);
 // for(let i = 0; i &lt; lis.length; i++){
 //     lis[i].addEventListener(&#39;click&#39;, function () { 
 //         console.log(this.innerHTML);
 //     })
 // }
 // 使用事件委托
 let list = document.getElementById(&#39;list&#39;)
 list.addEventListener(&#39;click&#39;, function (e) { 
   let target = e.target
   console.log(target.innerHTML);
 }, false)
 }
&lt;/script&gt;
</code></pre><p>事件委托一般使用的是 <strong>事件冒泡阶段</strong> 进行（虽然事件捕获阶段也可以），因为事件冒泡的事件流模型被所有的主流浏览器兼容，事件冒泡的兼容性更好。</p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>px/em/rem总结</title>
    <url>/2019/02/16/px-em-rem%E6%80%BB%E7%BB%93/</url>
    <content><![CDATA[<h2 id="px"><a href="#px" class="headerlink" title="px"></a>px</h2><p>对于<strong>px</strong>，大家都不陌生。它是一个相对于屏幕的相对长度单位。</p>
<h2 id="em"><a href="#em" class="headerlink" title="em"></a>em</h2><p><strong>em</strong>也是一个相对长度单位，但它相对的是父级元素的字体大小。<br>对于em有一个推算过程：<br>如果没有定义自己的font-size，则：浏览器默认：<em>1em = 16px</em><br>所以：<br><em>12px = 0.75em</em><br><em>10px = 0.625em</em><br>但是如果每次都这样进行计算很麻烦，而且开发效率也很低，因此为了简化计算，我们将浏览器的font-size设置为<strong>62.5%</strong>，这样：<br><strong>1em = （16px * 62.5%） = 10px； 1.2em = 12px</strong><br>依次类推，要使用em这个相对长度单位，只要我们在body标签里面设置了font-size为62.5%，这样只要就可以得到计算公式：<strong>(n)px = (n \ 10)em</strong></p>
<p>但是，em单位是相对的，不是固定的，是逐级继承的（一层一层向上计算），举个例子：<br>比如，一个div里面嵌套了一个div，这两个div都设置了font-size为1.2em，浏览器的font-size设置为62.5%，此时，最里层的div的font-size大小是：<strong>（1.2 * 1.2） = 1.44em</strong>。</p>
<h2 id="rem"><a href="#rem" class="headerlink" title="rem"></a>rem</h2><p><strong>rem</strong>也是相对长度单位，从它的单位也可以看出，它跟<strong>em</strong>比较，多了个 <strong>r</strong> 字母，它的意思就是<strong>root（根）</strong>的意思。简单来说，就是它是相对于根节点（html标签）的font-size而言的。这样子，就消除了<strong>em</strong>单位逐级继承的缺点。<br>举个例子：<br>先将<strong>html</strong>标签设置为62.5%，这样，html里面的任何子标签都是继承于这个标签，也就是说相对于这个标签。所以，不论标签中有多少级的嵌套，最里层标签的font-size的计算公式永远是：<strong>(n)px = (n \ 10)rem</strong></p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>css</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title>js的原型和继承</title>
    <url>/2019/02/16/js%E7%9A%84%E5%8E%9F%E5%9E%8B%E5%92%8C%E7%BB%A7%E6%89%BF/</url>
    <content><![CDATA[<h2 id="原型模式"><a href="#原型模式" class="headerlink" title="原型模式"></a>原型模式</h2><p>原型模式在《JavaScript高级程序设计》中的定义：</p>
<blockquote>
<p>我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用这个对象的好处就是可以让所有对象实例共享它包含的属性和方法。</p>
</blockquote>
<p>这里还有一个__proto__属性，每一个对象都拥有这个属性，这个属性指向对应的构造函数的prototype属性。</p>
<p>通过原型对象，我们就不用将信息添加到构造函数中了。</p>
<h4 id="实例对象共享原型对象的属性"><a href="#实例对象共享原型对象的属性" class="headerlink" title="实例对象共享原型对象的属性"></a>实例对象共享原型对象的属性</h4><pre><code>function Person(){}
Person.prototype.name = &#39;A&#39;
Person.prototype.age = 1
// 实例对象共享原型对象的属性
let p1 = new Person()
console.log(p1.name, p1.age);   // A 1
let p2 = new Person()
console.log(p2.name, p2.age);   // A 1
</code></pre><h4 id="constructor（构造函数）属性"><a href="#constructor（构造函数）属性" class="headerlink" title="constructor（构造函数）属性"></a>constructor（构造函数）属性</h4><p>每个原型对象在默认情况下都会自动获取一个constructor（构造函数）属性，这个属性包含一个指针，指向这个原型所在的函数。在上面的例子中，创建Person函数后，它的prototype指向它的原型对象，这个原型对象就会获取获取constructor属性，指向Person函数。</p>
<h4 id="判断实例对象与原型对象之间的关系"><a href="#判断实例对象与原型对象之间的关系" class="headerlink" title="判断实例对象与原型对象之间的关系"></a>判断实例对象与原型对象之间的关系</h4><ul>
<li>Obj.prototype.isPrototypeOf(obj)</li>
</ul>
<pre><code>console.log(Person.prototype.isPrototypeOf(p1)) // true
</code></pre><ul>
<li>Object.getPrototypeOf(obj)：返回对象实例的原型[es5]</li>
</ul>
<pre><code>console.log(Object.getPrototypeOf(p1) == Person.prototype);   // true
console.log(Object.getPrototypeOf(p1).name);    // A
</code></pre><ul>
<li>obj.hasOwnPrototype(attr)：检测一个属性是否存在于实例中。只有当实例对象重写原型对象的属性后（非原型属性）才会返回true。</li>
</ul>
<pre><code>console.log(p1.hasOwnProperty(&#39;name&#39;)); // false
p1.name = &#39;Ertsul&#39;
console.log(p1.hasOwnProperty(&#39;name&#39;)); //true
</code></pre><ul>
<li><p>in操作符：通过in操作符和hasOwnProperty()可以判断某属性存在于实例还是原型对象中【in判断是否存在属性，hasOwnProperty()判断存在于哪里。】可以单独使用和for-in循环使用：无论属性属于实例还是原型中，都会返回true。(‘name’ in person1)</p>
</li>
<li><p>获取所有实例的属性名字，无论是否可以枚举。</p>
</li>
</ul>
<pre><code>console.log(Object.getOwnPropertyNames(p1)); // [&quot;name&quot;]
</code></pre><ul>
<li>instanceof</li>
</ul>
<pre><code>console.log(p1 instanceof Person);    // true
</code></pre><h4 id="更简单的语法"><a href="#更简单的语法" class="headerlink" title="更简单的语法"></a>更简单的语法</h4><pre><code>function Person() {  }
Person.prototype = {
 name: &#39;001&#39;
}
let p1 = new Person()
console.log(p1.name);
</code></pre><p>这里的例外是：constructor属性不再指向Person；本质上相当于完全重写了Person对象了。注：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。[详见《JavaScript高级程序设计》P156-P157，原型的动态性]</p>
<p>####搜索机制</p>
<ul>
<li>解释器会现在目标对象中搜索目标属性，如果当前对象没有目标属性，解释器继续在目标对象的原型对象中搜索。</li>
<li>通过delete只能删除对象的属性，而不能删除原型对象中的属性。</li>
</ul>
<h4 id="组合模式（默认类型）：构造函数模式-原型模式"><a href="#组合模式（默认类型）：构造函数模式-原型模式" class="headerlink" title="组合模式（默认类型）：构造函数模式 + 原型模式"></a>组合模式（默认类型）：构造函数模式 + 原型模式</h4><p>构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。</p>
<h2 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h2><h4 id="原型链"><a href="#原型链" class="headerlink" title="原型链"></a>原型链</h4><pre><code>// 父亲
function Father() { 
 this.fatherProperty = true
}
Father.prototype.getFatherValue = function () { 
 return this.fatherProperty
}
// 儿子
function Son() { 
 this.sonProperty = false
}
// 继承父亲：通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性
Son.prototype = new Father()
Son.prototype.getSonValue = function () { 
 return this.sonProperty
}

let instance = new Son()
console.log(instance.fatherProperty);   // true
</code></pre><p>上面例子中，通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性。（重写儿子的原型）。这里，儿子原型对象的[[prototype]]（注：不是prototype，[[prototype]]存在于原型中）指向的是父亲的原型对象，而父亲的原型对象的[[prototype]]指向的是Object Prototype。（由于所有函数的默认原型都是Object的实例，所以默认原型都会包含一个内部指针，指向Object.prototype）</p>
<h4 id="借用构造函数"><a href="#借用构造函数" class="headerlink" title="借用构造函数"></a>借用构造函数</h4><ul>
<li>主要是为了解决因为引用类型值的原型属性会被所有实例共享的问题。</li>
<li><strong>借用构造函数/伪造对象/经典继承</strong>：在子类型构造函数的内部调用超类型构造函数。</li>
</ul>
<pre><code>// 父亲
    function Father() { 
     this.info = [&#39;Zero&#39;]
    }
    // 儿子
    function Son() { 
     // 继承父亲：在子类型构造函数的内部调用超类型构造函数
     // 《JavaScript高级程序设计》：函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call() 可以在新创建的对象上执行构造函数。 
     Father.call(this)        // 借用超类的构造函数
    }

    let f = new Father()
    f.info.push(&#39;100&#39;)
    console.log(f.info);    // [&quot;Zero&quot;, &quot;100&quot;]

    let s = new Son()
    console.log(s.info);    // [&quot;Zero&quot;]
</code></pre><p>如果在继承的时候要传递参数，则在后面添加参数即可。如：Father.call(this， param1, param2)</p>
<h4 id="proto"><a href="#proto" class="headerlink" title="__proto__"></a>__proto__</h4><p>通过<strong>__proto__</strong>也可以实现子类型对超类型的继承。</p>
<pre><code>const obj = {
 num : 123 
}
const obj1 = {
 __proto__ : obj
}
console.log(obj1.num);  // 123
</code></pre><h4 id="Object-create-source"><a href="#Object-create-source" class="headerlink" title="Object.create(source)"></a>Object.create(source)</h4><pre><code>const obj = {
 num : 123 
}
const obj2 = Object.create(obj)
console.log(obj2.num);  // 123
</code></pre><h4 id="Object-assign-Object-create-obj-…"><a href="#Object-assign-Object-create-obj-…" class="headerlink" title="Object.assign(Object.create(obj), {…})"></a>Object.assign(Object.create(obj), {…})</h4><pre><code>const obj = {
 num : 123 
}
const obj3 = Object.assign(
 Object.create(obj),
 {
 num2 : 234
 }
)
console.log(obj3.num, obj3.num2);   // 123 234
</code></pre><h2 id="补充"><a href="#补充" class="headerlink" title="补充"></a>补充</h2><h4 id="继承机制如下图："><a href="#继承机制如下图：" class="headerlink" title="继承机制如下图："></a>继承机制如下图：</h4><p><img src="http://upload-images.jianshu.io/upload_images/659084-862bb97f2e2fe227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="测试代码如下："><a href="#测试代码如下：" class="headerlink" title="测试代码如下："></a>测试代码如下：</h4><pre><code>// 父类
function SuperType(){
}
// 子类
function SubType(){

}
// 子类继承父类
SubType.prototype = new SuperType();
// 实例化父类和子类
let superIns = new SuperType();
let subIns = new SubType();

// 子类
console.log(SubType.prototype);     // SuperType {}
console.log(subIns.__proto__);      // SuperType {}

// 父类
console.log(SuperType.prototype);       // {constructor: ƒ} 
console.log(superIns.__proto__);        // {constructor: ƒ}

console.log(SuperType.prototype.__proto__);     
// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}
// 即： Object prototype

console.log(SuperType.prototype.__proto__.constructor);
// ƒ Object() { [native code] } 即：Object
</code></pre>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js的存储和拷贝</title>
    <url>/2019/02/16/js%E7%9A%84%E5%AD%98%E5%82%A8%E5%92%8C%E6%8B%B7%E8%B4%9D/</url>
    <content><![CDATA[<h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h4 id="基本数据类型"><a href="#基本数据类型" class="headerlink" title="基本数据类型"></a>基本数据类型</h4><ul>
<li>Number</li>
<li>String</li>
<li>Boolean</li>
<li>Undefined</li>
<li>Null<h4 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h4>多个基本数据类型复合形成。</li>
<li>Object</li>
</ul>
<h2 id="存储方式"><a href="#存储方式" class="headerlink" title="存储方式"></a>存储方式</h2><h4 id="基本数据类型的存储方式"><a href="#基本数据类型的存储方式" class="headerlink" title="基本数据类型的存储方式"></a>基本数据类型的存储方式</h4><ul>
<li>每当定义一个基本数据类型的变量，会在 <strong>栈区</strong> 开辟一个内存空间，用于存放该变量。栈区的特点是：静态分配，大小固定。</li>
<li>当一个变量通过直接复制的方式复制给另一个变量，系统会在 <strong>栈区</strong>  重新开辟一个内存空间；两个变量互不影响。</li>
</ul>
<pre><code>let num1 = 10;
let num2 = num1;
num2 = 20;
console.log(num1);     // 10 
</code></pre><h4 id="引用类型的存储方式"><a href="#引用类型的存储方式" class="headerlink" title="引用类型的存储方式"></a>引用类型的存储方式</h4><ul>
<li>每当定义一个引用类型，如：对象，会在 <strong>堆区</strong> 开辟一个内存空间；然后如果创建一个该对象的实例，会在 <strong>栈区</strong> 开辟一个内存存放该实例，该实例实际上是一个指向 <strong>堆内存</strong> 对象的指针。堆区的特点是：动态分配，大小不固定。</li>
<li>当一个实例直接复制给另一个实例，系统会在 <strong>栈区</strong>  重新开辟一个内存空间，但是新实例同样也是一个指向  <strong>堆内存</strong> 对象的指针，所以，这样的操作，这样的修改都会对新旧实例产生影响。</li>
</ul>
<pre><code>let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}

//直接复制
let obj2 = obj1;

obj2.name = &#39;Ertsul&#39;;
obj2.num[0] = &#39;一&#39;;
console.log(obj1, obj2);
// name:&quot;Ertsul&quot;
// age:22
// num:[&quot;一&quot;, &quot;2&quot;, &quot;3&quot;]
</code></pre><h2 id="浅拷贝和深拷贝"><a href="#浅拷贝和深拷贝" class="headerlink" title="浅拷贝和深拷贝"></a>浅拷贝和深拷贝</h2><h4 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h4><p>两者的区别主要在于 <strong>复制层次</strong> 的不同：</p>
<ul>
<li>浅拷贝主要复制到对象属性这一层次，如果对象里面有子对象，则无法对子对象完成复制；之后对于子对象的修改 <strong>会</strong> 影响到原复制对象。</li>
<li>深拷贝则是浅拷贝的 <strong>加强版</strong> ，可以实现对于子对象的拷贝；之后对于子对象的修改 <strong>不会</strong> 影响到原复制对象。主要实现方法有：<ul>
<li>递归</li>
<li>JSON解析<h4 id="浅拷贝"><a href="#浅拷贝" class="headerlink" title="浅拷贝"></a>浅拷贝</h4></li>
</ul>
</li>
</ul>
<pre><code>// 浅拷贝
function shallowCopy(source) {
    let result = {};
    for(let key in source){
        result[key] = source[key]
    }
    return result;
}
let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}

let obj2 = {};
obj2 = shallowCopy(obj1);

obj2.name = &#39;Ertsul&#39;;    // 不会产生影响
obj2.num[0] = &#39;一&#39;;      // 产生影响
console.log(&quot;obj1&quot;, obj1);
console.log(&quot;obj2&quot;, obj2);
</code></pre><p>结果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-2238425cd781911c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="深拷贝"><a href="#深拷贝" class="headerlink" title="深拷贝"></a>深拷贝</h4><h5 id="递归"><a href="#递归" class="headerlink" title="递归"></a>递归</h5><pre><code>// 递归实现深拷贝
function deepCopy(source, res){
    var res = res || {};
    for(let i in source){
        if(typeof source[i] === &#39;object&#39;){
            if(source[i].constructor === Array){
                res[i] = []
            }else {
                res[i] = {}
            }
            deepCopy(source[i], res[i]);   // 递归子对象属性
        }else{
            res[i] = source[i]
        }
    }
    return res;
}

let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}

let result = {}
result = deepCopy(obj1, result);
result.name = &#39;Ertsul&#39;;
result.num[1] = &#39;二&#39;;
console.log(&quot;result&quot;, result);
console.log(&quot;obj1&quot;, obj1);
</code></pre><p>结果如图：</p>
<p><img src="http://upload-images.jianshu.io/upload_images/659084-522f00e896a05506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h5 id="JSON解析"><a href="#JSON解析" class="headerlink" title="JSON解析"></a>JSON解析</h5><pre><code>// JSON实现深拷贝
let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;]
}
let result1 = JSON.parse(JSON.stringify(obj1));
result1.num[2] = &#39;三&#39;;
console.log(&#39;result1&#39;, result1);
console.log(&#39;obj1&#39;, obj1);
</code></pre><p>结果如图：<br><img src="http://upload-images.jianshu.io/upload_images/659084-b747df9bb831bf93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
      </tags>
  </entry>
  <entry>
    <title>js/es6小知识大杂烩</title>
    <url>/2019/02/16/js-es6%E5%B0%8F%E7%9F%A5%E8%AF%86%E5%A4%A7%E6%9D%82%E7%83%A9/</url>
    <content><![CDATA[<h4 id="合并两个数组"><a href="#合并两个数组" class="headerlink" title="合并两个数组"></a>合并两个数组</h4><ul>
<li>数组的解构 <strong>[…arr1, …arr2]</strong></li>
<li>Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。</li>
<li>arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。</li>
</ul>
<pre><code>let arr1 = [1, 2, 3];
let arr2 = [4, 5, 6];
let arr3 = [...arr1,  ...arr2];
console.log(arr3);
Array.prototype.push.apply(arr1,  arr2);
console.log(arr1);
</code></pre><h4 id="arguments-伪数组-转化为数组"><a href="#arguments-伪数组-转化为数组" class="headerlink" title="arguments/伪数组 转化为数组"></a>arguments/伪数组 转化为数组</h4><ul>
<li>[…arguments]</li>
<li>Array.prototype.slice.call(arguments)</li>
</ul>
<pre><code>(function Fn() {
    let arr = [...arguments, &#39;Ertsul&#39;];
    console.log(arr);
})(&#39;zero&#39;);
(function Fn1() {
    let arr = Array.prototype.slice.call(arguments);
    console.log(arr);
})(&#39;zero&#39;);
</code></pre><h4 id="判断字符类型"><a href="#判断字符类型" class="headerlink" title="判断字符类型"></a>判断字符类型</h4><ul>
<li>Object.prototype.toString.call()</li>
<li>typeof</li>
<li>instanceof</li>
</ul>
<h4 id="创建实例的方法"><a href="#创建实例的方法" class="headerlink" title="创建实例的方法"></a>创建实例的方法</h4><ul>
<li>字面量 let obj = {…}</li>
<li>new Object()构造函数</li>
<li>构造函数</li>
<li>Object.create()</li>
<li>工厂模式</li>
</ul>
<pre><code>// 字面量
let obj1 = {
    name: &#39;zero&#39;,
    age: 22
};
// Object 构造函数
let obj2 = new Object();
obj2.name = &#39;zero&#39;;
console.log(obj2.name);
// 工厂模式
function Person(name) {
    let obj = new Object();
    obj.name = name;
    return obj;
}
let p1 = Person(&#39;zero&#39;);
console.log(p1.name);
// 构造函数
function Animal(name) {
    this.name = name;
}
let a2 = new Animal(&#39;dog&#39;);
console.log(a2.name);
</code></pre><h4 id="数组的拆解-flat"><a href="#数组的拆解-flat" class="headerlink" title="数组的拆解 flat"></a>数组的拆解 flat</h4><pre><code>let arr2 = [1, [2, 3, [100, 8989]], [4, 5, 6, 7, 8]];
const flat = arr =&gt; arr.toString().split(&#39;,).map(item =&gt; +item);
console.log(flat(arr2)); // [1, 2, 3, 100, 8989, 4, 5, 6, 7, 8]
</code></pre><h4 id="继承的方法-–-8种"><a href="#继承的方法-–-8种" class="headerlink" title="继承的方法 – 8种"></a>继承的方法 – 8种</h4><ul>
<li>通过原型继承<ul>
<li>缺点：引用类型存在共享问题。</li>
</ul>
</li>
</ul>
<pre><code>function Fn1() { ... }
function Fn2() { ... }
Fn2.prototype = new Fn1();
</code></pre><ul>
<li>构造函数：通过 <strong>call</strong> 更改 <strong>this</strong> 指向；实际上是调用了父类的构造函数。<ul>
<li>缺点：父类中的方法（构造函数中）子类不可见。</li>
</ul>
</li>
</ul>
<pre><code>function Fn1() { ... }
function Fn2() { 
  Fn1.call(this);   // 将 this 绑定到 Fn1
}
</code></pre><pre><code>function SuperType(){

}
SuperType.prototype.sayHi = function(){
    console.log(&#39;Hi&#39;);
}

function subType(){
    SuperType.call(this);
}

let superIns = new SuperType();
superIns.sayHi();   // Hi

let subIns = new subType();
subIns.sayHi();     // Uncaught TypeError
</code></pre><ul>
<li>组合继承（原型 + 构造）<br>属性通过构造函数继承；方法通过原型继承。记得要更改 <strong>Fn2.prototype.constructor</strong> 的指向，指向子类。</li>
</ul>
<pre><code>// 组合继承
function Fn1() {
    this.name = &#39;zero&#39;
}

Fn1.prototype.sayName = function () {
    console.log(this.name);
};

function Fn2() {
    // 继承属性
    Fn1.call(this);
    this.age = 22;
}
// 继承方法
Fn2.prototype = new Fn1();
Fn2.prototype.constructor = Fn2;   // 需要修复构造函数指向

Fn2.prototype.sayAge = function () {
    console.log(this.age);
};

let f = new Fn2();
f.sayName();
f.sayAge();
</code></pre><ul>
<li>实例继承<br>在一个函数内实例化，然后添加新属性，并返回该对象。</li>
</ul>
<pre><code>function Fn() { ... }
function Fn2(name) {
 let obj = new Fn();
 obj.name = name;
 return obj;
}
</code></pre><ul>
<li>原型式继承<br>将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。</li>
</ul>
<pre><code>function SuperType(name) {
    this.name = name
}

function Object(o){
    function F(){}
    F.prototype = o;
    return new F();
}

let subType = Object(new SuperType(&#39;zero&#39;));
console.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__
</code></pre><ul>
<li>拷贝继承<br>将原型/父类上的属性全部拷贝到子类上。</li>
</ul>
<pre><code>// 拷贝继承
function Fn1() {
    this.name = &#39;zero&#39;;
    this.age = 22
}
function Fn2() {
    let f1 = new Fn1();
    // 注意这里要用 in 操作符
    for (let item in f1) {
        Fn2.prototype[item] = f1[item];
    }
    Fn2.prototype.ownFun = function () {
        console.log(&#39;my own function.&#39;);
    }
}

let f = new Fn2();
console.log(f.name + &quot;, &quot; + f.age);
f.ownFun();
</code></pre><ul>
<li>寄生组合式模型<ul>
<li>通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。</li>
<li>通过构造函数实现属性的继承。</li>
</ul>
</li>
</ul>
<pre><code>// 寄生组合式继承
function inheritPrototype(subType, superType) {
    // 创建对象：新建的对象指向父类的原型
    let prototype = Object(superType.prototype);
    // 增强对象：新建对象的 constructor 指向子类
    prototype.constructor = subType;
    // 指定对象：子类的原型指向新建对象
    subType.prototype = prototype;
}

function Fn1() {
    this.name = &#39;Ertsul&#39;;
}

Fn1.prototype.sayName = function () {
    console.log(this.name);
};

function Fn2() {
    Fn1.call(this);
    this.age = 22;
}

inheritPrototype(Fn2, Fn1);

Fn2.prototype.sayAge = function () {
    console.log(this.age);
};

let f = new Fn2();
f.sayName();f.sayAge();
</code></pre><ul>
<li>es6 的 extends </li>
</ul>
<pre><code>// class
class F1 {
    constructor(name) {
        this.name = name;
    }
}

class F2 extends F1 {
    constructor(name, age){
        super(name);    // 调用父类的构造函数
        this.age = age;
    }
    showMsg(){
        console.log(this.name + &#39;, &#39; + this.age);
    }
}

let p = new F2(&#39;zero&#39;, 22);
p.showMsg();  // zero, 22
</code></pre><h4 id="比较两个对象是否相等"><a href="#比较两个对象是否相等" class="headerlink" title="比较两个对象是否相等"></a>比较两个对象是否相等</h4><ul>
<li>遍历对象对象进行判断。</li>
<li>将对象转化为字符串进行判断。</li>
</ul>
<pre><code>let obj1 = {
    name: &#39;a&#39;,
    age: 1
}
let obj2 = obj1;
let obj3 = {
    name: &#39;a&#39;,
    age: 2
}
console.log(JSON.stringify(obj1));
console.log(JSON.parse(JSON.stringify(obj1)));
console.log(JSON.stringify(obj1) == JSON.stringify(obj2));  // true
console.log(JSON.stringify(obj1) == JSON.stringify(obj3));  // false    
</code></pre><h4 id="封装一个时间函数，时间通过-time-传递，回调函数通过-then-函数执行"><a href="#封装一个时间函数，时间通过-time-传递，回调函数通过-then-函数执行" class="headerlink" title="封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行"></a>封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行</h4><pre><code>function time(time){
    return new Promise((resolve, reject) =&gt; {
        setTimeout(resolve, time);
    })
}

let t = new time(5000);
t.then((a, b) =&gt; {
    console.log(&#39;time&#39;);
})
</code></pre><h4 id="原型相关的API"><a href="#原型相关的API" class="headerlink" title="原型相关的API"></a>原型相关的API</h4><ul>
<li>Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例</li>
<li>Object.getPrototypeOf(p1)：获取原型</li>
<li>p1.hasOwnProperty(‘name’)：判断某个属性是否属于某个实例（只能获取属性实例）</li>
<li>in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中）</li>
</ul>
<pre><code>function Person(name, age) {
    this.name = name;
    this.age = age;
}

let p1 = new Person(&#39;Ertsul&#39;, 22);
console.log(Person.prototype);      // constructor f
console.log(Person.prototype.constructor);  // Person
console.log(Person.prototype.__proto__);    // constructor 的原型
console.log(p1.__proto__);      // // constructor f

console.log(Person.prototype.isPrototypeOf(p1));    // true
console.log(Person.isPrototypeOf(p1));      // false
console.log(Object.getPrototypeOf(p1));     // constructor f

console.log(p1.hasOwnProperty(&#39;name&#39;));     // true 存在实例中

Person.prototype.num = 100

console.log(p1.hasOwnProperty(&#39;num&#39;));      // fasle    存在原型中

console.log(&#39;num&#39; in p1);   // true 不管是实例还是原型中
</code></pre><h4 id="js-判断数组类型"><a href="#js-判断数组类型" class="headerlink" title="js 判断数组类型"></a>js 判断数组类型</h4><ul>
<li>arr instanceof Array</li>
<li>arr.constructor === Array</li>
</ul>
<pre><code>let arr = [1, 2, 3];
let obj = {}
function judgeFn(arr){
    // return arr.constructor === Array ? true : false
    return arr instanceof Array ? true : false
}
console.log(judgeFn(arr));  // true
console.log(judgeFn(obj )); // false
</code></pre><h4 id="日期格式化"><a href="#日期格式化" class="headerlink" title="日期格式化"></a>日期格式化</h4><pre><code>/* 日期格式化 */
function formatNumber(num) {
    const n = `${num}`;        // 转化为字符串
    return n[1] ? n : `0${n}`;
}
function formatTime(date){
    // 年 月 日
    const year = date.getFullYear();
    const month = date.getMonth() + 1;
    const day = date.getDate();
    // 时 分 秒
    const hour = date.getHours();
    const minute = date.getMinutes();
    const second = date.getSeconds();

    return `${[year, month, day].map(formatNumber).join(&#39;-&#39;)} ${[hour, minute, second].map(formatNumber).join(&#39;:&#39;)}`
}
let time = new Date();
console.log(time);        // Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间)
let t1 = formatTime(time);
console.log(t1);        // 2018-08-14 16:52:06
</code></pre><h4 id="字符串转化为标准日期格式"><a href="#字符串转化为标准日期格式" class="headerlink" title="字符串转化为标准日期格式"></a>字符串转化为标准日期格式</h4><pre><code>/* 字符串转化为标准日期格式 */
function time2string(str) {
    const chunks = str.split(&#39; &#39;);
    const date = chunks[0].split(&#39;-&#39;);
    const time = chunks[1].split(&#39;:&#39;);

    return new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]);
}
let str = &quot;2018-08-14 23:59:59&quot;;
let t2 = time2string(str);
console.log(t2);    // Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间)
</code></pre><h4 id="防抖节流"><a href="#防抖节流" class="headerlink" title="防抖节流"></a>防抖节流</h4><pre><code>/* 防抖节流 debounce throttle */
// 防抖 - 连续快速触发的解决方案
function debounce(fn, wait) {
    let timeout = null;    // 初始化 timer 定时器
    return function (){
        timeout &amp;&amp; clearTimeout(timeout);    // 清空定时器
        timeout = setTimeout(fn, wait);        // 设置定时器
    }
}
// 节流 - 一定时间内请求一次 -- 定时器法
function throttle1(fn, wait) {
    let timer = null;    // 初始化 timer 定时器
    return function () {
        let context = this;        // 保存上下文 this
        let args = arguments;    // 记录参数
        if(!timer) {    // 定时器为空
            timer = setTimeout(() =&gt; {
                fn.apply(context, args);
                timer = null;    // 清空定时器
            }, wait);
        }
    }
}
// 节流 - 一定时间内请求一次 -- 时间戳法
function throttle2(fn, wait) {
    let prev = Date.now();    // 记录前一个时间
    return function () {
        let context = this;        // 保存上下文 this
        let args = arguments;    // 记录参数
        let now = Date.now();     // 记录当前时间
        if(now - prev &gt;= wait){        // 时间戳大于设置的时间
            fn.apply(context, args);
            prev = Date.now();    // 记录前一个时间
        }
    }
}

// window.addEventListener(&#39;scroll&#39;, debounce(() =&gt; {
 //    console.log(Math.random());
// }, 500));
// window.addEventListener(&#39;scroll&#39;, throttle1(() =&gt; {
//     console.log(Math.random());
// }, 1000));
window.addEventListener(&#39;scroll&#39;, throttle2(() =&gt; {
    console.log(Math.random());
}, 1000))
</code></pre><ul>
<li>JSON.stringfy(obj, [replace, space])<ul>
<li>巧用第二个参数，可以实现json对象的过滤替换。</li>
<li>第三个参数，是缩进的空格数。    </li>
<li>如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。</li>
</ul>
</li>
</ul>
<pre><code>let obj1 = {
    name: &#39;zero&#39;,
    age: 22,
    hobby: &#39;ball&#39;
};

let str1 = JSON.stringify(obj1);
console.log(str1, typeof str1, str1.constructor === String);    // {&quot;name&quot;:&quot;zero&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;} string true
let str2 = JSON.stringify(obj1, (key, value) =&gt; {
    if(value === &#39;zero&#39;) {
        return &#39;Ertsul.&#39;
    }else {
        return value;
    }
});
console.log(str2);  // {&quot;name&quot;:&quot;Ertsul.&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;}

let obj2 = {
    num: 100,
    toJSON(){
        return &#39;apple&#39;
    }
};

let str3 = JSON.stringify(obj2);
console.log(str3);  // apple
</code></pre><ul>
<li>数组的 sort()<br>sort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。<br>如果要对数组的数字进行排序，则需要：<blockquote>
<p>array.sort((val1, val2) =&gt; {return val - val2});</p>
</blockquote>
</li>
</ul>
<p>通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。</p>
<pre><code>let arr10 = [1, 2, 19, 12, 22];
console.log(arr10.sort()); // [1, 12, 19, 2, 22]
console.log(arr10.sort((val1, val2) =&gt; {  // [1, 2, 12, 19, 22]
  return val1 - val2;
}));  
</code></pre><ul>
<li>reduce函数<blockquote>
<p>reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。</p>
</blockquote>
</li>
</ul>
<p>其完整的函数为： </p>
<pre><code>arr.reduce((prev, next, cur, srcArr) =&gt; {
  ......
}, initVal)
</code></pre><ul>
<li>prev: 上次返回的值</li>
<li>next: 下一个数组元素的值</li>
<li>cur: 当前数组元素的索引值</li>
<li>scrArr: 源数组</li>
<li>initVal: 设置第一次的 <strong>prev</strong></li>
</ul>
<p>例子 1：</p>
<pre><code>let arr = [&#39;apple&#39;, &#39;pear&#39;, &#39;bananas&#39;];
arr.reduce((prev, next, cur, arr) =&gt; {
  console.warn(prev, next, cur, arr);
  return next;
}, &#39;fruit&#39;)
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-65c2bd1bf155dfaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<p>例子 2：统计一个数组中单词出现的次数</p>
<pre><code>// 统计数组中单词出现的次数
let arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;bananas&quot;, &quot;bananas&quot;];
function getCount(arr) {
  return arr.reduce((prev, next, cur) =&gt; {
    prev[next] = (prev[next] + 1) || 1
    return prev;
  }, {})
}
console.warn(getCount(arr));  // {apple: 2, orange: 3, pear: 1, bananas: 2}
</code></pre><ul>
<li>Object.seal()<br>防止对象纂改：不能添加也不能删除属性</li>
</ul>
<pre><code>let obj = {
  name: &#39;Ersul&#39;
}
Object.seal(obj); // 防止对象纂改：不能删除也不能添加属性
delete obj.name;
console.warn(obj.name); // Ertsul
obj.age = 22;
console.warn(obj.age); // undefined
</code></pre><ul>
<li>Object.freeze()<br>冻结对象，不能修改对象任何属性的值。如若</li>
</ul>
<pre><code>let obj = {
  name: &#39;Ersul&#39;
}

Object.freeze(obj); // 冻结对象，不能修改属性的值
obj.name = &#39;Zero&#39;;
console.warn(obj.name); // Ertsul
</code></pre><ul>
<li>数组字符串的相互转化</li>
</ul>
<pre><code>// 数组 --&gt; 字符串 : join()
let arr3 = [1, 2, 3, 4, 5];
console.log(arr3.join(&#39;-&#39;));
// 字符串 --&gt; 数组 : split()
let str = &#39;apple,pear,bananas&#39;;
console.log(str.split(&#39;,&#39;));
</code></pre>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>js</category>
        <category>es6</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>js</tag>
        <tag>es6</tag>
      </tags>
  </entry>
  <entry>
    <title>webpack学习笔记</title>
    <url>/2019/02/16/webpack%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/</url>
    <content><![CDATA[<h2 id="项目构建"><a href="#项目构建" class="headerlink" title="项目构建"></a>项目构建</h2><ul>
<li>新建项目文件夹</li>
<li>npm init</li>
<li><p>设置项目目录结构，结构如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-bd9163add73e9ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
</li>
<li><p><strong>build</strong> 目录是 webpack 打包后的生成目录，<strong>index.html</strong> 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。</p>
</li>
<li><strong>src</strong> 目录是项目源文件，<strong>template.html</strong> 是 html 文件模板。</li>
<li><strong>webpack.config.js</strong> 是配置 <strong>webpack</strong> 的总文件。</li>
</ul>
<pre><code>module.exports = { ... }
</code></pre><h2 id="模式-mode"><a href="#模式-mode" class="headerlink" title="模式 mode"></a>模式 mode</h2><pre><code>mode: &quot;development&quot;, // development or production
</code></pre><h2 id="入口-entry"><a href="#入口-entry" class="headerlink" title="入口 entry"></a>入口 entry</h2><p>设置打包的入口文件, entry: filepath</p>
<pre><code>entry: &quot;./src/index.js&quot;, // 入口
</code></pre><h2 id="输出-output"><a href="#输出-output" class="headerlink" title="输出 output"></a>输出 output</h2><p>设置打包后的输出文件，output: { … }</p>
<pre><code>output: { // 输出
  filename: &quot;bundle.[hash:8].js&quot;,
  path: path.resolve(__dirname + &#39;/build&#39;),
  // publicPath: &quot;http://&quot;, // 公共路径前缀
},
</code></pre><p>注：</p>
<ul>
<li><strong>path</strong> 后面应是绝对路径。</li>
<li><strong>bundle.[hash:8].js</strong> 中的 <strong>[hash:8]</strong> 可以在每次打包后都在文件后面追加 hash 值。</li>
</ul>
<p>通过上面三项，可以实现一个简单的 <strong>webpack</strong> 打包配置。在 <strong>package.json</strong> 添加脚本或直接执行 <strong>./node_modules/.bin/webpack</strong> 即可实现打包：</p>
<pre><code>&quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;,
</code></pre><h2 id="webpack-dev-server"><a href="#webpack-dev-server" class="headerlink" title="webpack-dev-server"></a>webpack-dev-server</h2><p>webpack 开发服务器，用于开发时候的配置：</p>
<ul>
<li>yarn add taco –dev webpack-dev-server / npm install –save-dev webpack-dev-server</li>
<li>基本配置如下：</li>
</ul>
<pre><code>devServer: { // 开发服务器
  port: 3001,
  contentBase: path.resolve(__dirname + &#39;/build&#39;), // 本地服务器目录
  progress: true, // 进度条
  open: true, // 自动打开浏览器
  compress: true, // 压缩
  // 1. 代理
  proxy: {
    &quot;/api&quot;: {
      target: &quot;&quot;,
      pathRewrite: {
        &quot;/api&quot;: &quot;&quot;
      }
    }
  },
  // 2. 用 express 内置钩子模拟数据
  before(app) {
    app.get(&quot;/api&quot;, (req, res) =&gt; { ... })
  },
  // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件
},
},
</code></pre><ul>
<li>在 <strong>package.json</strong> 添加脚本即可：</li>
</ul>
<pre><code>&quot;dev&quot;: &quot;webpack-dev-server&quot;
</code></pre><h2 id="source-map-amp-amp-eval-source-map-amp-amp-cheap-module-source-map-amp-amp-cheap-module-eval-source-map"><a href="#source-map-amp-amp-eval-source-map-amp-amp-cheap-module-source-map-amp-amp-cheap-module-eval-source-map" class="headerlink" title="source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map"></a>source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map</h2><p>作用：源码映射，报错时显示出错的位置。</p>
<ul>
<li>source-map：会单独生成一个 <strong>sourcemap</strong> 文件；会显示行列。</li>
<li>eval-source-map：不会单独生成一个 <strong>sourcemap</strong> 文件，会将生成的 <strong>sourcemap</strong> 放到打包后的 <strong>html</strong> 文件；会显示行和列。</li>
<li>cheap-module-source-map：会生成 <strong>sourcemap</strong> 文件，不会显示列。</li>
<li>cheap-module-eval-source-map：不会生成 <strong>sourcemap</strong> 文件，集成在 <strong>html</strong> 文件中，不会显示列。</li>
</ul>
<pre><code>devtool: &quot;source-map&quot;, // 源码映射
</code></pre><h2 id="watch"><a href="#watch" class="headerlink" title="watch"></a>watch</h2><p>作用：监控代码实时变化，进行编译打包。</p>
<pre><code>watch: true, // 监控代码实时变化，进行编译打包
watchOptions: {
  poll: 1000, // 多毫秒监控一次
  aggreatement: 500, // 防抖
  ignored: &quot;node_modules&quot; // 忽略文件夹
},
</code></pre><h2 id="resolve"><a href="#resolve" class="headerlink" title="resolve"></a>resolve</h2><p>作用：解析第三方包</p>
<pre><code>resolve: { // 解析 第三方包
  modules: [
    path.resolve(&quot;node_modules&quot;), // 在当前目录下查找模块 
    path.resolve(&quot;other_modules&quot;), // 在其他目录下查找模块 
  ],
  // 自动添加扩展名，主要是 import 时候使用, 依次解析
  extensions: [&quot;.js&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.vue&quot;],
  // 比如引用 bootstrap 的 css 样式
  // 方式一： bootstrap 的主入口
  mainFields: [&quot;style&quot;, &quot;main&quot;],
  // 方式二：别名  
  // alias: {
  //   bootstrap: &quot;bootstrap/dist/css/bootstrap.css&quot;
  // }
},
</code></pre><h2 id="插件"><a href="#插件" class="headerlink" title="插件"></a>插件</h2><p>webpack 的插件配置是一个数组，里面存放着各种各样的插件。</p>
<pre><code>plugins: [
 new pluginName(...)
]
</code></pre><h4 id="html-webpack-plugin"><a href="#html-webpack-plugin" class="headerlink" title="html-webpack-plugin"></a>html-webpack-plugin</h4><p>插件作用：打包时候自动根据 <strong>html</strong> 模板生成目标 <strong>html</strong> 文件，自动生成目标打包目录；另外，可配置 <strong>html</strong> 的相关打包配置，如：压缩，去双引号等。</p>
<pre><code>new HtmlWebpackPlugin({
  filename: &quot;index.html&quot;, // 目标文件名称
  template: path.resolve(__dirname + &#39;/src/template.html&#39;), // 模板文件
  minify: { // 压缩配置
    removeAttributeQuotes: true, // 去双引号
    collapseWhitespace: true, // 不换行
  },
  hash: true // 生成 hash 戳
})
</code></pre><h4 id="mini-css-extract-plugin"><a href="#mini-css-extract-plugin" class="headerlink" title="mini-css-extract-plugin"></a>mini-css-extract-plugin</h4><p>作用：将生成的 <strong>css样式</strong> 抽离成一个 <strong>css文件</strong>，并将该样式文件引进目标 <strong>html</strong> 文件中。</p>
<pre><code>plugins: [ // 插件
  new MiniCssExtractPlugin({
    filename: &quot;main.css&quot;,
  })
],
module: { // 模块
  rules: [{
    test: /\.css$/,
    use: [
      // {
      //   loader: &quot;style-loader&quot;,
      //   options: {
      //     insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级
      //   }
      // },
      MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序
      &quot;css-loader&quot;
    ]
  }]
}
</code></pre><p>注：这里抽离出来的 <strong>main.css</strong> 文件并没有压缩，要通过手动添加以下两个插件到优化项：</p>
<ul>
<li>optimize-css-assets-webpack-plugin</li>
<li>uglifyjs-webpack-plugin</li>
</ul>
<pre><code>optimization: { // 优化项
  minimizer: [
    new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件
    new UglifyjsWebpackPlugin({
      cache: true,
      parallel: true,
    }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置
  ]
},
</code></pre><h4 id="optimize-css-assets-webpack-plugin"><a href="#optimize-css-assets-webpack-plugin" class="headerlink" title="optimize-css-assets-webpack-plugin"></a>optimize-css-assets-webpack-plugin</h4><p>插件作用：压缩抽离出来的 <strong>main.css</strong> 文件。但是，使用了 <strong>optimize-css-assets-webpack-plugin</strong> 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 <strong>uglifyjs-webpack-plugin</strong> 。</p>
<h4 id="uglifyjs-webpack-plugin"><a href="#uglifyjs-webpack-plugin" class="headerlink" title="uglifyjs-webpack-plugin"></a>uglifyjs-webpack-plugin</h4><p>插件作用：压缩打包后的 <strong>js</strong> 文件。</p>
<h4 id="clean-webpack-plugin"><a href="#clean-webpack-plugin" class="headerlink" title="clean-webpack-plugin"></a>clean-webpack-plugin</h4><p>作用：清理文件</p>
<pre><code>plugins: [
 new CleanWebpackPlugin(&quot;./build&quot;)
]
</code></pre><h4 id="copy-webpack-plugin"><a href="#copy-webpack-plugin" class="headerlink" title="copy-webpack-plugin"></a>copy-webpack-plugin</h4><p>作用：将某些文件拷贝到打包后的文件夹。</p>
<pre><code>new CopyWebpackPlugin([
  {from: &quot;./copy&quot;, to: &quot;./&quot;}
])
</code></pre><h4 id="banner-plugin"><a href="#banner-plugin" class="headerlink" title="banner-plugin"></a>banner-plugin</h4><p>作用：版权声明，是 <strong>webpack</strong> 的内置模块。</p>
<pre><code>new webpack.BannerPlugin(&quot;@copyright by Ertsul&quot;)
</code></pre><h4 id="webpack-DefinePlugin-…"><a href="#webpack-DefinePlugin-…" class="headerlink" title="webpack.DefinePlugin({ … })"></a>webpack.DefinePlugin({ … })</h4><p>作用：定义环境变量。</p>
<pre><code>plugins: [
  new webpack.DefinePlugin({
    DEV: JSON.stringify(&quot;development&quot;),
    PRO: JSON.stringify(&quot;production&quot;)
  })
]
</code></pre><h4 id="webpacfk-IgnorePlugin"><a href="#webpacfk-IgnorePlugin" class="headerlink" title="webpacfk.IgnorePlugin()"></a>webpacfk.IgnorePlugin()</h4><p>作用：忽略模块的引进</p>
<pre><code>plugins: [
  new webpack.IgnorePlugin(/\./locale/, /moment/)
]
</code></pre><p>注：如果直接使用 <strong>DEV: ‘development’</strong> 的话，会把 <strong>DEV</strong> 直接替换为 <strong>引号内部的内容</strong>。如：<strong>console.log(DEV)</strong>，会变成 <strong>console.log(dev)</strong>，最后的结果是 <strong>undefined</strong>。所以，需要通过 <strong>JSON.stringfy()</strong> 进行转化。</p>
<h2 id="模块-module"><a href="#模块-module" class="headerlink" title="模块 module"></a>模块 module</h2><p>模块主要是各种 <strong>loader</strong>，作用：解析各种类型的文件。</p>
<pre><code>module: { 
 rules: [
   {
     test: regx,
     use: [loadName]
   }
 ]
}
</code></pre><h4 id="css-loader-style-loader"><a href="#css-loader-style-loader" class="headerlink" title="css-loader / style-loader"></a>css-loader / style-loader</h4><ul>
<li>css-loader：主要是用于解析在 <strong>css</strong> 文件中通过 <strong>@import</strong> 方式引进其他的 <strong>css</strong> 文件。</li>
<li>style-loader: 主要是用于将 <strong>js</strong> 文件中通过 <strong>require</strong> 方式引进的 <strong>css</strong> 文件插入到目标 <strong>html</strong> 文件的 <strong>head</strong> 中（插到最后，层级最高）。</li>
</ul>
<pre><code>// 数组方式
module: { // 模块
  rules: [{
    test: /\.css$/, // 正则
    use: [&quot;style-loader&quot;, &quot;css-loader&quot;] // loader 数组
  }]
}
// 对象方式
module: { // 模块
  rules: [{
    test: /\.css$/, // 正则
    use: [
      {
        loader: &quot;style-loader&quot;,
        options: {
          insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级
        }
      }, 
      &quot;css-loader&quot;
    ]
  }]
}
</code></pre><p>注：<strong>loader</strong> 是从右向左、从下到上的执行顺序，故：<strong>use: [“style-loader”, “css-loader”]</strong></p>
<h4 id="postcss-loader-autoprefixer"><a href="#postcss-loader-autoprefixer" class="headerlink" title="postcss-loader + autoprefixer"></a>postcss-loader + autoprefixer</h4><p>这两个的配合使用可以自动添加 <strong>css</strong> 的浏览器前缀。</p>
<ul>
<li>autoprefixer：自动添加 <strong>css</strong> 的浏览器前缀。</li>
<li>postcss-loader：loader 处理 autoprefixer。</li>
</ul>
<pre><code>// 使用 postcss-loader 
module: { // 模块
  rules: [{
    test: /\.css$/,
    use: [
      // {
      //   loader: &quot;style-loader&quot;,
      //   options: {
      //     insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级
      //   }
      // },
      MiniCssExtractPlugin.loader,
      &quot;css-loader&quot;,
      &quot;postcss-loader&quot; // 注意顺序
    ]
  }]
}
</code></pre><ul>
<li>根目录下新建 postcss.config.js 文件</li>
</ul>
<pre><code>module.exports = {
  plugins: [
    require(&quot;autoprefixer&quot;)
  ]
}
</code></pre><h4 id="babel-loader-babel-core-babel-preset-env"><a href="#babel-loader-babel-core-babel-preset-env" class="headerlink" title="babel-loader + @babel/core + @babel/preset-env"></a>babel-loader + @babel/core + @babel/preset-env</h4><p>作用：转化 es6 语法</p>
<pre><code>module: { // 模块
  rules: [{
    test: /\.js$/,
    use: {
      loader: &quot;babel-loader&quot;,
      options: { // 用 babel-loader 需要把 es6 转化为 es5
        presets: [
          &quot;@babel/preset-env&quot;, // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块
        ],
        // plugins: [...] // 其他的小插件
      }
    }
  }]
}
</code></pre><h4 id="expose-loader"><a href="#expose-loader" class="headerlink" title="expose-loader"></a>expose-loader</h4><p>作用：暴露全局的 <strong>loader</strong>，暴露到 <strong>window</strong> 上。</p>
<pre><code>// 一般情况
import $ from &#39;jquery&#39;;
console.log(window.$); // undefined
// 内联 loader 方式
import $ from &#39;expose-loader?$!jquery&#39;;
console.log(window.$);
// 其他方式：在每个模块中注入
new webpack.ProvidePlugin({
  $: &quot;jquery&quot;
})
console.log($);
console.log(window.$); // undefined
</code></pre><h4 id="file-loader-amp-amp-url-loader-amp-amp-html-withimg-loader"><a href="#file-loader-amp-amp-url-loader-amp-amp-html-withimg-loader" class="headerlink" title="file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader"></a>file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader</h4><p>在 <strong>webpack</strong> 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。</p>
<ul>
<li>file-loader：<strong>js</strong> 文件中通过 <strong>import</strong> 方式引进图片。</li>
<li>html-withimg-loader：<strong>html</strong> 文件中通过 <strong>scr</strong> 方式引进图片。</li>
<li>在 <strong>css</strong> 中使用图片，<strong>style-loader</strong> 已经做了处理。</li>
<li>url-loader：将图片转化为 <strong>base64</strong></li>
</ul>
<pre><code>module: {
  rules: [
    {
      test: /\.(png|jpg|gif)$/,
      use: {
        loader: &quot;url-loader&quot;,
        options: {
          limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader
          // publicPath: &quot;http://&quot;, // 公共路径前缀
        }
      }
    },
    {
      test: /\.html$/,
      use: [&quot;html-withimg-loader&quot;]
    }
  ]
}
</code></pre><p>`</p>
<h2 id="模块-module-–-noParse"><a href="#模块-module-–-noParse" class="headerlink" title="模块 module – noParse"></a>模块 module – noParse</h2><p>作用：不解析指定包的依赖关系。</p>
<pre><code>module: {
  noParse: /jquery/
}
</code></pre><h2 id="模块-module-–-exclude"><a href="#模块-module-–-exclude" class="headerlink" title="模块 module – exclude"></a>模块 module – exclude</h2><p>作用：排除</p>
<pre><code>module: {
  exclude: /node_module/
}
</code></pre><h2 id="模块-module-–-include"><a href="#模块-module-–-include" class="headerlink" title="模块 module – include"></a>模块 module – include</h2><p>作用：包含</p>
<pre><code>module: {
  include: /src/
}
</code></pre><h2 id="区分不同环境，实现开发和生产配置的分离"><a href="#区分不同环境，实现开发和生产配置的分离" class="headerlink" title="区分不同环境，实现开发和生产配置的分离"></a>区分不同环境，实现开发和生产配置的分离</h2><p>将 <strong>webpack</strong> 的配置文件划分为以下文件：</p>
<ul>
<li>webpack.base.js：基本、共有的配置。</li>
<li>webpack.dev.js：开发配置。</li>
<li>webpack.prod.js：生产配置。</li>
</ul>
<p>使用 <strong>webpack-merger</strong> 插件：</p>
<ul>
<li>安装 <strong>webpack-merge</strong> 插件；</li>
<li>引进目标模块</li>
</ul>
<pre><code>import { smart } from &quot;webpack-merge&quot;;
</code></pre><ul>
<li>使用</li>
</ul>
<pre><code>const base = require(&quot;webpack.base.js);

module.exports = smart(base, {
  ...
})
</code></pre><h2 id="webpack-自带优化"><a href="#webpack-自带优化" class="headerlink" title="webpack 自带优化"></a>webpack 自带优化</h2><ul>
<li><strong>import</strong> 语法（生成环境），<strong>tree-shaking</strong> 自动删除没有用到的代码；</li>
<li><strong>es6</strong> 模块会把语法放到 <strong>default</strong> 上；</li>
<li>自动省略可以简化的代码；</li>
<li><strong>scope hosting</strong>，作用域提升。</li>
</ul>
<h2 id="webpack-懒加载"><a href="#webpack-懒加载" class="headerlink" title="webpack 懒加载"></a>webpack 懒加载</h2><ul>
<li>通过 <strong>import</strong> 实现（该语法内部由 <strong>jsonp</strong> 实现），返回的是一个 <strong>promise</strong>。</li>
<li>要在 <strong>babel-loader</strong> 中添加 <strong>@babel/plugin-syntax-dynamic-import</strong> 插件。</li>
<li><strong>vue</strong> 和 <strong>react</strong> 的l懒加载都是这样实现的。</li>
</ul>
<pre><code>/*
* 模拟点击加载 source.js 的内容
*/
// 1
{
  loader: &#39;babel-loader&#39;,
  options: {
    presets: [
      &#39;@babel/preset-env&#39;
    ],
    plugins: [
      &#39;@babel/plugin-syntax-dynamic-import&#39;
    ]
  },
}
// 2
let btn = document.createElement(&#39;button&#39;);
btn.innerHTML = &#39;btn&#39;;
btn.addEventListener(&#39;click&#39;, function () {
  // 内部由 jsonp 实现动态加载文件
  import(&#39;./source.js&#39;)
    .then(data =&gt; {
      console.log(data);
    })
})
document.body.appendChild(btn);

</code></pre><p>点击按钮后结果如下：<br><img src="http://upload-images.jianshu.io/upload_images/659084-fa79ce43578285a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h2 id="热更新-热替换-Hot-Module-Replacement-HMR"><a href="#热更新-热替换-Hot-Module-Replacement-HMR" class="headerlink" title="热更新 / 热替换 / Hot Module Replacement / HMR"></a>热更新 / 热替换 / Hot Module Replacement / HMR</h2><p>热更新：页面只更新改动的模块。</p>
<ul>
<li><strong>devServer</strong> 开始 <strong>hot</strong> 热更新模块。</li>
<li>使用 <strong>webpack</strong> 内置热更新插件。<ul>
<li>NamedModulesPlugin</li>
<li>HotModuleReplacementPlugin</li>
</ul>
</li>
</ul>
<pre><code>// devServer 配置
devServer: {
  port: 8089,
  contentBase: path.resolve(__dirname + &#39;/dist/&#39;),
  compress: true,
  progress: true,
  // open: true
  hot: true, // 开启热更新，只更新更改的模块
},
// 添加插件
plugins: [
  new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径
  new webpack.HotModuleReplacementPlugin(), // 热更新
]
</code></pre><ul>
<li>使用热更新</li>
</ul>
<pre><code>import source from &#39;./source.js&#39;;

console.log(source);

// 添加热更新操作，不然不会实现热更新
if (module.hot) {
module.hot.accept(&#39;./source.js&#39;, () =&gt; {
  require(&#39;./source.js&#39;);
})
</code></pre><h2 id="多线程打包"><a href="#多线程打包" class="headerlink" title="多线程打包"></a>多线程打包</h2><p>使用 <strong>happypack</strong> 可以实现多线程打包。</p>
<ul>
<li>安装并引进 <strong>happypack</strong>;</li>
<li>改写 <strong>module</strong>;</li>
<li><strong>plugin</strong> 配置。</li>
</ul>
<pre><code>// 改写 module
module: {
  rules: [
    {
      test: /\.js$/,
      // use: {
      //   loader: &#39;babel-loader&#39;,
      //   options: {
      //     presets: [
      //       &#39;@babel/preset-env&#39;
      //     ]
      //   }
      // }
      use: {
        loader: &#39;Happypack/loader?id=js&#39;,
      }
    },
  ]
}
// plugin 配置
plugins: [
  new Happypack({
    id: &#39;js&#39;,
    use: [
      {
        loader: &#39;babel-loader&#39;,
        options: {
          presets: [
            &#39;@babel/preset-env&#39;
          ]
        }
      }
    ]
  }),
]
</code></pre><h2 id="多页面打包"><a href="#多页面打包" class="headerlink" title="多页面打包"></a>多页面打包</h2><pre><code>const path = require(&quot;path&quot;);
const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);

module.exports = {
  mode: &quot;production&quot;,
  entry: {
    home: &quot;./src/home.js&quot;,
    about: &quot;./src/about.js&quot;,
    other: &quot;./src/other.js&quot;
  },
  output: {
    path: path.resolve(__dirname + &quot;/build/&quot;),
    filename: &quot;[name].js&quot;,
  },
  plugins: [
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname + &quot;/src/template.html&quot;),
      filename: &quot;home.html&quot;,
      chunks: [&quot;home&quot;]
    }),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname + &quot;/src/template.html&quot;),
      filename: &quot;other.html&quot;,
      chunks: [&quot;other&quot;]
    }),
    new HtmlWebpackPlugin({
      template: path.resolve(__dirname + &quot;/src/template.html&quot;),
      filename: &quot;about.html&quot;,
      chunks: [&quot;about&quot;]
    }),
  ]
}
</code></pre><h2 id="多页面打包抽离公共代码块"><a href="#多页面打包抽离公共代码块" class="headerlink" title="多页面打包抽离公共代码块"></a>多页面打包抽离公共代码块</h2><p>打包 <strong>多页面</strong> 需要将公共的代码块抽离出来进行优化：</p>
<pre><code>optimation: {
  splitChunks: {  // 分割代码块
    cacheGroups: {  // 缓存组
      common: {  // 公共的模块
        chunks: &#39;initial&#39;,  // 从哪里开始，initial 即：入口
        miniSize: 0,  // 大小大于多少字节的时候抽离
        miniChunks: 2  // 引用多少次的时候抽离
      },
      vender: {  // 第三方模块
        priority: 1,  // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用
        test: /node_modules/,  // 抽离出来
        chunks: &#39;initial&#39;,  // 从哪里开始，initial 即：入口
        miniSize: 0,  // 大小大于多少字节的时候抽离
        miniChunks: 2  // 引用多少次的时候抽离
      }
    }
  }
}
</code></pre><h2 id="Tapable"><a href="#Tapable" class="headerlink" title="Tapable"></a>Tapable</h2><p><strong>webpack</strong> 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 <strong>Tapable</strong>，通过 <strong>Tapable</strong> 实现各种钩子（如同步钩子异步钩子）。而 <strong>Tapable</strong> 核心是依赖于 <strong>发布订阅者模式</strong>。</p>
<ul>
<li>同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 <strong>tap</strong> 注册。</li>
</ul>
<p>使用：</p>
<pre><code>const { SyncHook } = require(&#39;tapable&#39;);

class Hook {
  constructor() {
    this.hooks = {
      arch: new SyncHook([&#39;name&#39;])
    }
  }
  tap() { // 注册监听事件
    this.hooks.arch.tap(&#39;vue&#39;, (name) =&gt; {
      console.log(&#39;vue&#39;, name);
    })
    this.hooks.arch.tap(&#39;react&#39;, (name) =&gt; {
      console.log(&#39;react&#39;, name);
    })
  }
  start() { // 开始
    this.hooks.arch.call(&#39;Ertsul&#39;)
  }
}
let h = new Hook();
h.tap();
h.start();
</code></pre><ul>
<li>异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 <strong>tapAsync</strong> 注册。</li>
</ul>
<p>setTimeout()方式使用：</p>
<pre><code>const { AsyncParallelHook } = require(&#39;tapable&#39;);

class AsyncHook {
  constructor() {
    this.hooks = {
      arch: new AsyncParallelHook([&#39;name&#39;])
    }
  }
  tap() {
    this.hooks.arch.tapAsync(&#39;vue&#39;, (name, cb) =&gt; {
      setTimeout(() =&gt; {
        console.log(&#39;vue&#39;, name);
        cb &amp;&amp; cb();
      }, 1000)
    })
    this.hooks.arch.tapAsync(&#39;react&#39;, (name, cb) =&gt; {
      setTimeout(() =&gt; {
        console.log(&#39;react&#39;, name);
        cb &amp;&amp; cb();
      }, 1000)
    })
  }
  start() {
    this.hooks.arch.callAsync(&#39;Ertsul&#39;, () =&gt; {
      console.log(&#39;All finished!&#39;);
    })
  }
}

const a = new AsyncHook();
a.tap();
a.start();
</code></pre><p>Promise()方式使用：</p>
<pre><code>const { AsyncParallelHook } = require(&#39;tapable&#39;);

class AsyncHook {
  constructor() {
    this.hooks = {
      arch: new AsyncParallelHook([&#39;name&#39;])
    }
  }
  tap() {
    this.hooks.arch.tapPromise(&#39;vue&#39;, (name) =&gt; {
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          console.log(&#39;vue&#39;, name);
          resolve();
        }, 1000)
      })
    })
    this.hooks.arch.tapPromise(&#39;react&#39;, (name) =&gt; {
      return new Promise((resolve, reject) =&gt; {
        setTimeout(() =&gt; {
          console.log(&#39;react&#39;, name);
          resolve();
        }, 1000)
      })
    })
  }
  start() {
    this.hooks.arch.promise(&#39;Ertsul&#39;).then(() =&gt; {
      console.log(&#39;hook all finished!&#39;);
    })
  }
}

const a = new AsyncHook();
a.tap();
a.start();
</code></pre><h4 id="Synchook-同步钩子"><a href="#Synchook-同步钩子" class="headerlink" title="Synchook 同步钩子"></a>Synchook 同步钩子</h4><p>实现：</p>
<pre><code>class Synchook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tap(name, task) { //  注册事件
    this.tasks.push(task);
  }
  call(...args) { // 发布事件
    this.tasks.forEach(task =&gt; {
      task(...args);
    })
  }
}

let hook = new Synchook([&#39;Synchook&#39;]);
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
})
hook.tap(&#39;react&#39;, (name) =&gt; {
  console.log(&#39;react&#39;, name);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-1d12026d2f938c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="SyncBailHook-同步熔断钩子"><a href="#SyncBailHook-同步熔断钩子" class="headerlink" title="SyncBailHook 同步熔断钩子"></a>SyncBailHook 同步熔断钩子</h4><p>Synchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。</p>
<p>实现：</p>
<pre><code>// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数
class Syncbailhook {
  constructor(args) {
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    let ret = &#39;&#39;; // 当前函数的返回值
    let index = 0; // 当前任务数组的索引
    do {
      ret = this.tasks[index++](...args);
    } while (ret === undefined &amp;&amp; index &lt; this.tasks.length)
  }
}

let hook = new Syncbailhook([&#39;Syncbailhook&#39;]);
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
})
hook.tap(&#39;react&#39;, (name) =&gt; {
  console.log(&#39;react&#39;, name);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-3a46a477c8b08d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="SyncWaterfallHook-同步瀑布钩子"><a href="#SyncWaterfallHook-同步瀑布钩子" class="headerlink" title="SyncWaterfallHook 同步瀑布钩子"></a>SyncWaterfallHook 同步瀑布钩子</h4><p>Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。</p>
<p>实现：</p>
<pre><code>/**
 * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系
 * 上一个函数的执行返回结果在当前函数的输入
 */
class Syncwaterfallhook {
  constructor(args) {
    this.tasks = [];
  }
  tap(name, task) {
    this.tasks.push(task);
  }
  call(...args) {
    let [first, ...others] = this.tasks;
    let ret = first(...args);
    others.reduce((prev, current) =&gt; {
      return current(prev);
    }, ret)
  }
}

let hook = new Syncwaterfallhook([&#39;Syncwaterfallhook&#39;]);
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
  return &#39;vue learnt&#39;;
})
hook.tap(&#39;react&#39;, (data) =&gt; {
  console.log(&#39;react&#39;, data);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-5ccbc856cac523cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="SyncLoopHook-同步循环钩子"><a href="#SyncLoopHook-同步循环钩子" class="headerlink" title="SyncLoopHook 同步循环钩子"></a>SyncLoopHook 同步循环钩子</h4><p>同步循环钩子回让某个函数执行一定的次数。</p>
<p>实现：</p>
<pre><code>// Tapable Syncloophook 同步循环钩子
class Syncloophook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tap(name, task) { //  注册事件
    this.tasks.push(task);
  }
  call(...args) { // 发布事件
    this.tasks.forEach(task =&gt; {
      let ret = &#39;&#39;;
      do {
        ret = task(...args);
      } while (ret != undefined);
    })
  }
}

let hook = new Syncloophook([&#39;Syncloophook&#39;]);
const total = 3;
let index = 0;
hook.tap(&#39;vue&#39;, (name) =&gt; {
  console.log(&#39;vue&#39;, name);
  return ++index === total ? undefined : &#39;continue&#39;;
})
hook.tap(&#39;react&#39;, (name) =&gt; {
  console.log(&#39;react&#39;, name);
})
hook.call(&#39;Ertsul&#39;);
</code></pre><p><img src="http://upload-images.jianshu.io/upload_images/659084-fd5d933715541d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240" alt="image.png"></p>
<h4 id="AsyncParallelHook-异步并发钩子-回调函数方式"><a href="#AsyncParallelHook-异步并发钩子-回调函数方式" class="headerlink" title="AsyncParallelHook 异步并发钩子 回调函数方式"></a>AsyncParallelHook 异步并发钩子 回调函数方式</h4><p>实现：</p>
<pre><code>// Tapable Asynchook 异步钩子
class asyncparallelhook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tapAsync(name, task) { //  注册事件
    this.tasks.push(task);
  }
  callAsync(...args) { // 发布事件
    let finalCallback = args.pop();
    let index = 0;
    const done = () =&gt; {
      index++;
      if (index === this.tasks.length) {
        finalCallback();
      }
    }
    this.tasks.forEach(task =&gt; {
      task(...args, done);
    })
  }
}

let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]);
hook.tapAsync(&#39;vue&#39;, (name, cb) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#39;vue&#39;, name);
    cb &amp;&amp; cb();
  }, 1000)
})
hook.tapAsync(&#39;react&#39;, (name, cb) =&gt; {
  setTimeout(() =&gt; {
    console.log(&#39;react&#39;, name);
    cb &amp;&amp; cb();
  }, 1000)
})
hook.callAsync(&#39;Ertsul&#39;, () =&gt; {
  console.log(&#39;All hook finished!&#39;);
});
</code></pre><h4 id="AsyncParallelHook-异步并发钩子-Promise方式"><a href="#AsyncParallelHook-异步并发钩子-Promise方式" class="headerlink" title="AsyncParallelHook 异步并发钩子 Promise方式"></a>AsyncParallelHook 异步并发钩子 Promise方式</h4><p>实现：</p>
<pre><code>// Tapable Asynchook 异步钩子
class asyncparallelhook {
  constructor(args) { // args =&gt; [&#39;Synchook&#39;]
    this.tasks = []; // 注册事件数组
  }
  tapPromise(name, task) { //  注册事件
    this.tasks.push(task);
  }
  promise(...args) { // 发布事件
    let tasks = this.tasks.map(task =&gt; task(...args));
    return Promise.all(tasks);
  }
}

let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]);
hook.tapPromise(&#39;vue&#39;, (name) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#39;vue&#39;, name);
      resolve();
    }, 1000)
  })
})
hook.tapPromise(&#39;react&#39;, (name) =&gt; {
  return new Promise((resolve, reject) =&gt; {
    setTimeout(() =&gt; {
      console.log(&#39;react&#39;, name);
      resolve();
    }, 1000)
  })
})
hook.promise(&#39;Ertsul&#39;).then(() =&gt; {
  console.log(&#39;All hooks finished!&#39;);
})
</code></pre><h4 id="AsyncSeriesHook-异步串行钩子"><a href="#AsyncSeriesHook-异步串行钩子" class="headerlink" title="AsyncSeriesHook 异步串行钩子"></a>AsyncSeriesHook 异步串行钩子</h4><h4 id="AsyncWaterfallHook-异步瀑布流钩子"><a href="#AsyncWaterfallHook-异步瀑布流钩子" class="headerlink" title="AsyncWaterfallHook 异步瀑布流钩子"></a>AsyncWaterfallHook 异步瀑布流钩子</h4>]]></content>
      <categories>
        <category>frontEnd</category>
        <category>webpack</category>
      </categories>
      <tags>
        <tag>frontEnd</tag>
        <tag>webpack</tag>
      </tags>
  </entry>
</search>
