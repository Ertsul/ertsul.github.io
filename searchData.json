[{"title":"webpack学习笔记","url":"/2019/02/16/webpack学习笔记/","content":"\n## 项目构建\n- 新建项目文件夹\n- npm init\n- 设置项目目录结构，结构如下：\n\n  <img src=\"https://upload-images.jianshu.io/upload_images/659084-bd9163add73e9ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240\" width=\"180px\" height=\"260px\">\n\n- **build** 目录是 webpack 打包后的生成目录，**index.html** 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。\n- **src** 目录是项目源文件，**template.html** 是 html 文件模板。\n- **webpack.config.js** 是配置 **webpack** 的总文件。\n\n```\nmodule.exports = { ... }\n```\n\n## 模式 mode\n\n```\nmode: \"development\", // development or production\n```\n\n## 入口 entry\n设置打包的入口文件, entry: filepath\n\n```\nentry: \"./src/index.js\", // 入口\n```\n\n## 输出 output\n设置打包后的输出文件，output: { ... }\n\n```\noutput: { // 输出\n  filename: \"bundle.[hash:8].js\",\n  path: path.resolve(__dirname + '/build'),\n  // publicPath: \"http://\", // 公共路径前缀\n},\n```\n注：\n- **path** 后面应是绝对路径。\n- **bundle.[hash:8].js** 中的 **[hash:8]** 可以在每次打包后都在文件后面追加 hash 值。\n\n通过上面三项，可以实现一个简单的 **webpack** 打包配置。在 **package.json** 添加脚本或直接执行 **./node_modules/.bin/webpack** 即可实现打包：\n\n```\n\"build\": \"./node_modules/.bin/webpack\",\n```\n\n## webpack-dev-server\nwebpack 开发服务器，用于开发时候的配置：\n- yarn add taco --dev webpack-dev-server / npm install --save-dev webpack-dev-server\n- 基本配置如下：\n\n```\ndevServer: { // 开发服务器\n  port: 3001,\n  contentBase: path.resolve(__dirname + '/build'), // 本地服务器目录\n  progress: true, // 进度条\n  open: true, // 自动打开浏览器\n  compress: true, // 压缩\n  // 1. 代理\n  proxy: {\n    \"/api\": {\n      target: \"\",\n      pathRewrite: {\n        \"/api\": \"\"\n      }\n    }\n  },\n  // 2. 用 express 内置钩子模拟数据\n  before(app) {\n    app.get(\"/api\", (req, res) => { ... })\n  },\n  // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件\n},\n},\n```\n\n- 在 **package.json** 添加脚本即可：\n\n```\n\"dev\": \"webpack-dev-server\"\n```\n\n## source-map && eval-source-map && cheap-module-source-map && cheap-module-eval-source-map\n\n作用：源码映射，报错时显示出错的位置。\n\n- source-map：会单独生成一个 **sourcemap** 文件；会显示行列。\n- eval-source-map：不会单独生成一个 **sourcemap** 文件，会将生成的 **sourcemap** 放到打包后的 **html** 文件；会显示行和列。\n- cheap-module-source-map：会生成 **sourcemap** 文件，不会显示列。\n- cheap-module-eval-source-map：不会生成 **sourcemap** 文件，集成在 **html** 文件中，不会显示列。\n\n```\ndevtool: \"source-map\", // 源码映射\n```\n\n## watch\n作用：监控代码实时变化，进行编译打包。\n\n```\nwatch: true, // 监控代码实时变化，进行编译打包\nwatchOptions: {\n  poll: 1000, // 多毫秒监控一次\n  aggreatement: 500, // 防抖\n  ignored: \"node_modules\" // 忽略文件夹\n},\n```\n\n## resolve\n作用：解析第三方包\n\n```\nresolve: { // 解析 第三方包\n  modules: [\n    path.resolve(\"node_modules\"), // 在当前目录下查找模块 \n    path.resolve(\"other_modules\"), // 在其他目录下查找模块 \n  ],\n  // 自动添加扩展名，主要是 import 时候使用, 依次解析\n  extensions: [\".js\", \".css\", \".json\", \".vue\"],\n  // 比如引用 bootstrap 的 css 样式\n  // 方式一： bootstrap 的主入口\n  mainFields: [\"style\", \"main\"],\n  // 方式二：别名  \n  // alias: {\n  //   bootstrap: \"bootstrap/dist/css/bootstrap.css\"\n  // }\n},\n```\n\n## 插件\nwebpack 的插件配置是一个数组，里面存放着各种各样的插件。\n\n```\nplugins: [\n new pluginName(...)\n]\n```\n\n#### html-webpack-plugin\n插件作用：打包时候自动根据 **html** 模板生成目标 **html** 文件，自动生成目标打包目录；另外，可配置 **html** 的相关打包配置，如：压缩，去双引号等。\n\n```\nnew HtmlWebpackPlugin({\n  filename: \"index.html\", // 目标文件名称\n  template: path.resolve(__dirname + '/src/template.html'), // 模板文件\n  minify: { // 压缩配置\n    removeAttributeQuotes: true, // 去双引号\n    collapseWhitespace: true, // 不换行\n  },\n  hash: true // 生成 hash 戳\n})\n```\n\n#### mini-css-extract-plugin\n作用：将生成的 **css样式** 抽离成一个 **css文件**，并将该样式文件引进目标 **html** 文件中。\n\n```\nplugins: [ // 插件\n  new MiniCssExtractPlugin({\n    filename: \"main.css\",\n  })\n],\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序\n      \"css-loader\"\n    ]\n  }]\n}\n```\n\n注：这里抽离出来的 **main.css** 文件并没有压缩，要通过手动添加以下两个插件到优化项：\n- optimize-css-assets-webpack-plugin\n- uglifyjs-webpack-plugin\n\n```\noptimization: { // 优化项\n  minimizer: [\n    new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件\n    new UglifyjsWebpackPlugin({\n      cache: true,\n      parallel: true,\n    }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置\n  ]\n},\n```\n\n#### optimize-css-assets-webpack-plugin\n插件作用：压缩抽离出来的 **main.css** 文件。但是，使用了 **optimize-css-assets-webpack-plugin** 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 **uglifyjs-webpack-plugin** 。\n\n#### uglifyjs-webpack-plugin\n插件作用：压缩打包后的 **js** 文件。\n\n#### clean-webpack-plugin\n作用：清理文件\n\n```\nplugins: [\n new CleanWebpackPlugin(\"./build\")\n]\n```\n\n#### copy-webpack-plugin\n作用：将某些文件拷贝到打包后的文件夹。\n\n```\nnew CopyWebpackPlugin([\n  {from: \"./copy\", to: \"./\"}\n])\n```\n\n#### banner-plugin\n作用：版权声明，是 **webpack** 的内置模块。\n\n```\nnew webpack.BannerPlugin(\"@copyright by Ertsul\")\n```\n\n#### webpack.DefinePlugin({ ... })\n作用：定义环境变量。\n\n```\nplugins: [\n  new webpack.DefinePlugin({\n    DEV: JSON.stringify(\"development\"),\n    PRO: JSON.stringify(\"production\")\n  })\n]\n```\n\n#### webpacfk.IgnorePlugin()\n作用：忽略模块的引进\n\n```\nplugins: [\n  new webpack.IgnorePlugin(/\\./locale/, /moment/)\n]\n```\n\n注：如果直接使用 **DEV: 'development'** 的话，会把 **DEV** 直接替换为 **引号内部的内容**。如：**console.log(DEV)**，会变成 **console.log(dev)**，最后的结果是 **undefined**。所以，需要通过 **JSON.stringfy()** 进行转化。\n\n## 模块 module\n模块主要是各种 **loader**，作用：解析各种类型的文件。\n\n```\nmodule: { \n rules: [\n   {\n     test: regx,\n     use: [loadName]\n   }\n ]\n}\n```\n\n#### css-loader / style-loader\n- css-loader：主要是用于解析在 **css** 文件中通过 **@import** 方式引进其他的 **css** 文件。\n- style-loader: 主要是用于将 **js** 文件中通过 **require** 方式引进的 **css** 文件插入到目标 **html** 文件的 **head** 中（插到最后，层级最高）。\n\n```\n// 数组方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\"style-loader\", \"css-loader\"] // loader 数组\n  }]\n}\n// 对象方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\n      {\n        loader: \"style-loader\",\n        options: {\n          insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n        }\n      }, \n      \"css-loader\"\n    ]\n  }]\n}\n```\n注：**loader** 是从右向左、从下到上的执行顺序，故：**use: [\"style-loader\", \"css-loader\"]**\n\n#### postcss-loader + autoprefixer\n这两个的配合使用可以自动添加 **css** 的浏览器前缀。\n- autoprefixer：自动添加 **css** 的浏览器前缀。\n- postcss-loader：loader 处理 autoprefixer。\n\n```\n// 使用 postcss-loader \nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader,\n      \"css-loader\",\n      \"postcss-loader\" // 注意顺序\n    ]\n  }]\n}\n```\n\n- 根目录下新建 postcss.config.js 文件\n\n```\nmodule.exports = {\n  plugins: [\n    require(\"autoprefixer\")\n  ]\n}\n```\n\n#### babel-loader + @babel/core + @babel/preset-env\n作用：转化 es6 语法\n  \n```\nmodule: { // 模块\n  rules: [{\n    test: /\\.js$/,\n    use: {\n      loader: \"babel-loader\",\n      options: { // 用 babel-loader 需要把 es6 转化为 es5\n        presets: [\n          \"@babel/preset-env\", // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块\n        ],\n        // plugins: [...] // 其他的小插件\n      }\n    }\n  }]\n}\n```\n\n#### expose-loader\n作用：暴露全局的 **loader**，暴露到 **window** 上。\n\n```\n// 一般情况\nimport $ from 'jquery';\nconsole.log(window.$); // undefined\n// 内联 loader 方式\nimport $ from 'expose-loader?$!jquery';\nconsole.log(window.$);\n// 其他方式：在每个模块中注入\nnew webpack.ProvidePlugin({\n  $: \"jquery\"\n})\nconsole.log($);\nconsole.log(window.$); // undefined\n```\n\n#### file-loader && url-loader && html-withimg-loader\n在 **webpack** 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。\n\n- file-loader：**js** 文件中通过 **import** 方式引进图片。\n- html-withimg-loader：**html** 文件中通过 **scr** 方式引进图片。\n- 在 **css** 中使用图片，**style-loader** 已经做了处理。\n- url-loader：将图片转化为 **base64**\n\n```\nmodule: {\n  rules: [\n    {\n      test: /\\.(png|jpg|gif)$/,\n      use: {\n        loader: \"url-loader\",\n        options: {\n          limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader\n          // publicPath: \"http://\", // 公共路径前缀\n        }\n      }\n    },\n    {\n      test: /\\.html$/,\n      use: [\"html-withimg-loader\"]\n    }\n  ]\n}\n```\n`\n## 模块 module -- noParse\n作用：不解析指定包的依赖关系。\n\n```\nmodule: {\n  noParse: /jquery/\n}\n```\n\n## 模块 module -- exclude\n作用：排除\n\n```\nmodule: {\n  exclude: /node_module/\n}\n```\n\n## 模块 module -- include\n作用：包含\n\n```\nmodule: {\n  include: /src/\n}\n```\n\n\n\n## 区分不同环境，实现开发和生产配置的分离\n将 **webpack** 的配置文件划分为以下文件：\n\n- webpack.base.js：基本、共有的配置。\n- webpack.dev.js：开发配置。\n- webpack.prod.js：生产配置。\n\n使用 **webpack-merger** 插件：\n- 安装 **webpack-merge** 插件；\n- 引进目标模块\n\n```\nimport { smart } from \"webpack-merge\";\n```\n\n- 使用\n\n```\nconst base = require(\"webpack.base.js);\n\nmodule.exports = smart(base, {\n  ...\n})\n```\n\n## webpack 自带优化\n- **import** 语法（生成环境），**tree-shaking** 自动删除没有用到的代码；\n- **es6** 模块会把语法放到 **default** 上；\n- 自动省略可以简化的代码；\n- **scope hosting**，作用域提升。\n\n## webpack 懒加载\n- 通过 **import** 实现（该语法内部由 **jsonp** 实现），返回的是一个 **promise**。\n- 要在 **babel-loader** 中添加 **@babel/plugin-syntax-dynamic-import** 插件。\n- **vue** 和 **react** 的l懒加载都是这样实现的。\n\n```\n/*\n* 模拟点击加载 source.js 的内容\n*/\n// 1\n{\n  loader: 'babel-loader',\n  options: {\n    presets: [\n      '@babel/preset-env'\n    ],\n    plugins: [\n      '@babel/plugin-syntax-dynamic-import'\n    ]\n  },\n}\n// 2\nlet btn = document.createElement('button');\nbtn.innerHTML = 'btn';\nbtn.addEventListener('click', function () {\n  // 内部由 jsonp 实现动态加载文件\n  import('./source.js')\n    .then(data => {\n      console.log(data);\n    })\n})\ndocument.body.appendChild(btn);\n\n```\n\n点击按钮后结果如下：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fa79ce43578285a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 热更新 / 热替换 / Hot Module Replacement / HMR\n热更新：页面只更新改动的模块。\n\n- **devServer** 开始 **hot** 热更新模块。\n- 使用 **webpack** 内置热更新插件。\n  - NamedModulesPlugin\n  - HotModuleReplacementPlugin\n\n```\n// devServer 配置\ndevServer: {\n  port: 8089,\n  contentBase: path.resolve(__dirname + '/dist/'),\n  compress: true,\n  progress: true,\n  // open: true\n  hot: true, // 开启热更新，只更新更改的模块\n},\n// 添加插件\nplugins: [\n  new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径\n  new webpack.HotModuleReplacementPlugin(), // 热更新\n]\n```\n\n- 使用热更新\n\n```\nimport source from './source.js';\n\nconsole.log(source);\n\n// 添加热更新操作，不然不会实现热更新\nif (module.hot) {\nmodule.hot.accept('./source.js', () => {\n  require('./source.js');\n})\n```\n\n## 多线程打包\n使用 **happypack** 可以实现多线程打包。\n\n- 安装并引进 **happypack**;\n- 改写 **module**;\n- **plugin** 配置。\n\n```\n// 改写 module\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      // use: {\n      //   loader: 'babel-loader',\n      //   options: {\n      //     presets: [\n      //       '@babel/preset-env'\n      //     ]\n      //   }\n      // }\n      use: {\n        loader: 'Happypack/loader?id=js',\n      }\n    },\n  ]\n}\n// plugin 配置\nplugins: [\n  new Happypack({\n    id: 'js',\n    use: [\n      {\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            '@babel/preset-env'\n          ]\n        }\n      }\n    ]\n  }),\n]\n```\n\n## 多页面打包\n\n```\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n    home: \"./src/home.js\",\n    about: \"./src/about.js\",\n    other: \"./src/other.js\"\n  },\n  output: {\n    path: path.resolve(__dirname + \"/build/\"),\n    filename: \"[name].js\",\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"home.html\",\n      chunks: [\"home\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"other.html\",\n      chunks: [\"other\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"about.html\",\n      chunks: [\"about\"]\n    }),\n  ]\n}\n```\n\n## 多页面打包抽离公共代码块\n打包 **多页面** 需要将公共的代码块抽离出来进行优化：\n\n```\noptimation: {\n  splitChunks: {  // 分割代码块\n    cacheGroups: {  // 缓存组\n      common: {  // 公共的模块\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      },\n      vender: {  // 第三方模块\n        priority: 1,  // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用\n        test: /node_modules/,  // 抽离出来\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      }\n    }\n  }\n}\n```\n\n## Tapable\n**webpack** 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 **Tapable**，通过 **Tapable** 实现各种钩子（如同步钩子异步钩子）。而 **Tapable** 核心是依赖于 **发布订阅者模式**。\n\n- 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tap** 注册。\n\n使用：\n```\nconst { SyncHook } = require('tapable');\n\nclass Hook {\n  constructor() {\n    this.hooks = {\n      arch: new SyncHook(['name'])\n    }\n  }\n  tap() { // 注册监听事件\n    this.hooks.arch.tap('vue', (name) => {\n      console.log('vue', name);\n    })\n    this.hooks.arch.tap('react', (name) => {\n      console.log('react', name);\n    })\n  }\n  start() { // 开始\n    this.hooks.arch.call('Ertsul')\n  }\n}\nlet h = new Hook();\nh.tap();\nh.start();\n```\n\n- 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tapAsync** 注册。\n\nsetTimeout()方式使用：\n\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapAsync('vue', (name, cb) => {\n      setTimeout(() => {\n        console.log('vue', name);\n        cb && cb();\n      }, 1000)\n    })\n    this.hooks.arch.tapAsync('react', (name, cb) => {\n      setTimeout(() => {\n        console.log('react', name);\n        cb && cb();\n      }, 1000)\n    })\n  }\n  start() {\n    this.hooks.arch.callAsync('Ertsul', () => {\n      console.log('All finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\nPromise()方式使用：\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapPromise('vue', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('vue', name);\n          resolve();\n        }, 1000)\n      })\n    })\n    this.hooks.arch.tapPromise('react', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('react', name);\n          resolve();\n        }, 1000)\n      })\n    })\n  }\n  start() {\n    this.hooks.arch.promise('Ertsul').then(() => {\n      console.log('hook all finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\n#### Synchook 同步钩子\n实现：\n```\nclass Synchook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      task(...args);\n    })\n  }\n}\n\nlet hook = new Synchook(['Synchook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n![image.png](https://upload-images.jianshu.io/upload_images/659084-1d12026d2f938c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncBailHook 同步熔断钩子\nSynchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。\n\n实现：\n```\n// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数\nclass Syncbailhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let ret = ''; // 当前函数的返回值\n    let index = 0; // 当前任务数组的索引\n    do {\n      ret = this.tasks[index++](...args);\n    } while (ret === undefined && index < this.tasks.length)\n  }\n}\n\nlet hook = new Syncbailhook(['Syncbailhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-3a46a477c8b08d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncWaterfallHook 同步瀑布钩子\nSyncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。\n\n实现：\n```\n/**\n * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系\n * 上一个函数的执行返回结果在当前函数的输入\n */\nclass Syncwaterfallhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let [first, ...others] = this.tasks;\n    let ret = first(...args);\n    others.reduce((prev, current) => {\n      return current(prev);\n    }, ret)\n  }\n}\n\nlet hook = new Syncwaterfallhook(['Syncwaterfallhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return 'vue learnt';\n})\nhook.tap('react', (data) => {\n  console.log('react', data);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-5ccbc856cac523cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncLoopHook 同步循环钩子\n同步循环钩子回让某个函数执行一定的次数。\n\n实现：\n```\n// Tapable Syncloophook 同步循环钩子\nclass Syncloophook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      let ret = '';\n      do {\n        ret = task(...args);\n      } while (ret != undefined);\n    })\n  }\n}\n\nlet hook = new Syncloophook(['Syncloophook']);\nconst total = 3;\nlet index = 0;\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return ++index === total ? undefined : 'continue';\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fd5d933715541d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### AsyncParallelHook 异步并发钩子 回调函数方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapAsync(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  callAsync(...args) { // 发布事件\n    let finalCallback = args.pop();\n    let index = 0;\n    const done = () => {\n      index++;\n      if (index === this.tasks.length) {\n        finalCallback();\n      }\n    }\n    this.tasks.forEach(task => {\n      task(...args, done);\n    })\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapAsync('vue', (name, cb) => {\n  setTimeout(() => {\n    console.log('vue', name);\n    cb && cb();\n  }, 1000)\n})\nhook.tapAsync('react', (name, cb) => {\n  setTimeout(() => {\n    console.log('react', name);\n    cb && cb();\n  }, 1000)\n})\nhook.callAsync('Ertsul', () => {\n  console.log('All hook finished!');\n});\n```\n\n#### AsyncParallelHook 异步并发钩子 Promise方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapPromise(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  promise(...args) { // 发布事件\n    let tasks = this.tasks.map(task => task(...args));\n    return Promise.all(tasks);\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapPromise('vue', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('vue', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.tapPromise('react', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('react', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.promise('Ertsul').then(() => {\n  console.log('All hooks finished!');\n})\n```\n\n#### AsyncSeriesHook 异步串行钩子\n#### AsyncWaterfallHook 异步瀑布流钩子","tags":["frontEnd","webpack"]},{"title":"hello-hexo","url":"/2019/02/16/hello-hexo/","content":"## Hello Hexo"}]