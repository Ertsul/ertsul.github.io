[{"title":"3D立体骰子","url":"/2019/02/16/3D立体骰子/","content":"CSS3确实很强大，很多高大上的动画都可以实现，这里来实现下3D立方体，效果图如下：\n![3D立方体.gif](http://upload-images.jianshu.io/upload_images/659084-21400fd37137e37c.gif?imageMogr2/auto-orient/strip)\n## html\n其实，实现3D立方体需要的html十分简单，只需要一个ul标签里面包裹6个li标签，分别用来表示3D立方体的6个面[ 前，下，后，上，左，右 ]。具体代码如下:\n````\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n</ul>\n````\n## CSS3\n#### ul\n基本的宽高这些就不说了；作为整个3D立方体的父级元素，需要设置positiion属性为relative，还要最重要的是设置它的动画类型tranform-style为preserve-3d，这样就可以实现它的所有子元素都进行3d动画。\n#### li\n宽高设置为100%，position属性设置为absolute。\n- 前\n设置背景，并且沿着Z轴移动50px，即宽高的一半(为什么得添加这个, 后面用动画进行解释说明)。\n- 下\n设置背景，沿着**X轴**旋转-90deg，作为底面，同样，并且沿着Z轴移动50px。\n- 后\n设置背景，沿着**X轴**旋转-180deg，作为后面，同样，并且沿着Z轴移动50px。\n- 上\n设置背景，沿着**X轴**旋转90deg，作为上面，同样，并且沿着Z轴移动50px。\n- 左\n设置背景，沿着**Y轴**旋转-90deg，作为左面，同样，并且沿着Z轴移动50px。\n- 右\n设置背景，沿着**Y轴**旋转90deg，作为右面，同样，并且沿着Z轴移动50px。\n![效果.gif](http://upload-images.jianshu.io/upload_images/659084-133d15ade6726266.gif?imageMogr2/auto-orient/strip)\n#### 结尾说明\n这里说明上面那个translate，先来看看如果不添加这个属性是怎样的效果：\n![动画.gif](http://upload-images.jianshu.io/upload_images/659084-2e1633af2155afdb.gif?imageMogr2/auto-orient/strip)\n可见，所有的面都交集于立方体的中心点。由于未对6个面作任何动画处理的时候，所有的面都集合在一起。所以在面作旋转的同时需要对其进行Z轴的位移处理。\n#### 代码\n````\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n    body {\n        background-color: black;\n    }\n\n    ul {\n        list-style: none;\n        width: 100px;\n        height: 100px;\n        position: relative;\n        cursor: pointer;\n        margin: 150px auto;\n\n        transition: 1s;    /* 设置过渡时间 */\n        transform-style: preserve-3d;   /* 设置所有的子元素实现3D动画 */\n    }\n\n    /* 设置鼠标悬停的动画 */\n    ul:hover {\n        transform: rotateX(120deg) rotateY(120deg);\n    }\n\n    ul li {\n        width: 100%;\n        height: 100%;\n        text-align: center;\n        line-height: 100px;\n        font-size: 40px;\n        font-weight: 700;\n        position: absolute;\n        top: 0px;\n    }\n    /* 前 */\n    ul li:nth-child(1) {\n        background-color: rgba(225, 0, 0, .4);\n        transform: rotateX(0deg) translateZ(50px);\n    }\n    /* 下 */\n    ul li:nth-child(2) {\n        background-color: rgba(0, 255, 0, .4);\n        transform: rotateX(-90deg) translateZ(50px);\n    }\n    /* 后 */\n    ul li:nth-child(3) {\n        background-color: rgba(0, 0, 255, .4);\n        transform: rotateX(-180deg) translateZ(50px);\n    }\n    /* 上 */\n    ul li:nth-child(4) {\n        background-color: rgba(125, 125, 0, .4);\n        transform: rotateX(90deg) translateZ(50px);\n    }\n    /* 左 */\n    ul li:nth-child(5) {\n        background-color: rgba(0, 125, 125, .4);\n        transform: rotateY(-90deg) translateZ(50px);\n    }\n    /* 右 */\n    ul li:nth-child(6) {\n        background-color: rgba(10, 45, 36, .4);\n        transform: rotateY(90deg) translateZ(50px);\n    }\n</style>\n````","tags":["frontEnd","css"]},{"title":"DOM事件","url":"/2019/02/16/DOM事件/","content":"## 事件\n事件就是用户或者浏览器进行的特定行为，比如：鼠标点击事件。\n\n## 事件名称\n\n比如：click就是一个事件名。\n\n## 事件流的执行过程\n\n事件流：指的是DOM事件流（多个事件按照一定顺序执行），DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。\n事件流的执行过程：从window开始，最后回到window。\n事件流被分为三个阶段：事件捕获（1-5），事件触发（5-6），事件冒泡（6-10）。\n\n来自网上的图片：\n\n![事件流.png](http://upload-images.jianshu.io/upload_images/659084-eb2b449c3348c5d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### [](#事件冒泡 \"事件冒泡\")事件冒泡\n\n来自百度的解释：\n\n> 当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。\n\n就比如：我们用button产生一个click事件，但是由于button按钮本身可能不能处理这个事件，就要开始传播出去这个事件。\n实现事件冒泡的条件是：元素之间有嵌套，每个元素都有相同的事件，这样当最里层的事件触发时，这个事件就会一级一级向上传播，也就是”冒泡“。\n\n举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。这样，当里层点击事件触发时，外层的点击事件也会被触发。\n\n````\n<div id=\"outer\">\n <div id=\"inner\">\n </div>\n</div>\n\n<script>\n window.onload = function () {\n   let inner = document.getElementById('inner')\n   let outer = document.getElementById('outer')\n   inner.addEventListener('click', function (e) {\n     console.log('inner');\n   })\n   outer.addEventListener('click', function () { \n     console.log('outer');\n   })\n }\n</script>\n````\n\n结果为：\n![事件冒泡.gif](http://upload-images.jianshu.io/upload_images/659084-be2355e585a26bc5?imageMogr2/auto-orient/strip)\n\n##### 阻止事件冒泡\n\n*   一般浏览器：event.stopPropagation()\n*   IE浏览器：event.cancelBubble = true\n\n##### 阻止默认事件\n\n*   一般浏览器：event.preventDefault()\n*   IE浏览器：event.returnValue = false\n\n## addEventListener的第三个参数\n\naddEventListener方法用于将事件和函数进行绑定，函数为：addEventListener(event, fn, useCapture)，这些参数分别是：事件名，事件处理函数，第三个参数 **useCapture** 是一个布尔值，用来设置该事件的执行是在哪个阶段发生的（默认是在冒泡阶段）。\n\n*   true：表示该事件是在“事件捕获阶段”触发的。（由外向内）\n*   false：表示该事件是在“事件冒泡阶段”触发的。（由内向外）\n\n举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。\n\n将第三个参数设置为true，事件在 **捕获阶段** 执行：\n\n````\n<div id=\"outer\">\n <div id=\"inner\">\n </div>\n</div>\n\n<script>\n window.onload = function () {\n let inner = document.getElementById('inner')\n let outer = document.getElementById('outer')\n inner.addEventListener('click', function (e) {\n console.log('inner');\n }, true)\n outer.addEventListener('click', function () { \n console.log('outer');\n }, true)\n }\n</script>\n````\n\n由于是 **捕获阶段** 执行，即：由外向内执行，所以结果为： outer inner。\n\n结果为：\n![image.png](http://upload-images.jianshu.io/upload_images/659084-82bb228984257ae1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将第三个参数设置为false，事件在 **冒泡阶段** 执行，输出结果为： inner outer。\n![image.png](http://upload-images.jianshu.io/upload_images/659084-1d1d0c25024cc18d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 事件处理函数/事件监听函数\n\n事件触发后的处理函数。如：btn.onclick = fn，fn就是事件处理函数/事件监听函数。\n\n#### HTML事件处理程序\n\n例如：\n\n````\n<button onclick = \"fn()\">click</button>\n````\n\n这种方式的缺点是：结构和行为耦合在一起。\n\n#### DOM0级事件处理程序\n\n形式为：ele.on + ‘事件名称’ = 事件处理函数\n例如： ele.onclick = function() {…}，this指向当前元素。\n\n#### DOM2级事件处理程序\n\n这种方式主要是通过这两个方法：addEventListener()，removeEventListener()\n这种方式的优点就是：可以同一个事件处理程序绑定多个事件处理函数。\n\n## 事件委托\n\n事件委托要处理的问题是：解决事件处理程序过多的问题。简单来说，就是将很多个事件处理程序委托给一个事件处理程序，通过这个事件处理程序来管理这么多个事件处理程序。\n好处：减少对DOM的访问，提高性能；可以对后来添加进来的元素也能绑定委托事件。\n\n例如：在一个 ul 标签中有很多个 li 标签，我们的需求而是点击每一个 li 标签显示每一个 li 标签的内容。\n如果没有使用事件委托，我们需要给每一个 li 标签都添加事件监听函数，很明显，这样的效率并不高，而且对整个网页的性能也会影响；如果我们使用事件委托，将这些 li 的事件委托给 ul 标签，这样就可以只用一个事件监听函数实现。\n\n代码如下：\n\n````\n<ul id=\"list\"> \n <li>111111</li>\n <li>222222</li>\n <li>333333</li>\n <li>444444</li>\n</ul>\n\n<script>\n window.onload = function () { \n // 传统的方法\n // let lis = document.getElementsByTagName('li')\n // console.log(lis);\n // for(let i = 0; i < lis.length; i++){\n //     lis[i].addEventListener('click', function () { \n //         console.log(this.innerHTML);\n //     })\n // }\n // 使用事件委托\n let list = document.getElementById('list')\n list.addEventListener('click', function (e) { \n   let target = e.target\n   console.log(target.innerHTML);\n }, false)\n }\n</script>\n````\n\n事件委托一般使用的是 **事件冒泡阶段** 进行（虽然事件捕获阶段也可以），因为事件冒泡的事件流模型被所有的主流浏览器兼容，事件冒泡的兼容性更好。","tags":["frontEnd","js"]},{"title":"px/em/rem总结","url":"/2019/02/16/px-em-rem总结/","content":"## px\n\n对于**px**，大家都不陌生。它是一个相对于屏幕的相对长度单位。\n\n## em\n\n**em**也是一个相对长度单位，但它相对的是父级元素的字体大小。\n对于em有一个推算过程：\n如果没有定义自己的font-size，则：浏览器默认：*1em = 16px*\n所以：\n*12px = 0.75em*\n*10px = 0.625em*\n但是如果每次都这样进行计算很麻烦，而且开发效率也很低，因此为了简化计算，我们将浏览器的font-size设置为**62.5%**，这样：\n**1em = （16px * 62.5%） = 10px； 1.2em = 12px**\n依次类推，要使用em这个相对长度单位，只要我们在body标签里面设置了font-size为62.5%，这样只要就可以得到计算公式：**(n)px = (n \\ 10)em**\n\n但是，em单位是相对的，不是固定的，是逐级继承的（一层一层向上计算），举个例子：\n比如，一个div里面嵌套了一个div，这两个div都设置了font-size为1.2em，浏览器的font-size设置为62.5%，此时，最里层的div的font-size大小是：**（1.2 * 1.2） = 1.44em**。\n\n## rem\n\n**rem**也是相对长度单位，从它的单位也可以看出，它跟**em**比较，多了个 **r** 字母，它的意思就是**root（根）**的意思。简单来说，就是它是相对于根节点（html标签）的font-size而言的。这样子，就消除了**em**单位逐级继承的缺点。\n举个例子：\n先将**html**标签设置为62.5%，这样，html里面的任何子标签都是继承于这个标签，也就是说相对于这个标签。所以，不论标签中有多少级的嵌套，最里层标签的font-size的计算公式永远是：**(n)px = (n \\ 10)rem**\n","tags":["frontEnd","css"]},{"title":"js的原型和继承","url":"/2019/02/16/js的原型和继承/","content":"## 原型模式\n\n原型模式在《JavaScript高级程序设计》中的定义：\n\n> 我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用这个对象的好处就是可以让所有对象实例共享它包含的属性和方法。\n\n这里还有一个\\_\\_proto\\_\\_属性，每一个对象都拥有这个属性，这个属性指向对应的构造函数的prototype属性。\n\n通过原型对象，我们就不用将信息添加到构造函数中了。\n\n#### 实例对象共享原型对象的属性\n\n````\nfunction Person(){}\nPerson.prototype.name = 'A'\nPerson.prototype.age = 1\n// 实例对象共享原型对象的属性\nlet p1 = new Person()\nconsole.log(p1.name, p1.age);   // A 1\nlet p2 = new Person()\nconsole.log(p2.name, p2.age);   // A 1\n````\n\n#### constructor（构造函数）属性\n\n每个原型对象在默认情况下都会自动获取一个constructor（构造函数）属性，这个属性包含一个指针，指向这个原型所在的函数。在上面的例子中，创建Person函数后，它的prototype指向它的原型对象，这个原型对象就会获取获取constructor属性，指向Person函数。\n\n#### 判断实例对象与原型对象之间的关系\n\n*   Obj.prototype.isPrototypeOf(obj)\n\n````\nconsole.log(Person.prototype.isPrototypeOf(p1)) // true\n ````\n\n*   Object.getPrototypeOf(obj)：返回对象实例的原型[es5]\n\n````\nconsole.log(Object.getPrototypeOf(p1) == Person.prototype);   // true\nconsole.log(Object.getPrototypeOf(p1).name);    // A\n````\n\n*   obj.hasOwnPrototype(attr)：检测一个属性是否存在于实例中。只有当实例对象重写原型对象的属性后（非原型属性）才会返回true。\n\n````\nconsole.log(p1.hasOwnProperty('name')); // false\np1.name = 'Ertsul'\nconsole.log(p1.hasOwnProperty('name')); //true\n````\n\n*   in操作符：通过in操作符和hasOwnProperty()可以判断某属性存在于实例还是原型对象中【in判断是否存在属性，hasOwnProperty()判断存在于哪里。】可以单独使用和for-in循环使用：无论属性属于实例还是原型中，都会返回true。(‘name’ in person1)\n\n*   获取所有实例的属性名字，无论是否可以枚举。\n\n````\nconsole.log(Object.getOwnPropertyNames(p1)); // [\"name\"]\n````\n\n*   instanceof\n\n````\nconsole.log(p1 instanceof Person);    // true\n````\n\n#### 更简单的语法\n\n````\nfunction Person() {  }\nPerson.prototype = {\n name: '001'\n}\nlet p1 = new Person()\nconsole.log(p1.name);\n````\n\n这里的例外是：constructor属性不再指向Person；本质上相当于完全重写了Person对象了。注：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。[详见《JavaScript高级程序设计》P156-P157，原型的动态性]\n\n####搜索机制\n\n*   解释器会现在目标对象中搜索目标属性，如果当前对象没有目标属性，解释器继续在目标对象的原型对象中搜索。\n*   通过delete只能删除对象的属性，而不能删除原型对象中的属性。\n\n#### 组合模式（默认类型）：构造函数模式 + 原型模式\n\n构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。\n\n## 继承\n\n#### 原型链\n\n````\n// 父亲\nfunction Father() { \n this.fatherProperty = true\n}\nFather.prototype.getFatherValue = function () { \n return this.fatherProperty\n}\n// 儿子\nfunction Son() { \n this.sonProperty = false\n}\n// 继承父亲：通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性\nSon.prototype = new Father()\nSon.prototype.getSonValue = function () { \n return this.sonProperty\n}\n\nlet instance = new Son()\nconsole.log(instance.fatherProperty);   // true\n````\n\n上面例子中，通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性。（重写儿子的原型）。这里，儿子原型对象的[[prototype]]（注：不是prototype，[[prototype]]存在于原型中）指向的是父亲的原型对象，而父亲的原型对象的[[prototype]]指向的是Object Prototype。（由于所有函数的默认原型都是Object的实例，所以默认原型都会包含一个内部指针，指向Object.prototype）\n\n#### 借用构造函数\n\n*   主要是为了解决因为引用类型值的原型属性会被所有实例共享的问题。\n*   **借用构造函数/伪造对象/经典继承**：在子类型构造函数的内部调用超类型构造函数。\n\n````\n// 父亲\n    function Father() { \n     this.info = ['Zero']\n    }\n    // 儿子\n    function Son() { \n     // 继承父亲：在子类型构造函数的内部调用超类型构造函数\n     // 《JavaScript高级程序设计》：函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call() 可以在新创建的对象上执行构造函数。 \n     Father.call(this)        // 借用超类的构造函数\n    }\n\n    let f = new Father()\n    f.info.push('100')\n    console.log(f.info);    // [\"Zero\", \"100\"]\n\n    let s = new Son()\n    console.log(s.info);    // [\"Zero\"]\n````\n\n如果在继承的时候要传递参数，则在后面添加参数即可。如：Father.call(this， param1, param2)\n\n#### \\_\\_proto\\_\\_\n\n通过**\\_\\_proto\\_\\_**也可以实现子类型对超类型的继承。\n\n````\nconst obj = {\n num : 123 \n}\nconst obj1 = {\n __proto__ : obj\n}\nconsole.log(obj1.num);  // 123\n````\n\n#### Object.create(source)\n\n````\nconst obj = {\n num : 123 \n}\nconst obj2 = Object.create(obj)\nconsole.log(obj2.num);  // 123\n````\n\n#### Object.assign(Object.create(obj), {…})\n\n````\nconst obj = {\n num : 123 \n}\nconst obj3 = Object.assign(\n Object.create(obj),\n {\n num2 : 234\n }\n)\nconsole.log(obj3.num, obj3.num2);   // 123 234\n````\n\n## 补充\n#### 继承机制如下图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-862bb97f2e2fe227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 测试代码如下：\n\n````\n// 父类\nfunction SuperType(){\n}\n// 子类\nfunction SubType(){\n\n}\n// 子类继承父类\nSubType.prototype = new SuperType();\n// 实例化父类和子类\nlet superIns = new SuperType();\nlet subIns = new SubType();\n\n// 子类\nconsole.log(SubType.prototype);     // SuperType {}\nconsole.log(subIns.__proto__);      // SuperType {}\n\n// 父类\nconsole.log(SuperType.prototype);       // {constructor: ƒ} \nconsole.log(superIns.__proto__);        // {constructor: ƒ}\n\nconsole.log(SuperType.prototype.__proto__);     \n// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n// 即： Object prototype\n\nconsole.log(SuperType.prototype.__proto__.constructor);\n// ƒ Object() { [native code] } 即：Object\n````","tags":["frontEnd","js"]},{"title":"js的存储和拷贝","url":"/2019/02/16/js的存储和拷贝/","content":"\n## 数据类型\n#### 基本数据类型\n- Number\n- String\n- Boolean\n- Undefined\n- Null\n#### 引用类型\n多个基本数据类型复合形成。\n- Object\n\n## 存储方式\n#### 基本数据类型的存储方式\n- 每当定义一个基本数据类型的变量，会在 **栈区** 开辟一个内存空间，用于存放该变量。栈区的特点是：静态分配，大小固定。\n- 当一个变量通过直接复制的方式复制给另一个变量，系统会在 **栈区**  重新开辟一个内存空间；两个变量互不影响。\n\n````\nlet num1 = 10;\nlet num2 = num1;\nnum2 = 20;\nconsole.log(num1);     // 10 \n````\n\n#### 引用类型的存储方式\n- 每当定义一个引用类型，如：对象，会在 **堆区** 开辟一个内存空间；然后如果创建一个该对象的实例，会在 **栈区** 开辟一个内存存放该实例，该实例实际上是一个指向 **堆内存** 对象的指针。堆区的特点是：动态分配，大小不固定。\n- 当一个实例直接复制给另一个实例，系统会在 **栈区**  重新开辟一个内存空间，但是新实例同样也是一个指向  **堆内存** 对象的指针，所以，这样的操作，这样的修改都会对新旧实例产生影响。\n\n````\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\n\n//直接复制\nlet obj2 = obj1;\n\nobj2.name = 'Ertsul';\nobj2.num[0] = '一';\nconsole.log(obj1, obj2);\n// name:\"Ertsul\"\n// age:22\n// num:[\"一\", \"2\", \"3\"]\n````\n\n## 浅拷贝和深拷贝\n#### 区别\n两者的区别主要在于 **复制层次** 的不同：\n- 浅拷贝主要复制到对象属性这一层次，如果对象里面有子对象，则无法对子对象完成复制；之后对于子对象的修改 **会** 影响到原复制对象。\n- 深拷贝则是浅拷贝的 **加强版** ，可以实现对于子对象的拷贝；之后对于子对象的修改 **不会** 影响到原复制对象。主要实现方法有：\n  - 递归\n  - JSON解析\n#### 浅拷贝\n\n````\n// 浅拷贝\nfunction shallowCopy(source) {\n    let result = {};\n    for(let key in source){\n        result[key] = source[key]\n    }\n    return result;\n}\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\n\nlet obj2 = {};\nobj2 = shallowCopy(obj1);\n\nobj2.name = 'Ertsul';    // 不会产生影响\nobj2.num[0] = '一';      // 产生影响\nconsole.log(\"obj1\", obj1);\nconsole.log(\"obj2\", obj2);\n````\n\n结果如图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-2238425cd781911c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 深拷贝\n\n##### 递归\n\n````\n// 递归实现深拷贝\nfunction deepCopy(source, res){\n    var res = res || {};\n    for(let i in source){\n        if(typeof source[i] === 'object'){\n            if(source[i].constructor === Array){\n                res[i] = []\n            }else {\n                res[i] = {}\n            }\n            deepCopy(source[i], res[i]);   // 递归子对象属性\n        }else{\n            res[i] = source[i]\n        }\n    }\n    return res;\n}\n\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\n\nlet result = {}\nresult = deepCopy(obj1, result);\nresult.name = 'Ertsul';\nresult.num[1] = '二';\nconsole.log(\"result\", result);\nconsole.log(\"obj1\", obj1);\n````\n\n结果如图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-522f00e896a05506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### JSON解析\n\n````\n// JSON实现深拷贝\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\nlet result1 = JSON.parse(JSON.stringify(obj1));\nresult1.num[2] = '三';\nconsole.log('result1', result1);\nconsole.log('obj1', obj1);\n````\n\n结果如图：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-b747df9bb831bf93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","tags":["frontEnd","js"]},{"title":"js/es6小知识大杂烩","url":"/2019/02/16/js-es6小知识大杂烩/","content":"\n#### 合并两个数组\n- 数组的解构 **[...arr1, ...arr2]**\n- Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。\n- arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。\n\n```\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\nlet arr3 = [...arr1,  ...arr2];\nconsole.log(arr3);\nArray.prototype.push.apply(arr1,  arr2);\nconsole.log(arr1);\n```\n\n#### arguments/伪数组 转化为数组\n- [...arguments]\n- Array.prototype.slice.call(arguments)\n\n```\n(function Fn() {\n    let arr = [...arguments, 'Ertsul'];\n    console.log(arr);\n})('zero');\n(function Fn1() {\n    let arr = Array.prototype.slice.call(arguments);\n    console.log(arr);\n})('zero');\n```\n\n#### 判断字符类型\n- Object.prototype.toString.call()\n- typeof\n- instanceof\n\n#### 创建实例的方法\n- 字面量 let obj = {...}\n- new Object()构造函数\n- 构造函数\n- Object.create()\n- 工厂模式\n\n```\n// 字面量\nlet obj1 = {\n    name: 'zero',\n    age: 22\n};\n// Object 构造函数\nlet obj2 = new Object();\nobj2.name = 'zero';\nconsole.log(obj2.name);\n// 工厂模式\nfunction Person(name) {\n    let obj = new Object();\n    obj.name = name;\n    return obj;\n}\nlet p1 = Person('zero');\nconsole.log(p1.name);\n// 构造函数\nfunction Animal(name) {\n    this.name = name;\n}\nlet a2 = new Animal('dog');\nconsole.log(a2.name);\n```\n\n#### 继承的方法 -- 8种\n- 通过原型继承\n  - 缺点：引用类型存在共享问题。\n\n````\nfunction Fn1() { ... }\nfunction Fn2() { ... }\nFn2.prototype = new Fn1();\n````\n\n- 构造函数：通过 **call** 更改 **this** 指向；实际上是调用了父类的构造函数。\n  - 缺点：父类中的方法（构造函数中）子类不可见。\n\n````\nfunction Fn1() { ... }\nfunction Fn2() { \n  Fn1.call(this);   // 将 this 绑定到 Fn1\n}\n````\n\n````\nfunction SuperType(){\n    \n}\nSuperType.prototype.sayHi = function(){\n    console.log('Hi');\n}\n\nfunction subType(){\n    SuperType.call(this);\n}\n\nlet superIns = new SuperType();\nsuperIns.sayHi();   // Hi\n\nlet subIns = new subType();\nsubIns.sayHi();     // Uncaught TypeError\n````\n\n- 组合继承（原型 + 构造）\n属性通过构造函数继承；方法通过原型继承。记得要更改 **Fn2.prototype.constructor** 的指向，指向子类。\n\n````\n// 组合继承\nfunction Fn1() {\n    this.name = 'zero'\n}\n\nFn1.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction Fn2() {\n    // 继承属性\n    Fn1.call(this);\n    this.age = 22;\n}\n// 继承方法\nFn2.prototype = new Fn1();\nFn2.prototype.constructor = Fn2;   // 需要修复构造函数指向\n\nFn2.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nlet f = new Fn2();\nf.sayName();\nf.sayAge();\n````\n\n- 实例继承\n在一个函数内实例化，然后添加新属性，并返回该对象。\n\n````\nfunction Fn() { ... }\nfunction Fn2(name) {\n let obj = new Fn();\n obj.name = name;\n return obj;\n}\n````\n\n- 原型式继承\n将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。\n\n````\nfunction SuperType(name) {\n    this.name = name\n}\n\nfunction Object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n\nlet subType = Object(new SuperType('zero'));\nconsole.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__\n````\n\n- 拷贝继承\n将原型/父类上的属性全部拷贝到子类上。\n\n````\n// 拷贝继承\nfunction Fn1() {\n    this.name = 'zero';\n    this.age = 22\n}\nfunction Fn2() {\n    let f1 = new Fn1();\n    // 注意这里要用 in 操作符\n    for (let item in f1) {\n        Fn2.prototype[item] = f1[item];\n    }\n    Fn2.prototype.ownFun = function () {\n        console.log('my own function.');\n    }\n}\n\nlet f = new Fn2();\nconsole.log(f.name + \", \" + f.age);\nf.ownFun();\n````\n\n- 寄生组合式模型\n  - 通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。\n  - 通过构造函数实现属性的继承。\n\n````\n// 寄生组合式继承\nfunction inheritPrototype(subType, superType) {\n    // 创建对象：新建的对象指向父类的原型\n    let prototype = Object(superType.prototype);\n    // 增强对象：新建对象的 constructor 指向子类\n    prototype.constructor = subType;\n    // 指定对象：子类的原型指向新建对象\n    subType.prototype = prototype;\n}\n\nfunction Fn1() {\n    this.name = 'Ertsul';\n}\n\nFn1.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction Fn2() {\n    Fn1.call(this);\n    this.age = 22;\n}\n\ninheritPrototype(Fn2, Fn1);\n\nFn2.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nlet f = new Fn2();\nf.sayName();f.sayAge();\n````\n\n- es6 的 extends \n\n````\n// class\nclass F1 {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nclass F2 extends F1 {\n    constructor(name, age){\n        super(name);    // 调用父类的构造函数\n        this.age = age;\n    }\n    showMsg(){\n        console.log(this.name + ', ' + this.age);\n    }\n}\n\nlet p = new F2('zero', 22);\np.showMsg();  // zero, 22\n````\n\n#### 比较两个对象是否相等\n- 遍历对象对象进行判断。\n- 将对象转化为字符串进行判断。\n\n````\nlet obj1 = {\n    name: 'a',\n    age: 1\n}\nlet obj2 = obj1;\nlet obj3 = {\n    name: 'a',\n    age: 2\n}\nconsole.log(JSON.stringify(obj1));\nconsole.log(JSON.parse(JSON.stringify(obj1)));\nconsole.log(JSON.stringify(obj1) == JSON.stringify(obj2));  // true\nconsole.log(JSON.stringify(obj1) == JSON.stringify(obj3));  // false    \n````\n\n#### 封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行\n\n````\nfunction time(time){\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time);\n    })\n}\n\nlet t = new time(5000);\nt.then((a, b) => {\n    console.log('time');\n})\n````\n\n#### 原型相关的API\n- Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例\n- Object.getPrototypeOf(p1)：获取原型\n- p1.hasOwnProperty('name')：判断某个属性是否属于某个实例（只能获取属性实例）\n- in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中）\n\n````\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nlet p1 = new Person('Ertsul', 22);\nconsole.log(Person.prototype);      // constructor f\nconsole.log(Person.prototype.constructor);  // Person\nconsole.log(Person.prototype.__proto__);    // constructor 的原型\nconsole.log(p1.__proto__);      // // constructor f\n\nconsole.log(Person.prototype.isPrototypeOf(p1));    // true\nconsole.log(Person.isPrototypeOf(p1));      // false\nconsole.log(Object.getPrototypeOf(p1));     // constructor f\n\nconsole.log(p1.hasOwnProperty('name'));     // true 存在实例中\n\nPerson.prototype.num = 100\n\nconsole.log(p1.hasOwnProperty('num'));      // fasle    存在原型中\n\nconsole.log('num' in p1);   // true 不管是实例还是原型中\n````\n\n#### js 判断数组类型\n- arr instanceof Array\n- arr.constructor === Array\n\n````\nlet arr = [1, 2, 3];\nlet obj = {}\nfunction judgeFn(arr){\n    // return arr.constructor === Array ? true : false\n    return arr instanceof Array ? true : false\n}\nconsole.log(judgeFn(arr));  // true\nconsole.log(judgeFn(obj )); // false\n````\n\n#### 日期格式化\n````\n/* 日期格式化 */\nfunction formatNumber(num) {\n\tconst n = `${num}`;\t\t// 转化为字符串\n\treturn n[1] ? n : `0${n}`;\n}\nfunction formatTime(date){\n\t// 年 月 日\n\tconst year = date.getFullYear();\n\tconst month = date.getMonth() + 1;\n\tconst day = date.getDate();\n\t// 时 分 秒\n\tconst hour = date.getHours();\n\tconst minute = date.getMinutes();\n\tconst second = date.getSeconds();\n\n\treturn `${[year, month, day].map(formatNumber).join('-')} ${[hour, minute, second].map(formatNumber).join(':')}`\n}\nlet time = new Date();\nconsole.log(time);\t\t// Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间)\nlet t1 = formatTime(time);\nconsole.log(t1);\t\t// 2018-08-14 16:52:06\n````\n\n#### 字符串转化为标准日期格式\n````\n/* 字符串转化为标准日期格式 */\nfunction time2string(str) {\n\tconst chunks = str.split(' ');\n\tconst date = chunks[0].split('-');\n\tconst time = chunks[1].split(':');\n\n\treturn new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]);\n}\nlet str = \"2018-08-14 23:59:59\";\nlet t2 = time2string(str);\nconsole.log(t2);\t// Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间)\n````\n#### 防抖节流\n````\n/* 防抖节流 debounce throttle */\n// 防抖 - 连续快速触发的解决方案\nfunction debounce(fn, wait) {\n\tlet timeout = null;\t// 初始化 timer 定时器\n\treturn function (){\n\t\ttimeout && clearTimeout(timeout);\t// 清空定时器\n\t\ttimeout = setTimeout(fn, wait);\t\t// 设置定时器\n\t}\n}\n// 节流 - 一定时间内请求一次 -- 定时器法\nfunction throttle1(fn, wait) {\n\tlet timer = null;\t// 初始化 timer 定时器\n\treturn function () {\n\t\tlet context = this;\t\t// 保存上下文 this\n\t\tlet args = arguments;\t// 记录参数\n\t\tif(!timer) {\t// 定时器为空\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tfn.apply(context, args);\n\t\t\t\ttimer = null;\t// 清空定时器\n\t\t\t}, wait);\n\t\t}\n\t}\n}\n// 节流 - 一定时间内请求一次 -- 时间戳法\nfunction throttle2(fn, wait) {\n\tlet prev = Date.now();\t// 记录前一个时间\n\treturn function () {\n\t\tlet context = this;\t\t// 保存上下文 this\n\t\tlet args = arguments;\t// 记录参数\n\t\tlet now = Date.now(); \t// 记录当前时间\n\t\tif(now - prev >= wait){\t\t// 时间戳大于设置的时间\n\t\t\tfn.apply(context, args);\n\t\t\tprev = Date.now();\t// 记录前一个时间\n\t\t}\n\t}\n}\n\n// window.addEventListener('scroll', debounce(() => {\n //    console.log(Math.random());\n// }, 500));\n// window.addEventListener('scroll', throttle1(() => {\n// \tconsole.log(Math.random());\n// }, 1000));\nwindow.addEventListener('scroll', throttle2(() => {\n\tconsole.log(Math.random());\n}, 1000))\n````\n- JSON.stringfy(obj, [replace, space])\n  - 巧用第二个参数，可以实现json对象的过滤替换。\n  - 第三个参数，是缩进的空格数。    \n  - 如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。\n```\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    hobby: 'ball'\n};\n\nlet str1 = JSON.stringify(obj1);\nconsole.log(str1, typeof str1, str1.constructor === String);    // {\"name\":\"zero\",\"age\":22,\"hobby\":\"ball\"} string true\nlet str2 = JSON.stringify(obj1, (key, value) => {\n    if(value === 'zero') {\n        return 'Ertsul.'\n    }else {\n        return value;\n    }\n});\nconsole.log(str2);  // {\"name\":\"Ertsul.\",\"age\":22,\"hobby\":\"ball\"}\n\nlet obj2 = {\n    num: 100,\n    toJSON(){\n        return 'apple'\n    }\n};\n\nlet str3 = JSON.stringify(obj2);\nconsole.log(str3);  // apple\n```\n\n- 数组的 sort()\nsort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。\n如果要对数组的数字进行排序，则需要：\n>array.sort((val1, val2) => {return val - val2});\n\n通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。\n\n```\nlet arr10 = [1, 2, 19, 12, 22];\nconsole.log(arr10.sort()); // [1, 12, 19, 2, 22]\nconsole.log(arr10.sort((val1, val2) => {  // [1, 2, 12, 19, 22]\n  return val1 - val2;\n}));  \n```\n\n- reduce函数\n> reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。\n\n其完整的函数为： \n\n```\narr.reduce((prev, next, cur, srcArr) => {\n  ......\n}, initVal)\n```\n\n- prev: 上次返回的值\n- next: 下一个数组元素的值\n- cur: 当前数组元素的索引值\n- scrArr: 源数组\n- initVal: 设置第一次的 **prev**\n\n例子 1：\n```\nlet arr = ['apple', 'pear', 'bananas'];\narr.reduce((prev, next, cur, arr) => {\n  console.warn(prev, next, cur, arr);\n  return next;\n}, 'fruit')\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-65c2bd1bf155dfaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n例子 2：统计一个数组中单词出现的次数\n```\n// 统计数组中单词出现的次数\nlet arr = [\"apple\", \"orange\", \"apple\", \"orange\", \"pear\", \"orange\", \"bananas\", \"bananas\"];\nfunction getCount(arr) {\n  return arr.reduce((prev, next, cur) => {\n    prev[next] = (prev[next] + 1) || 1\n    return prev;\n  }, {})\n}\nconsole.warn(getCount(arr));  // {apple: 2, orange: 3, pear: 1, bananas: 2}\n```\n\n- Object.seal()\n防止对象纂改：不能添加也不能删除属性\n\n```\nlet obj = {\n  name: 'Ersul'\n}\nObject.seal(obj); // 防止对象纂改：不能删除也不能添加属性\ndelete obj.name;\nconsole.warn(obj.name); // Ertsul\nobj.age = 22;\nconsole.warn(obj.age); // undefined\n```\n\n- Object.freeze()\n冻结对象，不能修改对象任何属性的值。如若\n\n```\nlet obj = {\n  name: 'Ersul'\n}\n\nObject.freeze(obj); // 冻结对象，不能修改属性的值\nobj.name = 'Zero';\nconsole.warn(obj.name); // Ertsul\n```\n\n- 数组字符串的相互转化\n```\n// 数组 --> 字符串 : join()\nlet arr3 = [1, 2, 3, 4, 5];\nconsole.log(arr3.join('-'));\n// 字符串 --> 数组 : split()\nlet str = 'apple,pear,bananas';\nconsole.log(str.split(','));\n```","tags":["frontEnd","js","es6"]},{"title":"webpack学习笔记","url":"/2019/02/16/webpack学习笔记/","content":"\n## 项目构建\n- 新建项目文件夹\n- npm init\n- 设置项目目录结构，结构如下：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-bd9163add73e9ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- **build** 目录是 webpack 打包后的生成目录，**index.html** 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。\n- **src** 目录是项目源文件，**template.html** 是 html 文件模板。\n- **webpack.config.js** 是配置 **webpack** 的总文件。\n\n```\nmodule.exports = { ... }\n```\n\n## 模式 mode\n\n```\nmode: \"development\", // development or production\n```\n\n## 入口 entry\n设置打包的入口文件, entry: filepath\n\n```\nentry: \"./src/index.js\", // 入口\n```\n\n## 输出 output\n设置打包后的输出文件，output: { ... }\n\n```\noutput: { // 输出\n  filename: \"bundle.[hash:8].js\",\n  path: path.resolve(__dirname + '/build'),\n  // publicPath: \"http://\", // 公共路径前缀\n},\n```\n注：\n- **path** 后面应是绝对路径。\n- **bundle.[hash:8].js** 中的 **[hash:8]** 可以在每次打包后都在文件后面追加 hash 值。\n\n通过上面三项，可以实现一个简单的 **webpack** 打包配置。在 **package.json** 添加脚本或直接执行 **./node_modules/.bin/webpack** 即可实现打包：\n\n```\n\"build\": \"./node_modules/.bin/webpack\",\n```\n\n## webpack-dev-server\nwebpack 开发服务器，用于开发时候的配置：\n- yarn add taco --dev webpack-dev-server / npm install --save-dev webpack-dev-server\n- 基本配置如下：\n\n```\ndevServer: { // 开发服务器\n  port: 3001,\n  contentBase: path.resolve(__dirname + '/build'), // 本地服务器目录\n  progress: true, // 进度条\n  open: true, // 自动打开浏览器\n  compress: true, // 压缩\n  // 1. 代理\n  proxy: {\n    \"/api\": {\n      target: \"\",\n      pathRewrite: {\n        \"/api\": \"\"\n      }\n    }\n  },\n  // 2. 用 express 内置钩子模拟数据\n  before(app) {\n    app.get(\"/api\", (req, res) => { ... })\n  },\n  // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件\n},\n},\n```\n\n- 在 **package.json** 添加脚本即可：\n\n```\n\"dev\": \"webpack-dev-server\"\n```\n\n## source-map && eval-source-map && cheap-module-source-map && cheap-module-eval-source-map\n\n作用：源码映射，报错时显示出错的位置。\n\n- source-map：会单独生成一个 **sourcemap** 文件；会显示行列。\n- eval-source-map：不会单独生成一个 **sourcemap** 文件，会将生成的 **sourcemap** 放到打包后的 **html** 文件；会显示行和列。\n- cheap-module-source-map：会生成 **sourcemap** 文件，不会显示列。\n- cheap-module-eval-source-map：不会生成 **sourcemap** 文件，集成在 **html** 文件中，不会显示列。\n\n```\ndevtool: \"source-map\", // 源码映射\n```\n\n## watch\n作用：监控代码实时变化，进行编译打包。\n\n```\nwatch: true, // 监控代码实时变化，进行编译打包\nwatchOptions: {\n  poll: 1000, // 多毫秒监控一次\n  aggreatement: 500, // 防抖\n  ignored: \"node_modules\" // 忽略文件夹\n},\n```\n\n## resolve\n作用：解析第三方包\n\n```\nresolve: { // 解析 第三方包\n  modules: [\n    path.resolve(\"node_modules\"), // 在当前目录下查找模块 \n    path.resolve(\"other_modules\"), // 在其他目录下查找模块 \n  ],\n  // 自动添加扩展名，主要是 import 时候使用, 依次解析\n  extensions: [\".js\", \".css\", \".json\", \".vue\"],\n  // 比如引用 bootstrap 的 css 样式\n  // 方式一： bootstrap 的主入口\n  mainFields: [\"style\", \"main\"],\n  // 方式二：别名  \n  // alias: {\n  //   bootstrap: \"bootstrap/dist/css/bootstrap.css\"\n  // }\n},\n```\n\n## 插件\nwebpack 的插件配置是一个数组，里面存放着各种各样的插件。\n\n```\nplugins: [\n new pluginName(...)\n]\n```\n\n#### html-webpack-plugin\n插件作用：打包时候自动根据 **html** 模板生成目标 **html** 文件，自动生成目标打包目录；另外，可配置 **html** 的相关打包配置，如：压缩，去双引号等。\n\n```\nnew HtmlWebpackPlugin({\n  filename: \"index.html\", // 目标文件名称\n  template: path.resolve(__dirname + '/src/template.html'), // 模板文件\n  minify: { // 压缩配置\n    removeAttributeQuotes: true, // 去双引号\n    collapseWhitespace: true, // 不换行\n  },\n  hash: true // 生成 hash 戳\n})\n```\n\n#### mini-css-extract-plugin\n作用：将生成的 **css样式** 抽离成一个 **css文件**，并将该样式文件引进目标 **html** 文件中。\n\n```\nplugins: [ // 插件\n  new MiniCssExtractPlugin({\n    filename: \"main.css\",\n  })\n],\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序\n      \"css-loader\"\n    ]\n  }]\n}\n```\n\n注：这里抽离出来的 **main.css** 文件并没有压缩，要通过手动添加以下两个插件到优化项：\n- optimize-css-assets-webpack-plugin\n- uglifyjs-webpack-plugin\n\n```\noptimization: { // 优化项\n  minimizer: [\n    new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件\n    new UglifyjsWebpackPlugin({\n      cache: true,\n      parallel: true,\n    }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置\n  ]\n},\n```\n\n#### optimize-css-assets-webpack-plugin\n插件作用：压缩抽离出来的 **main.css** 文件。但是，使用了 **optimize-css-assets-webpack-plugin** 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 **uglifyjs-webpack-plugin** 。\n\n#### uglifyjs-webpack-plugin\n插件作用：压缩打包后的 **js** 文件。\n\n#### clean-webpack-plugin\n作用：清理文件\n\n```\nplugins: [\n new CleanWebpackPlugin(\"./build\")\n]\n```\n\n#### copy-webpack-plugin\n作用：将某些文件拷贝到打包后的文件夹。\n\n```\nnew CopyWebpackPlugin([\n  {from: \"./copy\", to: \"./\"}\n])\n```\n\n#### banner-plugin\n作用：版权声明，是 **webpack** 的内置模块。\n\n```\nnew webpack.BannerPlugin(\"@copyright by Ertsul\")\n```\n\n#### webpack.DefinePlugin({ ... })\n作用：定义环境变量。\n\n```\nplugins: [\n  new webpack.DefinePlugin({\n    DEV: JSON.stringify(\"development\"),\n    PRO: JSON.stringify(\"production\")\n  })\n]\n```\n\n#### webpacfk.IgnorePlugin()\n作用：忽略模块的引进\n\n```\nplugins: [\n  new webpack.IgnorePlugin(/\\./locale/, /moment/)\n]\n```\n\n注：如果直接使用 **DEV: 'development'** 的话，会把 **DEV** 直接替换为 **引号内部的内容**。如：**console.log(DEV)**，会变成 **console.log(dev)**，最后的结果是 **undefined**。所以，需要通过 **JSON.stringfy()** 进行转化。\n\n## 模块 module\n模块主要是各种 **loader**，作用：解析各种类型的文件。\n\n```\nmodule: { \n rules: [\n   {\n     test: regx,\n     use: [loadName]\n   }\n ]\n}\n```\n\n#### css-loader / style-loader\n- css-loader：主要是用于解析在 **css** 文件中通过 **@import** 方式引进其他的 **css** 文件。\n- style-loader: 主要是用于将 **js** 文件中通过 **require** 方式引进的 **css** 文件插入到目标 **html** 文件的 **head** 中（插到最后，层级最高）。\n\n```\n// 数组方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\"style-loader\", \"css-loader\"] // loader 数组\n  }]\n}\n// 对象方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\n      {\n        loader: \"style-loader\",\n        options: {\n          insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n        }\n      }, \n      \"css-loader\"\n    ]\n  }]\n}\n```\n注：**loader** 是从右向左、从下到上的执行顺序，故：**use: [\"style-loader\", \"css-loader\"]**\n\n#### postcss-loader + autoprefixer\n这两个的配合使用可以自动添加 **css** 的浏览器前缀。\n- autoprefixer：自动添加 **css** 的浏览器前缀。\n- postcss-loader：loader 处理 autoprefixer。\n\n```\n// 使用 postcss-loader \nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader,\n      \"css-loader\",\n      \"postcss-loader\" // 注意顺序\n    ]\n  }]\n}\n```\n\n- 根目录下新建 postcss.config.js 文件\n\n```\nmodule.exports = {\n  plugins: [\n    require(\"autoprefixer\")\n  ]\n}\n```\n\n#### babel-loader + @babel/core + @babel/preset-env\n作用：转化 es6 语法\n  \n```\nmodule: { // 模块\n  rules: [{\n    test: /\\.js$/,\n    use: {\n      loader: \"babel-loader\",\n      options: { // 用 babel-loader 需要把 es6 转化为 es5\n        presets: [\n          \"@babel/preset-env\", // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块\n        ],\n        // plugins: [...] // 其他的小插件\n      }\n    }\n  }]\n}\n```\n\n#### expose-loader\n作用：暴露全局的 **loader**，暴露到 **window** 上。\n\n```\n// 一般情况\nimport $ from 'jquery';\nconsole.log(window.$); // undefined\n// 内联 loader 方式\nimport $ from 'expose-loader?$!jquery';\nconsole.log(window.$);\n// 其他方式：在每个模块中注入\nnew webpack.ProvidePlugin({\n  $: \"jquery\"\n})\nconsole.log($);\nconsole.log(window.$); // undefined\n```\n\n#### file-loader && url-loader && html-withimg-loader\n在 **webpack** 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。\n\n- file-loader：**js** 文件中通过 **import** 方式引进图片。\n- html-withimg-loader：**html** 文件中通过 **scr** 方式引进图片。\n- 在 **css** 中使用图片，**style-loader** 已经做了处理。\n- url-loader：将图片转化为 **base64**\n\n```\nmodule: {\n  rules: [\n    {\n      test: /\\.(png|jpg|gif)$/,\n      use: {\n        loader: \"url-loader\",\n        options: {\n          limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader\n          // publicPath: \"http://\", // 公共路径前缀\n        }\n      }\n    },\n    {\n      test: /\\.html$/,\n      use: [\"html-withimg-loader\"]\n    }\n  ]\n}\n```\n`\n## 模块 module -- noParse\n作用：不解析指定包的依赖关系。\n\n```\nmodule: {\n  noParse: /jquery/\n}\n```\n\n## 模块 module -- exclude\n作用：排除\n\n```\nmodule: {\n  exclude: /node_module/\n}\n```\n\n## 模块 module -- include\n作用：包含\n\n```\nmodule: {\n  include: /src/\n}\n```\n\n\n\n## 区分不同环境，实现开发和生产配置的分离\n将 **webpack** 的配置文件划分为以下文件：\n\n- webpack.base.js：基本、共有的配置。\n- webpack.dev.js：开发配置。\n- webpack.prod.js：生产配置。\n\n使用 **webpack-merger** 插件：\n- 安装 **webpack-merge** 插件；\n- 引进目标模块\n\n```\nimport { smart } from \"webpack-merge\";\n```\n\n- 使用\n\n```\nconst base = require(\"webpack.base.js);\n\nmodule.exports = smart(base, {\n  ...\n})\n```\n\n## webpack 自带优化\n- **import** 语法（生成环境），**tree-shaking** 自动删除没有用到的代码；\n- **es6** 模块会把语法放到 **default** 上；\n- 自动省略可以简化的代码；\n- **scope hosting**，作用域提升。\n\n## webpack 懒加载\n- 通过 **import** 实现（该语法内部由 **jsonp** 实现），返回的是一个 **promise**。\n- 要在 **babel-loader** 中添加 **@babel/plugin-syntax-dynamic-import** 插件。\n- **vue** 和 **react** 的l懒加载都是这样实现的。\n\n```\n/*\n* 模拟点击加载 source.js 的内容\n*/\n// 1\n{\n  loader: 'babel-loader',\n  options: {\n    presets: [\n      '@babel/preset-env'\n    ],\n    plugins: [\n      '@babel/plugin-syntax-dynamic-import'\n    ]\n  },\n}\n// 2\nlet btn = document.createElement('button');\nbtn.innerHTML = 'btn';\nbtn.addEventListener('click', function () {\n  // 内部由 jsonp 实现动态加载文件\n  import('./source.js')\n    .then(data => {\n      console.log(data);\n    })\n})\ndocument.body.appendChild(btn);\n\n```\n\n点击按钮后结果如下：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fa79ce43578285a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 热更新 / 热替换 / Hot Module Replacement / HMR\n热更新：页面只更新改动的模块。\n\n- **devServer** 开始 **hot** 热更新模块。\n- 使用 **webpack** 内置热更新插件。\n  - NamedModulesPlugin\n  - HotModuleReplacementPlugin\n\n```\n// devServer 配置\ndevServer: {\n  port: 8089,\n  contentBase: path.resolve(__dirname + '/dist/'),\n  compress: true,\n  progress: true,\n  // open: true\n  hot: true, // 开启热更新，只更新更改的模块\n},\n// 添加插件\nplugins: [\n  new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径\n  new webpack.HotModuleReplacementPlugin(), // 热更新\n]\n```\n\n- 使用热更新\n\n```\nimport source from './source.js';\n\nconsole.log(source);\n\n// 添加热更新操作，不然不会实现热更新\nif (module.hot) {\nmodule.hot.accept('./source.js', () => {\n  require('./source.js');\n})\n```\n\n## 多线程打包\n使用 **happypack** 可以实现多线程打包。\n\n- 安装并引进 **happypack**;\n- 改写 **module**;\n- **plugin** 配置。\n\n```\n// 改写 module\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      // use: {\n      //   loader: 'babel-loader',\n      //   options: {\n      //     presets: [\n      //       '@babel/preset-env'\n      //     ]\n      //   }\n      // }\n      use: {\n        loader: 'Happypack/loader?id=js',\n      }\n    },\n  ]\n}\n// plugin 配置\nplugins: [\n  new Happypack({\n    id: 'js',\n    use: [\n      {\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            '@babel/preset-env'\n          ]\n        }\n      }\n    ]\n  }),\n]\n```\n\n## 多页面打包\n\n```\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n    home: \"./src/home.js\",\n    about: \"./src/about.js\",\n    other: \"./src/other.js\"\n  },\n  output: {\n    path: path.resolve(__dirname + \"/build/\"),\n    filename: \"[name].js\",\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"home.html\",\n      chunks: [\"home\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"other.html\",\n      chunks: [\"other\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"about.html\",\n      chunks: [\"about\"]\n    }),\n  ]\n}\n```\n\n## 多页面打包抽离公共代码块\n打包 **多页面** 需要将公共的代码块抽离出来进行优化：\n\n```\noptimation: {\n  splitChunks: {  // 分割代码块\n    cacheGroups: {  // 缓存组\n      common: {  // 公共的模块\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      },\n      vender: {  // 第三方模块\n        priority: 1,  // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用\n        test: /node_modules/,  // 抽离出来\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      }\n    }\n  }\n}\n```\n\n## Tapable\n**webpack** 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 **Tapable**，通过 **Tapable** 实现各种钩子（如同步钩子异步钩子）。而 **Tapable** 核心是依赖于 **发布订阅者模式**。\n\n- 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tap** 注册。\n\n使用：\n```\nconst { SyncHook } = require('tapable');\n\nclass Hook {\n  constructor() {\n    this.hooks = {\n      arch: new SyncHook(['name'])\n    }\n  }\n  tap() { // 注册监听事件\n    this.hooks.arch.tap('vue', (name) => {\n      console.log('vue', name);\n    })\n    this.hooks.arch.tap('react', (name) => {\n      console.log('react', name);\n    })\n  }\n  start() { // 开始\n    this.hooks.arch.call('Ertsul')\n  }\n}\nlet h = new Hook();\nh.tap();\nh.start();\n```\n\n- 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tapAsync** 注册。\n\nsetTimeout()方式使用：\n\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapAsync('vue', (name, cb) => {\n      setTimeout(() => {\n        console.log('vue', name);\n        cb && cb();\n      }, 1000)\n    })\n    this.hooks.arch.tapAsync('react', (name, cb) => {\n      setTimeout(() => {\n        console.log('react', name);\n        cb && cb();\n      }, 1000)\n    })\n  }\n  start() {\n    this.hooks.arch.callAsync('Ertsul', () => {\n      console.log('All finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\nPromise()方式使用：\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapPromise('vue', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('vue', name);\n          resolve();\n        }, 1000)\n      })\n    })\n    this.hooks.arch.tapPromise('react', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('react', name);\n          resolve();\n        }, 1000)\n      })\n    })\n  }\n  start() {\n    this.hooks.arch.promise('Ertsul').then(() => {\n      console.log('hook all finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\n#### Synchook 同步钩子\n实现：\n```\nclass Synchook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      task(...args);\n    })\n  }\n}\n\nlet hook = new Synchook(['Synchook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n![image.png](https://upload-images.jianshu.io/upload_images/659084-1d12026d2f938c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncBailHook 同步熔断钩子\nSynchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。\n\n实现：\n```\n// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数\nclass Syncbailhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let ret = ''; // 当前函数的返回值\n    let index = 0; // 当前任务数组的索引\n    do {\n      ret = this.tasks[index++](...args);\n    } while (ret === undefined && index < this.tasks.length)\n  }\n}\n\nlet hook = new Syncbailhook(['Syncbailhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-3a46a477c8b08d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncWaterfallHook 同步瀑布钩子\nSyncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。\n\n实现：\n```\n/**\n * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系\n * 上一个函数的执行返回结果在当前函数的输入\n */\nclass Syncwaterfallhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let [first, ...others] = this.tasks;\n    let ret = first(...args);\n    others.reduce((prev, current) => {\n      return current(prev);\n    }, ret)\n  }\n}\n\nlet hook = new Syncwaterfallhook(['Syncwaterfallhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return 'vue learnt';\n})\nhook.tap('react', (data) => {\n  console.log('react', data);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-5ccbc856cac523cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncLoopHook 同步循环钩子\n同步循环钩子回让某个函数执行一定的次数。\n\n实现：\n```\n// Tapable Syncloophook 同步循环钩子\nclass Syncloophook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      let ret = '';\n      do {\n        ret = task(...args);\n      } while (ret != undefined);\n    })\n  }\n}\n\nlet hook = new Syncloophook(['Syncloophook']);\nconst total = 3;\nlet index = 0;\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return ++index === total ? undefined : 'continue';\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fd5d933715541d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### AsyncParallelHook 异步并发钩子 回调函数方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapAsync(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  callAsync(...args) { // 发布事件\n    let finalCallback = args.pop();\n    let index = 0;\n    const done = () => {\n      index++;\n      if (index === this.tasks.length) {\n        finalCallback();\n      }\n    }\n    this.tasks.forEach(task => {\n      task(...args, done);\n    })\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapAsync('vue', (name, cb) => {\n  setTimeout(() => {\n    console.log('vue', name);\n    cb && cb();\n  }, 1000)\n})\nhook.tapAsync('react', (name, cb) => {\n  setTimeout(() => {\n    console.log('react', name);\n    cb && cb();\n  }, 1000)\n})\nhook.callAsync('Ertsul', () => {\n  console.log('All hook finished!');\n});\n```\n\n#### AsyncParallelHook 异步并发钩子 Promise方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapPromise(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  promise(...args) { // 发布事件\n    let tasks = this.tasks.map(task => task(...args));\n    return Promise.all(tasks);\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapPromise('vue', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('vue', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.tapPromise('react', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('react', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.promise('Ertsul').then(() => {\n  console.log('All hooks finished!');\n})\n```\n\n#### AsyncSeriesHook 异步串行钩子\n#### AsyncWaterfallHook 异步瀑布流钩子","tags":["frontEnd","webpack"]},{"title":"hello-hexo","url":"/2019/02/16/hello-hexo/","content":"## Hello Hexo\n决定把简书的文章转移到 **hexo** 上。"}]