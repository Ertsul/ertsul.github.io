[{"title":"websocket","url":"/2019/02/17/websocket/","content":"## HTTP/HTTPS 协议\n\n- 一个 **request** 对应一个 **response**。一般使用 **轮询** 机制获取信息。\n- 虽然后期有 **keep-alive**，可以一次连接中处理多个 **request** 合并发送，接收多个 **response**，对每个请求仍然需要单独发 **header**。\n- **HTTP** 的 **response** 是被动的，通信只能由客户端发起，做不到服务端主动向客户端推送信息。\n- **HTTP** 是无状态协议。\n- 需要三次握手。\n- HTTP：TCP + HTTP\n- HTTPS：TCP + HTTP + TLS\n\n#### ajax 轮询\n\n**ajax 轮询** 是指客户端 **不断** 向服务器发送资源请求 **request**，服务端不管有无目标资源，都会返回 **response** 结果。这样就要求服务器拥有更好的处理速度。\n\n#### long poll / 长轮询\n\n**long poll** 比 **ajax 轮询** 好点，**不会不断** 向服务器发送资源请求 **request**，一旦接受客户端的请求，有资源就返回；无资源就挂起，直到有资源才返回 **response** 结果（有且仅有返回一次）。高并发，需要服务器可以同时处理多个请求的能力。\n\n## websocket 协议\n\n- **websocket** 是 **html5** 出的协议。\n- **websocket** 是一个持久化的协议，**websocket** 只需要一次请求（一次 **HTTP 握手** ），就可以得到所需的资源。\n- 服务端可以 **主动** 向客户端推送信息，客户端也可以 **主动** 向服务端推送消息，实现“双向平等”，是属于服务器推送技术的一种。\n- 与 **HTTP** 有较好的兼容性，在握手阶段采用 **HTTP** 协议。\n- 默认端口 **80** and **443**。\n- 数据格式轻量，性能开销小，通信高效，可以发送文本，也可以二进制数据。\n- 没有同源策略。\n- WS：TCP + WS\n- WSS：TCP + WS + TLS\n\n#### websocket 握手\n\n```\nGET /chat HTTP/1.1\nHost: server.example.com\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw==\nSec-WebSocket-Protocol: chat, superchat\nSec-WebSocket-Version: 13\n```\n\n- Upgrade/Connection：通知服务器发起的是 **wesocket** 协议。\n- Sec-WebSocket-Key：浏览器随机生成的 **Base64 encode** 的值，用于验证服务器是不是 **websocket 协议**。\n- Sec-WebSocket-Protocol：用户定义的字符串，用来区分 **同 url** 下，不同的服务所需要的协议。\n- Sec-WebSocket-Version：协议版本。\n\n#### 服务器返回\n\n```\nHTTP/1.1 101 Switching Protocols\nUpgrade: websocket\nConnection: Upgrade\nSec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk=\nSec-WebSocket-Protocol: chat\n```\n\n- Upgrade/Connection：通知客户端升级的是 **websocket** 协议。\n- Sec-WebSocket-Accept：经服务器确认，加密后的 **Sec-WebSocket-Key**。\n- Sec-WebSocket-Protocol：最终使用的协议。\n\n#### 代码实现\n\n```\nws.addEventListener('open', function () {\n    console.log('Open the websocket...');\n    ws.send('Hello websocket...');\n});\nws.addEventListener('message', function (e) {\n    console.log('Ready state: ' + ws.readyState, 'Receive the websocket message...' + e.data);\n    ws.close();\n    setTimeout(() => {\n        console.log('Ready state: ' + ws.readyState);\n    }, 1000)\n});\nws.addEventListener('close', function () {\n    console.log('Ready state: ' + ws.readyState, 'Close the websocket...');\n})\n```\n\n结果：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-021a1bb1915811bd.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n\n参考：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-d06ed1bfe9c9fadb.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- https://www.zhihu.com/search?type=content&q=websocket\n- http://www.ruanyifeng.com/blog/2017/05/websocket.html","tags":["frontEnd"]},{"title":"用户认证小总结","url":"/2019/02/17/用户认证小总结/","content":"## 用户认证\n\n一般的用户认证流程如下图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-bdfa6d0008a02e53.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/800)\n\n但是，这种模式的扩展性不好。单个服务器没问题，如果多个服务器集群，要求共享 **session** ，每个服务器都能访问到 **session** 。\n\n- 解决方案一：**session** 数据持久化，写入数据库或者其他持久层。各个服务器收到请求后，向持久层发送数据请求。\n  - 缺点：工程量大。\n- 解决方案二：服务器不保存 **session** 数据，所有的数据保存在客户端，每次请求都发回服务器。如：JWT(Json Web Token)。\n\n## JWT\n\n**JWT** 服务器不保存 **session** 数据，在服务器认证之后，返回一个 **JSON** 对象。格式如下：\n\n```\n{\n    \"姓名\": \"zero\",\n    \"角色\": \"管理员\",\n    \"到期时间\": \"2018年10月6日0点0分\"\n}\n```\n\n之后，客户端与服务器的用户认证都靠这个 **JSON** 对象，当然，这个对象后面会加上签名，保证数据不被篡改。\n\n#### JWT 的数据结构\n\n- **JWT** 是一个很长的字符串，中间用 **\\.** 分隔，内部没有换行。\n- 组成由三个部分：**Header.Payload.Signature**\n  - Header：头部。**JSON** 对象，描述 **JWT** 的元数据。\n  - Payload：负载。**JSON** 对象，存放实际需要传递的数据；不加密。\n  - Signature：签名。对 **Header** 和 **Payload** 的签名，防止数据被篡改。\n\nHeader 格式：\n\n```\n{\n  \"alg\": \"HS256\",   // 签名的算法\n  \"typ\": \"JWT\"      // token 类型\n}\n```\n\nPayload 七个字段：\n\n- iss (issuer)：签发人\n- exp (expiration time)：过期时间\n- sub (subject)：主题\n- aud (audience)：受众\n- nbf (Not Before)：生效时间\n- iat (Issued At)：签发时间\n- jti (JWT ID)：编号\n\n#### JWT 的使用方式\n\n- 存储在 **cookie** 中。\n- 存储在 **localStorage** 中。\n- 客户端每次与服务器进行通信的时候，都会带上 **JWT**。\n\n参考：\n\n- http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html\n\n","tags":["frontEnd"]},{"title":"web safe","url":"/2019/02/17/web-safe/","content":"## CSRF : Cross Site Request Forgery\n\n**CSRF** 跨站请求伪造。\n是一种劫持受信任用户向服务器发送非预期请求的攻击方式。简而言之：用户在登录的情况下访问了钓鱼网站，钓鱼网站通过用户向其他网站发送请求，这样就达到了模拟用户的目的。具体实现如下图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-9ce93c3bff5d427b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 防御手段\n\n- 验证码实现用户验证。验证码强制用户必须与应用进行交互，才能完成最终的请求。\n- 通过 referer 实现用户验证。根据 **HTTP** 协议，在 **HTTP** 头中有一个字段叫 **Referer**，它记录了该 **HTTP** 请求的 **来源地址**。通过 **Referer Check**，可以检查请求是否来自合法的\"源\"。\n- 通过 token 实现用户验证。\n- 尽量不要在页面的链接中暴露用户隐私信息。\n- 对于用户修改删除等操作最好都使用 post 操作。\n- 避免全站通用的 cookie，严格设置 cookie 的域。\n\n## XSS : Cross Site Script\n\n**XSS** 跨站脚本攻击。\n攻击者向用户的网站嵌入的 js 脚本代码，当用户访问该网站的时候，该 js 脚本代码就会被执行，从而达到攻击用户的目的。\n\n#### 反射型 XSS 攻击\n\n又称非持久性跨站脚本攻击。发出请求时，XSS 代码出现在 **URL** 中，作为输入提交到服务器端，服务器端解析后响应，XSS 随响应内容一起返回给浏览器，最后浏览器解析执行 XSS 代码。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。\n比如：\n\n```\nhttp://www.test.com/message.php?send=<script>alert(‘foolish!’)</script>！\n```\n\n#### 存储型 XSS 攻击\n\nXSS 提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交 XSS 代码。这种攻击方式的稳定性很好。\n比如：\n\n> 攻击者在 value 填写`<script>alert(‘foolish!’)</script>`【或者 html 其他标签（破坏样式。。。）、一段攻击型代码】；将数据存储到数据库中；其他用户取出数据显示的时候，将会执行这些攻击性代码。\n\n#### 具体方式\n\n- 攻击者向服务器注入 js 代码。\n- 诱导用户访问受到攻击的网站。\n- 用户访问受到攻击的网站，执行注入的 js 代码。\n\n#### XSS 防御方式\n\n- HttpOnly\n- 输入检查\n- 输出检查\n\n参考链接：\n\n- https://www.cnblogs.com/shytong/p/5308667.html\n- https://github.com/dwqs/blog/issues/68\n- https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label3\n","tags":["frontEnd","web-safe"]},{"title":"Ajax和跨域总结","url":"/2019/02/17/Ajax和跨域总结/","content":"## Ajax（JavaScript实现）\n#### 简介\nAjax（Async Javascript And Xml）：异步Js和Xml，意思就是用Js执行异步网络请求。作用主要是在不重新加载**全部网页**的情况下，对**部分页面**进行更新。\n\n#### 创建XMLHttpRequest对象\n除了IE5和IE6不支持之外（支持ActiveXObject对象），几乎现在所有的有内建的XMLHttpRequest对象。所以在创建请求对象之前判断下就好了：\n\n````\nlet xhr = null;\nxhr = window.XMLHttpRequest ? new xmlHttpRequest() : new ActiveXObject(\"Microsoft.XMLHTTP\")\n// 或者\nif(window.XMLHttpRequest){\n    xhr = new XMLHttpRequest()\n}else{\n    xhr = new ActiveXObject('Microsoft.XMLHTTP')\n}\n````\n\n#### 通过open()和send()向服务器发送请求\n- xhr.open(method, url, async)\n这个方法的参数分别是：method请求的类型GET或者POST；URL请求的文件在服务器上的地址；async是否异步请求true或者false（一般不设置为false）。\n- xhr.send()：发送请求。\n- xhr.setRequestHeader(header, value)：如果是POST的话，要设置发送的HTTP头，然后通过send方法发送内容。参数分别是：发送的头部名称，头部的值。一般都是固定的。\n\n````\n// 向浏览器发送请求\nxhr.open('GET', './server.php', true)\n// 添加HTTP头（POST方法）\nxhr.setRequestHeader('Content-Text', 'application/x-www-form-urlencoded')   \nxhr.send()\n````\n\nGET方法不需要参数，POST方法则需要把body参数；如果要想向服务器发送相关的参数，则通过open里面的第二个参数url进行发送，具体实现如下代码：\n\n````\nurl = \"./filePath?paramName=\" + paramValue + ...;\n````\n\n#### 判断准备状态\n\n````\nxhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n        ...\n    }\n}\n````\n- xhr.onreadystatechange方法中，每当readyState改变时，就会触发xhr.onreadystatechange事件。\n- readyState属性：存有XMLHttpRequest的状态信息。0：请求未初始化；1：服务器链接已经建立；2：请求已经接受；3：请求处理中；4：请求已完成，且响应已就绪。一共有5个状态，所以onreadystatechange事件会被触发5次。\n- 实际上onreadystateschange是通过回调函数实现的，即：每当readyState的状态改变时，这个回调函数就会被执行。\n- status属性：表示响应的结果。\n\n总的代码如下：\n````\ndocument.getElementById('btn').onclick = function () {\n// 创建请求对象（先判断浏览器类型）\n// var xhr = null;\n// if (window.XMLHttpRequest) {\n//     xhr = new XMLHttpRequest()\n// } else {\n//     xhr = new ActiveXObject('Microsoft.XMLHTTP')\n// }\nxhr = (window.XMLHttpRequest) ? (new XMLHttpRequest()) : (new ActiveXObject('Microsoft.XMLHTTP'))\n// 判断响应状态并执行相关的操作\nxhr.onreadystatechange = function () {\n    if (xhr.readyState == 4 && xhr.status == 200) {\n        let data = xhr.responseText\n        console.log(data);\n        document.getElementById('myDiv').innerText = data\n    }\n}\n// 向浏览器发送请求\nlet url = \"./server.txt\"\nxhr.open('GET', url, true)\n// 添加HTTP头（POST方法）\n// xhr.setRequestHeader('Content-Text', 'application/x-www-form-urlencoded')\nxhr.send(null);\n}\n````\n![异步1.gif](https://upload-images.jianshu.io/upload_images/659084-b5b344a3944ba224.gif?imageMogr2/auto-orient/strip)\n\n但是，由于在**同源策略**的作用下，浏览器只能同源的其他域的资源，先看看什么是同源策略～\n\n## 同源策略/SOP（Same origin policy）\n来自百度的解释：\n> 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能（防止CSRF/XSRF攻击：跨站请求伪造）。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。\n\n简单来说，就是浏览器只能请求同源的其他域的资源，即同源的网页才能相互获取资源，而不能访问其他域的资源；但是有一个例外，同源策略不会阻止动态脚本插入到文档中；其中，**<script>\\</script>**是开放策略；当web网页执行一个脚本之前，会检查是否同源，只有同源才会被执行，非同源则会被拒绝访问。\n截取网上的图片说明同源：\n![image.png](http://upload-images.jianshu.io/upload_images/659084-80411ea5e317ed19.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/400)\n\n## 跨域\n跨域就是突破同源策略的限制，获取其他源的资源。\n非同源主要有三种行为会受到限制：\n- Cookie,LocalStorage和IndexDB无法读取。\n- DOM无法获取。\n- Ajax无法获取。\n\n#### JSONP\nJSONP是实现跨域的常用方法，但是JSONP只能实现GET方法。实际上是是利用了浏览器允许跨域引用JavaScript资源（script标签是开放策略）。\n\n下面举一个例子：我们从360浏览器首页的天气查询获取天气查询的异步请求地址；这里我们实现通过本地localhost服务器跨域请求360的天气查询，来说明JSONP怎么实现跨域。\n我们请求资源的地址为：\nhttps://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&v=2&param=weather&app=hao360&_jsonp=__jsonp21__&t=2521600\n在浏览器中打开这个地址，我们会得到这样的数据：\\_\\_jsonp21\\_\\_({...})。\n解释：JSONP返回的通常是以函数的形式返回，前面这个\\_\\_jsonp21\\_\\_是函数名，所以我们需要在我们的代码中事先准备好名称为\\_\\_jsonp21\\_\\_的函数，我们对跨域请求到的数据就是放在这个函数中的，然后动态加载一个**script**节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。\n\n具体代码如下：\n\n````\n // 请求的地址为：https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&v=2&param=weather&app=hao360&_jsonp=__jsonp21__&t=2521600\n\nfunction __jsonp21__(data) {   // 将要处理了的数据放在这个函数中\n    console.log(data);  // 得到的是跨域请求的数据\n    let myDiv = document.getElementById('myDiv')  \n    myDiv.innerHTML = data.area\n}\nwindow.onload = function () { \n    let btn = document.getElementById('btn')\n    btn.addEventListener('click', function () {  \n        let url = 'https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&v=2&param=weather&app=hao360&_jsonp=__jsonp21__&t=2521600'\n        let scriptTag = document.createElement('script')    // 动态创建script标签 \n        scriptTag.setAttribute('src', url)      // 将其他源的地址设置为动态script的src属性\n        // console.log(scriptTag);  // 得到的是script标签\n        document.getElementsByTagName('body')[0].appendChild(scriptTag)  // 将动态创建的script标签添加到html页面中\n    })\n}\n````\n注意：数据处理的函数名要跟跨域返回的函数名一样，这样我们通过JSONP请求数据的时候，服务器才能返回数据。\n最终结果如下：\n![跨域1.gif](https://upload-images.jianshu.io/upload_images/659084-df752a8458c616ff.gif?imageMogr2/auto-orient/strip)\n\n再句一个例子：\n请求地址是http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice\n\n````\nfunction refreshPrice(data) { \nconsole.log(data);\n}\nwindow.onload = function () {  \n    let scriptTag = document.createElement('script')\n    let url = 'http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice'\n    scriptTag.setAttribute('src', url)\n    document.getElementsByTagName('body')[0].appendChild(scriptTag)\n}\n````\n\n## Ajax（JQuery实现）\n在JQuery中，实现Ajax主要是由**$.ajax({...})**方法实现。方法的常用参数有：\n- async：是否实现异步加载，一般来说，是true。\n- type：GET或者POST。\n- url：发送请求的地址。\n- timeout：设置请求的超时时间。\n- success：请求成功后的回调函数。\n- error：请求失败后的回调函数。\n- jsonp：在一个JSONP请求中重写回调函数的名字，默认为callback，用来重新命名回调我们跨域请求时候的函数名字。这个值用来替代在 \"callback=?\" 这种 GET 或 POST 请求中 URL 参数里的 \"callback\" 部分，比如 {jsonp:'onJsonPLoad'} 会导致将 \"onJsonPLoad=?\" 传给服务器。\n- jsonpCallback：为JSONP请求指定一个回调函数名。 \n- dataType：预期服务器返回的数据类型。不指定的话，JQueryhi自动判断。\"xml\": 返回 XML 文档，可用jQuery处理。\n\n>\"html\": 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行；\"script\": 返回纯文本JavaScript代码。不会自动缓存结果。除非设置了\"cache\"参数。注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。（因为将使用DOM的 script标签来加载）；\"json\": 返回JSON数据；\"jsonp\": JSONP格式。使用 JSONP 形式调用函数时，如 \"myurl?callback=?\" jQuery 将自动替换 ? 为正确的函数名，以执行回调函数；\"text\": 返回纯文本字符串。\n\n用JQuery实现同源的Ajax请求：\n\n````\n$(function () {  \n    $('button').on('click', function () {  \n        $.ajax({\n            url: './server.txt',    // 请求地址\n            type: 'GET',    // 请求方式\n            async: true,    // 是否异步\n            success: function (data) {  \n                console.log(data);\n            }   // 请求成功后执行的函数\n        })\n    })\n})\n````\n\n实现结果如下：\n![异步2.gif](https://upload-images.jianshu.io/upload_images/659084-b1fcb9ed574a8a24.gif?imageMogr2/auto-orient/strip)\n\n用JQuery实现非同源的JSONP跨域请求：\n\n````\n$(function () {  \n$('button').on('click', function () {  \n    $.ajax({\n        url: 'https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&v=2&param=weather&app=hao360&_jsonp=__jsonp21__&t=2521600',\n        type: 'GET',\n        async: true,\n        dataType: 'jsonp',\n        jsonp: '_jsonp',\n        jsonpCallback: '__jsonp21__',\n        success: function (data) {  \n            console.log(data);\n            $('#myDiv').html(data.area)\n        },\n        error: function (err) {  \n            console.log(err);\n        }\n    })\n})\n})\n````\n\n实现结果如下：\n![跨域2.gif](https://upload-images.jianshu.io/upload_images/659084-14e8fc745c21ab00.gif?imageMogr2/auto-orient/strip)\n","tags":["frontEnd","js"]},{"title":"3D立体骰子","url":"/2019/02/16/3D立体骰子/","content":"CSS3确实很强大，很多高大上的动画都可以实现，这里来实现下3D立方体，效果图如下：\n![3D立方体.gif](http://upload-images.jianshu.io/upload_images/659084-21400fd37137e37c.gif?imageMogr2/auto-orient/strip)\n## html\n其实，实现3D立方体需要的html十分简单，只需要一个ul标签里面包裹6个li标签，分别用来表示3D立方体的6个面[ 前，下，后，上，左，右 ]。具体代码如下:\n````\n<ul>\n    <li>1</li>\n    <li>2</li>\n    <li>3</li>\n    <li>4</li>\n    <li>5</li>\n    <li>6</li>\n</ul>\n````\n## CSS3\n#### ul\n基本的宽高这些就不说了；作为整个3D立方体的父级元素，需要设置positiion属性为relative，还要最重要的是设置它的动画类型tranform-style为preserve-3d，这样就可以实现它的所有子元素都进行3d动画。\n#### li\n宽高设置为100%，position属性设置为absolute。\n- 前\n设置背景，并且沿着Z轴移动50px，即宽高的一半(为什么得添加这个, 后面用动画进行解释说明)。\n- 下\n设置背景，沿着**X轴**旋转-90deg，作为底面，同样，并且沿着Z轴移动50px。\n- 后\n设置背景，沿着**X轴**旋转-180deg，作为后面，同样，并且沿着Z轴移动50px。\n- 上\n设置背景，沿着**X轴**旋转90deg，作为上面，同样，并且沿着Z轴移动50px。\n- 左\n设置背景，沿着**Y轴**旋转-90deg，作为左面，同样，并且沿着Z轴移动50px。\n- 右\n设置背景，沿着**Y轴**旋转90deg，作为右面，同样，并且沿着Z轴移动50px。\n![效果.gif](http://upload-images.jianshu.io/upload_images/659084-133d15ade6726266.gif?imageMogr2/auto-orient/strip)\n#### 结尾说明\n这里说明上面那个translate，先来看看如果不添加这个属性是怎样的效果：\n![动画.gif](http://upload-images.jianshu.io/upload_images/659084-2e1633af2155afdb.gif?imageMogr2/auto-orient/strip)\n可见，所有的面都交集于立方体的中心点。由于未对6个面作任何动画处理的时候，所有的面都集合在一起。所以在面作旋转的同时需要对其进行Z轴的位移处理。\n#### 代码\n````\n<style>\n    * {\n        margin: 0;\n        padding: 0;\n    }\n\n    body {\n        background-color: black;\n    }\n\n    ul {\n        list-style: none;\n        width: 100px;\n        height: 100px;\n        position: relative;\n        cursor: pointer;\n        margin: 150px auto;\n\n        transition: 1s;    /* 设置过渡时间 */\n        transform-style: preserve-3d;   /* 设置所有的子元素实现3D动画 */\n    }\n\n    /* 设置鼠标悬停的动画 */\n    ul:hover {\n        transform: rotateX(120deg) rotateY(120deg);\n    }\n\n    ul li {\n        width: 100%;\n        height: 100%;\n        text-align: center;\n        line-height: 100px;\n        font-size: 40px;\n        font-weight: 700;\n        position: absolute;\n        top: 0px;\n    }\n    /* 前 */\n    ul li:nth-child(1) {\n        background-color: rgba(225, 0, 0, .4);\n        transform: rotateX(0deg) translateZ(50px);\n    }\n    /* 下 */\n    ul li:nth-child(2) {\n        background-color: rgba(0, 255, 0, .4);\n        transform: rotateX(-90deg) translateZ(50px);\n    }\n    /* 后 */\n    ul li:nth-child(3) {\n        background-color: rgba(0, 0, 255, .4);\n        transform: rotateX(-180deg) translateZ(50px);\n    }\n    /* 上 */\n    ul li:nth-child(4) {\n        background-color: rgba(125, 125, 0, .4);\n        transform: rotateX(90deg) translateZ(50px);\n    }\n    /* 左 */\n    ul li:nth-child(5) {\n        background-color: rgba(0, 125, 125, .4);\n        transform: rotateY(-90deg) translateZ(50px);\n    }\n    /* 右 */\n    ul li:nth-child(6) {\n        background-color: rgba(10, 45, 36, .4);\n        transform: rotateY(90deg) translateZ(50px);\n    }\n</style>\n````","tags":["frontEnd","css"]},{"title":"DOM事件","url":"/2019/02/16/DOM事件/","content":"## 事件\n事件就是用户或者浏览器进行的特定行为，比如：鼠标点击事件。\n\n## 事件名称\n\n比如：click就是一个事件名。\n\n## 事件流的执行过程\n\n事件流：指的是DOM事件流（多个事件按照一定顺序执行），DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。\n事件流的执行过程：从window开始，最后回到window。\n事件流被分为三个阶段：事件捕获（1-5），事件触发（5-6），事件冒泡（6-10）。\n\n来自网上的图片：\n\n![事件流.png](http://upload-images.jianshu.io/upload_images/659084-eb2b449c3348c5d6?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### [](#事件冒泡 \"事件冒泡\")事件冒泡\n\n来自百度的解释：\n\n> 当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。\n\n就比如：我们用button产生一个click事件，但是由于button按钮本身可能不能处理这个事件，就要开始传播出去这个事件。\n实现事件冒泡的条件是：元素之间有嵌套，每个元素都有相同的事件，这样当最里层的事件触发时，这个事件就会一级一级向上传播，也就是”冒泡“。\n\n举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。这样，当里层点击事件触发时，外层的点击事件也会被触发。\n\n````\n<div id=\"outer\">\n <div id=\"inner\">\n </div>\n</div>\n\n<script>\n window.onload = function () {\n   let inner = document.getElementById('inner')\n   let outer = document.getElementById('outer')\n   inner.addEventListener('click', function (e) {\n     console.log('inner');\n   })\n   outer.addEventListener('click', function () { \n     console.log('outer');\n   })\n }\n</script>\n````\n\n结果为：\n![事件冒泡.gif](http://upload-images.jianshu.io/upload_images/659084-be2355e585a26bc5?imageMogr2/auto-orient/strip)\n\n##### 阻止事件冒泡\n\n*   一般浏览器：event.stopPropagation()\n*   IE浏览器：event.cancelBubble = true\n\n##### 阻止默认事件\n\n*   一般浏览器：event.preventDefault()\n*   IE浏览器：event.returnValue = false\n\n## addEventListener的第三个参数\n\naddEventListener方法用于将事件和函数进行绑定，函数为：addEventListener(event, fn, useCapture)，这些参数分别是：事件名，事件处理函数，第三个参数 **useCapture** 是一个布尔值，用来设置该事件的执行是在哪个阶段发生的（默认是在冒泡阶段）。\n\n*   true：表示该事件是在“事件捕获阶段”触发的。（由外向内）\n*   false：表示该事件是在“事件冒泡阶段”触发的。（由内向外）\n\n举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。\n\n将第三个参数设置为true，事件在 **捕获阶段** 执行：\n\n````\n<div id=\"outer\">\n <div id=\"inner\">\n </div>\n</div>\n\n<script>\n window.onload = function () {\n let inner = document.getElementById('inner')\n let outer = document.getElementById('outer')\n inner.addEventListener('click', function (e) {\n console.log('inner');\n }, true)\n outer.addEventListener('click', function () { \n console.log('outer');\n }, true)\n }\n</script>\n````\n\n由于是 **捕获阶段** 执行，即：由外向内执行，所以结果为： outer inner。\n\n结果为：\n![image.png](http://upload-images.jianshu.io/upload_images/659084-82bb228984257ae1?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n将第三个参数设置为false，事件在 **冒泡阶段** 执行，输出结果为： inner outer。\n![image.png](http://upload-images.jianshu.io/upload_images/659084-1d1d0c25024cc18d?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 事件处理函数/事件监听函数\n\n事件触发后的处理函数。如：btn.onclick = fn，fn就是事件处理函数/事件监听函数。\n\n#### HTML事件处理程序\n\n例如：\n\n````\n<button onclick = \"fn()\">click</button>\n````\n\n这种方式的缺点是：结构和行为耦合在一起。\n\n#### DOM0级事件处理程序\n\n形式为：ele.on + ‘事件名称’ = 事件处理函数\n例如： ele.onclick = function() {…}，this指向当前元素。\n\n#### DOM2级事件处理程序\n\n这种方式主要是通过这两个方法：addEventListener()，removeEventListener()\n这种方式的优点就是：可以同一个事件处理程序绑定多个事件处理函数。\n\n## 事件委托\n\n事件委托要处理的问题是：解决事件处理程序过多的问题。简单来说，就是将很多个事件处理程序委托给一个事件处理程序，通过这个事件处理程序来管理这么多个事件处理程序。\n好处：减少对DOM的访问，提高性能；可以对后来添加进来的元素也能绑定委托事件。\n\n例如：在一个 ul 标签中有很多个 li 标签，我们的需求而是点击每一个 li 标签显示每一个 li 标签的内容。\n如果没有使用事件委托，我们需要给每一个 li 标签都添加事件监听函数，很明显，这样的效率并不高，而且对整个网页的性能也会影响；如果我们使用事件委托，将这些 li 的事件委托给 ul 标签，这样就可以只用一个事件监听函数实现。\n\n代码如下：\n\n````\n<ul id=\"list\"> \n <li>111111</li>\n <li>222222</li>\n <li>333333</li>\n <li>444444</li>\n</ul>\n\n<script>\n window.onload = function () { \n // 传统的方法\n // let lis = document.getElementsByTagName('li')\n // console.log(lis);\n // for(let i = 0; i < lis.length; i++){\n //     lis[i].addEventListener('click', function () { \n //         console.log(this.innerHTML);\n //     })\n // }\n // 使用事件委托\n let list = document.getElementById('list')\n list.addEventListener('click', function (e) { \n   let target = e.target\n   console.log(target.innerHTML);\n }, false)\n }\n</script>\n````\n\n事件委托一般使用的是 **事件冒泡阶段** 进行（虽然事件捕获阶段也可以），因为事件冒泡的事件流模型被所有的主流浏览器兼容，事件冒泡的兼容性更好。","tags":["frontEnd","js"]},{"title":"px/em/rem总结","url":"/2019/02/16/px-em-rem总结/","content":"## px\n\n对于**px**，大家都不陌生。它是一个相对于屏幕的相对长度单位。\n\n## em\n\n**em**也是一个相对长度单位，但它相对的是父级元素的字体大小。\n对于em有一个推算过程：\n如果没有定义自己的font-size，则：浏览器默认：*1em = 16px*\n所以：\n*12px = 0.75em*\n*10px = 0.625em*\n但是如果每次都这样进行计算很麻烦，而且开发效率也很低，因此为了简化计算，我们将浏览器的font-size设置为**62.5%**，这样：\n**1em = （16px * 62.5%） = 10px； 1.2em = 12px**\n依次类推，要使用em这个相对长度单位，只要我们在body标签里面设置了font-size为62.5%，这样只要就可以得到计算公式：**(n)px = (n \\ 10)em**\n\n但是，em单位是相对的，不是固定的，是逐级继承的（一层一层向上计算），举个例子：\n比如，一个div里面嵌套了一个div，这两个div都设置了font-size为1.2em，浏览器的font-size设置为62.5%，此时，最里层的div的font-size大小是：**（1.2 * 1.2） = 1.44em**。\n\n## rem\n\n**rem**也是相对长度单位，从它的单位也可以看出，它跟**em**比较，多了个 **r** 字母，它的意思就是**root（根）**的意思。简单来说，就是它是相对于根节点（html标签）的font-size而言的。这样子，就消除了**em**单位逐级继承的缺点。\n举个例子：\n先将**html**标签设置为62.5%，这样，html里面的任何子标签都是继承于这个标签，也就是说相对于这个标签。所以，不论标签中有多少级的嵌套，最里层标签的font-size的计算公式永远是：**(n)px = (n \\ 10)rem**\n","tags":["frontEnd","css"]},{"title":"js的原型和继承","url":"/2019/02/16/js的原型和继承/","content":"## 原型模式\n\n原型模式在《JavaScript高级程序设计》中的定义：\n\n> 我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用这个对象的好处就是可以让所有对象实例共享它包含的属性和方法。\n\n这里还有一个\\_\\_proto\\_\\_属性，每一个对象都拥有这个属性，这个属性指向对应的构造函数的prototype属性。\n\n通过原型对象，我们就不用将信息添加到构造函数中了。\n\n#### 实例对象共享原型对象的属性\n\n````\nfunction Person(){}\nPerson.prototype.name = 'A'\nPerson.prototype.age = 1\n// 实例对象共享原型对象的属性\nlet p1 = new Person()\nconsole.log(p1.name, p1.age);   // A 1\nlet p2 = new Person()\nconsole.log(p2.name, p2.age);   // A 1\n````\n\n#### constructor（构造函数）属性\n\n每个原型对象在默认情况下都会自动获取一个constructor（构造函数）属性，这个属性包含一个指针，指向这个原型所在的函数。在上面的例子中，创建Person函数后，它的prototype指向它的原型对象，这个原型对象就会获取获取constructor属性，指向Person函数。\n\n#### 判断实例对象与原型对象之间的关系\n\n*   Obj.prototype.isPrototypeOf(obj)\n\n````\nconsole.log(Person.prototype.isPrototypeOf(p1)) // true\n ````\n\n*   Object.getPrototypeOf(obj)：返回对象实例的原型[es5]\n\n````\nconsole.log(Object.getPrototypeOf(p1) == Person.prototype);   // true\nconsole.log(Object.getPrototypeOf(p1).name);    // A\n````\n\n*   obj.hasOwnPrototype(attr)：检测一个属性是否存在于实例中。只有当实例对象重写原型对象的属性后（非原型属性）才会返回true。\n\n````\nconsole.log(p1.hasOwnProperty('name')); // false\np1.name = 'Ertsul'\nconsole.log(p1.hasOwnProperty('name')); //true\n````\n\n*   in操作符：通过in操作符和hasOwnProperty()可以判断某属性存在于实例还是原型对象中【in判断是否存在属性，hasOwnProperty()判断存在于哪里。】可以单独使用和for-in循环使用：无论属性属于实例还是原型中，都会返回true。(‘name’ in person1)\n\n*   获取所有实例的属性名字，无论是否可以枚举。\n\n````\nconsole.log(Object.getOwnPropertyNames(p1)); // [\"name\"]\n````\n\n*   instanceof\n\n````\nconsole.log(p1 instanceof Person);    // true\n````\n\n#### 更简单的语法\n\n````\nfunction Person() {  }\nPerson.prototype = {\n name: '001'\n}\nlet p1 = new Person()\nconsole.log(p1.name);\n````\n\n这里的例外是：constructor属性不再指向Person；本质上相当于完全重写了Person对象了。注：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。[详见《JavaScript高级程序设计》P156-P157，原型的动态性]\n\n####搜索机制\n\n*   解释器会现在目标对象中搜索目标属性，如果当前对象没有目标属性，解释器继续在目标对象的原型对象中搜索。\n*   通过delete只能删除对象的属性，而不能删除原型对象中的属性。\n\n#### 组合模式（默认类型）：构造函数模式 + 原型模式\n\n构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。\n\n## 继承\n\n#### 原型链\n\n````\n// 父亲\nfunction Father() { \n this.fatherProperty = true\n}\nFather.prototype.getFatherValue = function () { \n return this.fatherProperty\n}\n// 儿子\nfunction Son() { \n this.sonProperty = false\n}\n// 继承父亲：通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性\nSon.prototype = new Father()\nSon.prototype.getSonValue = function () { \n return this.sonProperty\n}\n\nlet instance = new Son()\nconsole.log(instance.fatherProperty);   // true\n````\n\n上面例子中，通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性。（重写儿子的原型）。这里，儿子原型对象的[[prototype]]（注：不是prototype，[[prototype]]存在于原型中）指向的是父亲的原型对象，而父亲的原型对象的[[prototype]]指向的是Object Prototype。（由于所有函数的默认原型都是Object的实例，所以默认原型都会包含一个内部指针，指向Object.prototype）\n\n#### 借用构造函数\n\n*   主要是为了解决因为引用类型值的原型属性会被所有实例共享的问题。\n*   **借用构造函数/伪造对象/经典继承**：在子类型构造函数的内部调用超类型构造函数。\n\n````\n// 父亲\n    function Father() { \n     this.info = ['Zero']\n    }\n    // 儿子\n    function Son() { \n     // 继承父亲：在子类型构造函数的内部调用超类型构造函数\n     // 《JavaScript高级程序设计》：函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call() 可以在新创建的对象上执行构造函数。 \n     Father.call(this)        // 借用超类的构造函数\n    }\n\n    let f = new Father()\n    f.info.push('100')\n    console.log(f.info);    // [\"Zero\", \"100\"]\n\n    let s = new Son()\n    console.log(s.info);    // [\"Zero\"]\n````\n\n如果在继承的时候要传递参数，则在后面添加参数即可。如：Father.call(this， param1, param2)\n\n#### \\_\\_proto\\_\\_\n\n通过**\\_\\_proto\\_\\_**也可以实现子类型对超类型的继承。\n\n````\nconst obj = {\n num : 123 \n}\nconst obj1 = {\n __proto__ : obj\n}\nconsole.log(obj1.num);  // 123\n````\n\n#### Object.create(source)\n\n````\nconst obj = {\n num : 123 \n}\nconst obj2 = Object.create(obj)\nconsole.log(obj2.num);  // 123\n````\n\n#### Object.assign(Object.create(obj), {…})\n\n````\nconst obj = {\n num : 123 \n}\nconst obj3 = Object.assign(\n Object.create(obj),\n {\n num2 : 234\n }\n)\nconsole.log(obj3.num, obj3.num2);   // 123 234\n````\n\n## 补充\n#### 继承机制如下图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-862bb97f2e2fe227.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 测试代码如下：\n\n````\n// 父类\nfunction SuperType(){\n}\n// 子类\nfunction SubType(){\n\n}\n// 子类继承父类\nSubType.prototype = new SuperType();\n// 实例化父类和子类\nlet superIns = new SuperType();\nlet subIns = new SubType();\n\n// 子类\nconsole.log(SubType.prototype);     // SuperType {}\nconsole.log(subIns.__proto__);      // SuperType {}\n\n// 父类\nconsole.log(SuperType.prototype);       // {constructor: ƒ} \nconsole.log(superIns.__proto__);        // {constructor: ƒ}\n\nconsole.log(SuperType.prototype.__proto__);     \n// {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …}\n// 即： Object prototype\n\nconsole.log(SuperType.prototype.__proto__.constructor);\n// ƒ Object() { [native code] } 即：Object\n````","tags":["frontEnd","js"]},{"title":"js的存储和拷贝","url":"/2019/02/16/js的存储和拷贝/","content":"\n## 数据类型\n#### 基本数据类型\n- Number\n- String\n- Boolean\n- Undefined\n- Null\n#### 引用类型\n多个基本数据类型复合形成。\n- Object\n\n## 存储方式\n#### 基本数据类型的存储方式\n- 每当定义一个基本数据类型的变量，会在 **栈区** 开辟一个内存空间，用于存放该变量。栈区的特点是：静态分配，大小固定。\n- 当一个变量通过直接复制的方式复制给另一个变量，系统会在 **栈区**  重新开辟一个内存空间；两个变量互不影响。\n\n````\nlet num1 = 10;\nlet num2 = num1;\nnum2 = 20;\nconsole.log(num1);     // 10 \n````\n\n#### 引用类型的存储方式\n- 每当定义一个引用类型，如：对象，会在 **堆区** 开辟一个内存空间；然后如果创建一个该对象的实例，会在 **栈区** 开辟一个内存存放该实例，该实例实际上是一个指向 **堆内存** 对象的指针。堆区的特点是：动态分配，大小不固定。\n- 当一个实例直接复制给另一个实例，系统会在 **栈区**  重新开辟一个内存空间，但是新实例同样也是一个指向  **堆内存** 对象的指针，所以，这样的操作，这样的修改都会对新旧实例产生影响。\n\n````\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\n\n//直接复制\nlet obj2 = obj1;\n\nobj2.name = 'Ertsul';\nobj2.num[0] = '一';\nconsole.log(obj1, obj2);\n// name:\"Ertsul\"\n// age:22\n// num:[\"一\", \"2\", \"3\"]\n````\n\n## 浅拷贝和深拷贝\n#### 区别\n两者的区别主要在于 **复制层次** 的不同：\n- 浅拷贝主要复制到对象属性这一层次，如果对象里面有子对象，则无法对子对象完成复制；之后对于子对象的修改 **会** 影响到原复制对象。\n- 深拷贝则是浅拷贝的 **加强版** ，可以实现对于子对象的拷贝；之后对于子对象的修改 **不会** 影响到原复制对象。主要实现方法有：\n  - 递归\n  - JSON解析\n#### 浅拷贝\n\n````\n// 浅拷贝\nfunction shallowCopy(source) {\n    let result = {};\n    for(let key in source){\n        result[key] = source[key]\n    }\n    return result;\n}\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\n\nlet obj2 = {};\nobj2 = shallowCopy(obj1);\n\nobj2.name = 'Ertsul';    // 不会产生影响\nobj2.num[0] = '一';      // 产生影响\nconsole.log(\"obj1\", obj1);\nconsole.log(\"obj2\", obj2);\n````\n\n结果如图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-2238425cd781911c.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### 深拷贝\n\n##### 递归\n\n````\n// 递归实现深拷贝\nfunction deepCopy(source, res){\n    var res = res || {};\n    for(let i in source){\n        if(typeof source[i] === 'object'){\n            if(source[i].constructor === Array){\n                res[i] = []\n            }else {\n                res[i] = {}\n            }\n            deepCopy(source[i], res[i]);   // 递归子对象属性\n        }else{\n            res[i] = source[i]\n        }\n    }\n    return res;\n}\n\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\n\nlet result = {}\nresult = deepCopy(obj1, result);\nresult.name = 'Ertsul';\nresult.num[1] = '二';\nconsole.log(\"result\", result);\nconsole.log(\"obj1\", obj1);\n````\n\n结果如图：\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-522f00e896a05506.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n##### JSON解析\n\n````\n// JSON实现深拷贝\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    num: ['1', '2', '3']\n}\nlet result1 = JSON.parse(JSON.stringify(obj1));\nresult1.num[2] = '三';\nconsole.log('result1', result1);\nconsole.log('obj1', obj1);\n````\n\n结果如图：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-b747df9bb831bf93.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n","tags":["frontEnd","js"]},{"title":"js/es6小知识大杂烩","url":"/2019/02/16/js-es6小知识大杂烩/","content":"\n#### 合并两个数组\n- 数组的解构 **[...arr1, ...arr2]**\n- Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。\n- arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。\n\n```\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\nlet arr3 = [...arr1,  ...arr2];\nconsole.log(arr3);\nArray.prototype.push.apply(arr1,  arr2);\nconsole.log(arr1);\n```\n\n#### arguments/伪数组 转化为数组\n- [...arguments]\n- Array.prototype.slice.call(arguments)\n\n```\n(function Fn() {\n    let arr = [...arguments, 'Ertsul'];\n    console.log(arr);\n})('zero');\n(function Fn1() {\n    let arr = Array.prototype.slice.call(arguments);\n    console.log(arr);\n})('zero');\n```\n\n#### 判断字符类型\n- Object.prototype.toString.call()\n- typeof\n- instanceof\n\n#### 创建实例的方法\n- 字面量 let obj = {...}\n- new Object()构造函数\n- 构造函数\n- Object.create()\n- 工厂模式\n\n```\n// 字面量\nlet obj1 = {\n    name: 'zero',\n    age: 22\n};\n// Object 构造函数\nlet obj2 = new Object();\nobj2.name = 'zero';\nconsole.log(obj2.name);\n// 工厂模式\nfunction Person(name) {\n    let obj = new Object();\n    obj.name = name;\n    return obj;\n}\nlet p1 = Person('zero');\nconsole.log(p1.name);\n// 构造函数\nfunction Animal(name) {\n    this.name = name;\n}\nlet a2 = new Animal('dog');\nconsole.log(a2.name);\n```\n\n#### 继承的方法 -- 8种\n- 通过原型继承\n  - 缺点：引用类型存在共享问题。\n\n````\nfunction Fn1() { ... }\nfunction Fn2() { ... }\nFn2.prototype = new Fn1();\n````\n\n- 构造函数：通过 **call** 更改 **this** 指向；实际上是调用了父类的构造函数。\n  - 缺点：父类中的方法（构造函数中）子类不可见。\n\n````\nfunction Fn1() { ... }\nfunction Fn2() { \n  Fn1.call(this);   // 将 this 绑定到 Fn1\n}\n````\n\n````\nfunction SuperType(){\n    \n}\nSuperType.prototype.sayHi = function(){\n    console.log('Hi');\n}\n\nfunction subType(){\n    SuperType.call(this);\n}\n\nlet superIns = new SuperType();\nsuperIns.sayHi();   // Hi\n\nlet subIns = new subType();\nsubIns.sayHi();     // Uncaught TypeError\n````\n\n- 组合继承（原型 + 构造）\n属性通过构造函数继承；方法通过原型继承。记得要更改 **Fn2.prototype.constructor** 的指向，指向子类。\n\n````\n// 组合继承\nfunction Fn1() {\n    this.name = 'zero'\n}\n\nFn1.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction Fn2() {\n    // 继承属性\n    Fn1.call(this);\n    this.age = 22;\n}\n// 继承方法\nFn2.prototype = new Fn1();\nFn2.prototype.constructor = Fn2;   // 需要修复构造函数指向\n\nFn2.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nlet f = new Fn2();\nf.sayName();\nf.sayAge();\n````\n\n- 实例继承\n在一个函数内实例化，然后添加新属性，并返回该对象。\n\n````\nfunction Fn() { ... }\nfunction Fn2(name) {\n let obj = new Fn();\n obj.name = name;\n return obj;\n}\n````\n\n- 原型式继承\n将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。\n\n````\nfunction SuperType(name) {\n    this.name = name\n}\n\nfunction Object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n\nlet subType = Object(new SuperType('zero'));\nconsole.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__\n````\n\n- 拷贝继承\n将原型/父类上的属性全部拷贝到子类上。\n\n````\n// 拷贝继承\nfunction Fn1() {\n    this.name = 'zero';\n    this.age = 22\n}\nfunction Fn2() {\n    let f1 = new Fn1();\n    // 注意这里要用 in 操作符\n    for (let item in f1) {\n        Fn2.prototype[item] = f1[item];\n    }\n    Fn2.prototype.ownFun = function () {\n        console.log('my own function.');\n    }\n}\n\nlet f = new Fn2();\nconsole.log(f.name + \", \" + f.age);\nf.ownFun();\n````\n\n- 寄生组合式模型\n  - 通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。\n  - 通过构造函数实现属性的继承。\n\n````\n// 寄生组合式继承\nfunction inheritPrototype(subType, superType) {\n    // 创建对象：新建的对象指向父类的原型\n    let prototype = Object(superType.prototype);\n    // 增强对象：新建对象的 constructor 指向子类\n    prototype.constructor = subType;\n    // 指定对象：子类的原型指向新建对象\n    subType.prototype = prototype;\n}\n\nfunction Fn1() {\n    this.name = 'Ertsul';\n}\n\nFn1.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction Fn2() {\n    Fn1.call(this);\n    this.age = 22;\n}\n\ninheritPrototype(Fn2, Fn1);\n\nFn2.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nlet f = new Fn2();\nf.sayName();f.sayAge();\n````\n\n- es6 的 extends \n\n````\n// class\nclass F1 {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nclass F2 extends F1 {\n    constructor(name, age){\n        super(name);    // 调用父类的构造函数\n        this.age = age;\n    }\n    showMsg(){\n        console.log(this.name + ', ' + this.age);\n    }\n}\n\nlet p = new F2('zero', 22);\np.showMsg();  // zero, 22\n````\n\n#### 比较两个对象是否相等\n- 遍历对象对象进行判断。\n- 将对象转化为字符串进行判断。\n\n````\nlet obj1 = {\n    name: 'a',\n    age: 1\n}\nlet obj2 = obj1;\nlet obj3 = {\n    name: 'a',\n    age: 2\n}\nconsole.log(JSON.stringify(obj1));\nconsole.log(JSON.parse(JSON.stringify(obj1)));\nconsole.log(JSON.stringify(obj1) == JSON.stringify(obj2));  // true\nconsole.log(JSON.stringify(obj1) == JSON.stringify(obj3));  // false    \n````\n\n#### 封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行\n\n````\nfunction time(time){\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time);\n    })\n}\n\nlet t = new time(5000);\nt.then((a, b) => {\n    console.log('time');\n})\n````\n\n#### 原型相关的API\n- Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例\n- Object.getPrototypeOf(p1)：获取原型\n- p1.hasOwnProperty('name')：判断某个属性是否属于某个实例（只能获取属性实例）\n- in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中）\n\n````\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nlet p1 = new Person('Ertsul', 22);\nconsole.log(Person.prototype);      // constructor f\nconsole.log(Person.prototype.constructor);  // Person\nconsole.log(Person.prototype.__proto__);    // constructor 的原型\nconsole.log(p1.__proto__);      // // constructor f\n\nconsole.log(Person.prototype.isPrototypeOf(p1));    // true\nconsole.log(Person.isPrototypeOf(p1));      // false\nconsole.log(Object.getPrototypeOf(p1));     // constructor f\n\nconsole.log(p1.hasOwnProperty('name'));     // true 存在实例中\n\nPerson.prototype.num = 100\n\nconsole.log(p1.hasOwnProperty('num'));      // fasle    存在原型中\n\nconsole.log('num' in p1);   // true 不管是实例还是原型中\n````\n\n#### js 判断数组类型\n- arr instanceof Array\n- arr.constructor === Array\n\n````\nlet arr = [1, 2, 3];\nlet obj = {}\nfunction judgeFn(arr){\n    // return arr.constructor === Array ? true : false\n    return arr instanceof Array ? true : false\n}\nconsole.log(judgeFn(arr));  // true\nconsole.log(judgeFn(obj )); // false\n````\n\n#### 日期格式化\n````\n/* 日期格式化 */\nfunction formatNumber(num) {\n\tconst n = `${num}`;\t\t// 转化为字符串\n\treturn n[1] ? n : `0${n}`;\n}\nfunction formatTime(date){\n\t// 年 月 日\n\tconst year = date.getFullYear();\n\tconst month = date.getMonth() + 1;\n\tconst day = date.getDate();\n\t// 时 分 秒\n\tconst hour = date.getHours();\n\tconst minute = date.getMinutes();\n\tconst second = date.getSeconds();\n\n\treturn `${[year, month, day].map(formatNumber).join('-')} ${[hour, minute, second].map(formatNumber).join(':')}`\n}\nlet time = new Date();\nconsole.log(time);\t\t// Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间)\nlet t1 = formatTime(time);\nconsole.log(t1);\t\t// 2018-08-14 16:52:06\n````\n\n#### 字符串转化为标准日期格式\n````\n/* 字符串转化为标准日期格式 */\nfunction time2string(str) {\n\tconst chunks = str.split(' ');\n\tconst date = chunks[0].split('-');\n\tconst time = chunks[1].split(':');\n\n\treturn new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]);\n}\nlet str = \"2018-08-14 23:59:59\";\nlet t2 = time2string(str);\nconsole.log(t2);\t// Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间)\n````\n#### 防抖节流\n````\n/* 防抖节流 debounce throttle */\n// 防抖 - 连续快速触发的解决方案\nfunction debounce(fn, wait) {\n\tlet timeout = null;\t// 初始化 timer 定时器\n\treturn function (){\n\t\ttimeout && clearTimeout(timeout);\t// 清空定时器\n\t\ttimeout = setTimeout(fn, wait);\t\t// 设置定时器\n\t}\n}\n// 节流 - 一定时间内请求一次 -- 定时器法\nfunction throttle1(fn, wait) {\n\tlet timer = null;\t// 初始化 timer 定时器\n\treturn function () {\n\t\tlet context = this;\t\t// 保存上下文 this\n\t\tlet args = arguments;\t// 记录参数\n\t\tif(!timer) {\t// 定时器为空\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tfn.apply(context, args);\n\t\t\t\ttimer = null;\t// 清空定时器\n\t\t\t}, wait);\n\t\t}\n\t}\n}\n// 节流 - 一定时间内请求一次 -- 时间戳法\nfunction throttle2(fn, wait) {\n\tlet prev = Date.now();\t// 记录前一个时间\n\treturn function () {\n\t\tlet context = this;\t\t// 保存上下文 this\n\t\tlet args = arguments;\t// 记录参数\n\t\tlet now = Date.now(); \t// 记录当前时间\n\t\tif(now - prev >= wait){\t\t// 时间戳大于设置的时间\n\t\t\tfn.apply(context, args);\n\t\t\tprev = Date.now();\t// 记录前一个时间\n\t\t}\n\t}\n}\n\n// window.addEventListener('scroll', debounce(() => {\n //    console.log(Math.random());\n// }, 500));\n// window.addEventListener('scroll', throttle1(() => {\n// \tconsole.log(Math.random());\n// }, 1000));\nwindow.addEventListener('scroll', throttle2(() => {\n\tconsole.log(Math.random());\n}, 1000))\n````\n- JSON.stringfy(obj, [replace, space])\n  - 巧用第二个参数，可以实现json对象的过滤替换。\n  - 第三个参数，是缩进的空格数。    \n  - 如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。\n```\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    hobby: 'ball'\n};\n\nlet str1 = JSON.stringify(obj1);\nconsole.log(str1, typeof str1, str1.constructor === String);    // {\"name\":\"zero\",\"age\":22,\"hobby\":\"ball\"} string true\nlet str2 = JSON.stringify(obj1, (key, value) => {\n    if(value === 'zero') {\n        return 'Ertsul.'\n    }else {\n        return value;\n    }\n});\nconsole.log(str2);  // {\"name\":\"Ertsul.\",\"age\":22,\"hobby\":\"ball\"}\n\nlet obj2 = {\n    num: 100,\n    toJSON(){\n        return 'apple'\n    }\n};\n\nlet str3 = JSON.stringify(obj2);\nconsole.log(str3);  // apple\n```\n\n- 数组的 sort()\nsort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。\n如果要对数组的数字进行排序，则需要：\n>array.sort((val1, val2) => {return val - val2});\n\n通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。\n\n```\nlet arr10 = [1, 2, 19, 12, 22];\nconsole.log(arr10.sort()); // [1, 12, 19, 2, 22]\nconsole.log(arr10.sort((val1, val2) => {  // [1, 2, 12, 19, 22]\n  return val1 - val2;\n}));  \n```\n\n- reduce函数\n> reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。\n\n其完整的函数为： \n\n```\narr.reduce((prev, next, cur, srcArr) => {\n  ......\n}, initVal)\n```\n\n- prev: 上次返回的值\n- next: 下一个数组元素的值\n- cur: 当前数组元素的索引值\n- scrArr: 源数组\n- initVal: 设置第一次的 **prev**\n\n例子 1：\n```\nlet arr = ['apple', 'pear', 'bananas'];\narr.reduce((prev, next, cur, arr) => {\n  console.warn(prev, next, cur, arr);\n  return next;\n}, 'fruit')\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-65c2bd1bf155dfaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n例子 2：统计一个数组中单词出现的次数\n```\n// 统计数组中单词出现的次数\nlet arr = [\"apple\", \"orange\", \"apple\", \"orange\", \"pear\", \"orange\", \"bananas\", \"bananas\"];\nfunction getCount(arr) {\n  return arr.reduce((prev, next, cur) => {\n    prev[next] = (prev[next] + 1) || 1\n    return prev;\n  }, {})\n}\nconsole.warn(getCount(arr));  // {apple: 2, orange: 3, pear: 1, bananas: 2}\n```\n\n- Object.seal()\n防止对象纂改：不能添加也不能删除属性\n\n```\nlet obj = {\n  name: 'Ersul'\n}\nObject.seal(obj); // 防止对象纂改：不能删除也不能添加属性\ndelete obj.name;\nconsole.warn(obj.name); // Ertsul\nobj.age = 22;\nconsole.warn(obj.age); // undefined\n```\n\n- Object.freeze()\n冻结对象，不能修改对象任何属性的值。如若\n\n```\nlet obj = {\n  name: 'Ersul'\n}\n\nObject.freeze(obj); // 冻结对象，不能修改属性的值\nobj.name = 'Zero';\nconsole.warn(obj.name); // Ertsul\n```\n\n- 数组字符串的相互转化\n```\n// 数组 --> 字符串 : join()\nlet arr3 = [1, 2, 3, 4, 5];\nconsole.log(arr3.join('-'));\n// 字符串 --> 数组 : split()\nlet str = 'apple,pear,bananas';\nconsole.log(str.split(','));\n```","tags":["frontEnd","js","es6"]},{"title":"webpack学习笔记","url":"/2019/02/16/webpack学习笔记/","content":"\n## 项目构建\n- 新建项目文件夹\n- npm init\n- 设置项目目录结构，结构如下：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-bd9163add73e9ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- **build** 目录是 webpack 打包后的生成目录，**index.html** 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。\n- **src** 目录是项目源文件，**template.html** 是 html 文件模板。\n- **webpack.config.js** 是配置 **webpack** 的总文件。\n\n```\nmodule.exports = { ... }\n```\n\n## 模式 mode\n\n```\nmode: \"development\", // development or production\n```\n\n## 入口 entry\n设置打包的入口文件, entry: filepath\n\n```\nentry: \"./src/index.js\", // 入口\n```\n\n## 输出 output\n设置打包后的输出文件，output: { ... }\n\n```\noutput: { // 输出\n  filename: \"bundle.[hash:8].js\",\n  path: path.resolve(__dirname + '/build'),\n  // publicPath: \"http://\", // 公共路径前缀\n},\n```\n注：\n- **path** 后面应是绝对路径。\n- **bundle.[hash:8].js** 中的 **[hash:8]** 可以在每次打包后都在文件后面追加 hash 值。\n\n通过上面三项，可以实现一个简单的 **webpack** 打包配置。在 **package.json** 添加脚本或直接执行 **./node_modules/.bin/webpack** 即可实现打包：\n\n```\n\"build\": \"./node_modules/.bin/webpack\",\n```\n\n## webpack-dev-server\nwebpack 开发服务器，用于开发时候的配置：\n- yarn add taco --dev webpack-dev-server / npm install --save-dev webpack-dev-server\n- 基本配置如下：\n\n```\ndevServer: { // 开发服务器\n  port: 3001,\n  contentBase: path.resolve(__dirname + '/build'), // 本地服务器目录\n  progress: true, // 进度条\n  open: true, // 自动打开浏览器\n  compress: true, // 压缩\n  // 1. 代理\n  proxy: {\n    \"/api\": {\n      target: \"\",\n      pathRewrite: {\n        \"/api\": \"\"\n      }\n    }\n  },\n  // 2. 用 express 内置钩子模拟数据\n  before(app) {\n    app.get(\"/api\", (req, res) => { ... })\n  },\n  // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件\n},\n},\n```\n\n- 在 **package.json** 添加脚本即可：\n\n```\n\"dev\": \"webpack-dev-server\"\n```\n\n## source-map && eval-source-map && cheap-module-source-map && cheap-module-eval-source-map\n\n作用：源码映射，报错时显示出错的位置。\n\n- source-map：会单独生成一个 **sourcemap** 文件；会显示行列。\n- eval-source-map：不会单独生成一个 **sourcemap** 文件，会将生成的 **sourcemap** 放到打包后的 **html** 文件；会显示行和列。\n- cheap-module-source-map：会生成 **sourcemap** 文件，不会显示列。\n- cheap-module-eval-source-map：不会生成 **sourcemap** 文件，集成在 **html** 文件中，不会显示列。\n\n```\ndevtool: \"source-map\", // 源码映射\n```\n\n## watch\n作用：监控代码实时变化，进行编译打包。\n\n```\nwatch: true, // 监控代码实时变化，进行编译打包\nwatchOptions: {\n  poll: 1000, // 多毫秒监控一次\n  aggreatement: 500, // 防抖\n  ignored: \"node_modules\" // 忽略文件夹\n},\n```\n\n## resolve\n作用：解析第三方包\n\n```\nresolve: { // 解析 第三方包\n  modules: [\n    path.resolve(\"node_modules\"), // 在当前目录下查找模块 \n    path.resolve(\"other_modules\"), // 在其他目录下查找模块 \n  ],\n  // 自动添加扩展名，主要是 import 时候使用, 依次解析\n  extensions: [\".js\", \".css\", \".json\", \".vue\"],\n  // 比如引用 bootstrap 的 css 样式\n  // 方式一： bootstrap 的主入口\n  mainFields: [\"style\", \"main\"],\n  // 方式二：别名  \n  // alias: {\n  //   bootstrap: \"bootstrap/dist/css/bootstrap.css\"\n  // }\n},\n```\n\n## 插件\nwebpack 的插件配置是一个数组，里面存放着各种各样的插件。\n\n```\nplugins: [\n new pluginName(...)\n]\n```\n\n#### html-webpack-plugin\n插件作用：打包时候自动根据 **html** 模板生成目标 **html** 文件，自动生成目标打包目录；另外，可配置 **html** 的相关打包配置，如：压缩，去双引号等。\n\n```\nnew HtmlWebpackPlugin({\n  filename: \"index.html\", // 目标文件名称\n  template: path.resolve(__dirname + '/src/template.html'), // 模板文件\n  minify: { // 压缩配置\n    removeAttributeQuotes: true, // 去双引号\n    collapseWhitespace: true, // 不换行\n  },\n  hash: true // 生成 hash 戳\n})\n```\n\n#### mini-css-extract-plugin\n作用：将生成的 **css样式** 抽离成一个 **css文件**，并将该样式文件引进目标 **html** 文件中。\n\n```\nplugins: [ // 插件\n  new MiniCssExtractPlugin({\n    filename: \"main.css\",\n  })\n],\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序\n      \"css-loader\"\n    ]\n  }]\n}\n```\n\n注：这里抽离出来的 **main.css** 文件并没有压缩，要通过手动添加以下两个插件到优化项：\n- optimize-css-assets-webpack-plugin\n- uglifyjs-webpack-plugin\n\n```\noptimization: { // 优化项\n  minimizer: [\n    new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件\n    new UglifyjsWebpackPlugin({\n      cache: true,\n      parallel: true,\n    }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置\n  ]\n},\n```\n\n#### optimize-css-assets-webpack-plugin\n插件作用：压缩抽离出来的 **main.css** 文件。但是，使用了 **optimize-css-assets-webpack-plugin** 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 **uglifyjs-webpack-plugin** 。\n\n#### uglifyjs-webpack-plugin\n插件作用：压缩打包后的 **js** 文件。\n\n#### clean-webpack-plugin\n作用：清理文件\n\n```\nplugins: [\n new CleanWebpackPlugin(\"./build\")\n]\n```\n\n#### copy-webpack-plugin\n作用：将某些文件拷贝到打包后的文件夹。\n\n```\nnew CopyWebpackPlugin([\n  {from: \"./copy\", to: \"./\"}\n])\n```\n\n#### banner-plugin\n作用：版权声明，是 **webpack** 的内置模块。\n\n```\nnew webpack.BannerPlugin(\"@copyright by Ertsul\")\n```\n\n#### webpack.DefinePlugin({ ... })\n作用：定义环境变量。\n\n```\nplugins: [\n  new webpack.DefinePlugin({\n    DEV: JSON.stringify(\"development\"),\n    PRO: JSON.stringify(\"production\")\n  })\n]\n```\n\n#### webpacfk.IgnorePlugin()\n作用：忽略模块的引进\n\n```\nplugins: [\n  new webpack.IgnorePlugin(/\\./locale/, /moment/)\n]\n```\n\n注：如果直接使用 **DEV: 'development'** 的话，会把 **DEV** 直接替换为 **引号内部的内容**。如：**console.log(DEV)**，会变成 **console.log(dev)**，最后的结果是 **undefined**。所以，需要通过 **JSON.stringfy()** 进行转化。\n\n## 模块 module\n模块主要是各种 **loader**，作用：解析各种类型的文件。\n\n```\nmodule: { \n rules: [\n   {\n     test: regx,\n     use: [loadName]\n   }\n ]\n}\n```\n\n#### css-loader / style-loader\n- css-loader：主要是用于解析在 **css** 文件中通过 **@import** 方式引进其他的 **css** 文件。\n- style-loader: 主要是用于将 **js** 文件中通过 **require** 方式引进的 **css** 文件插入到目标 **html** 文件的 **head** 中（插到最后，层级最高）。\n\n```\n// 数组方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\"style-loader\", \"css-loader\"] // loader 数组\n  }]\n}\n// 对象方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\n      {\n        loader: \"style-loader\",\n        options: {\n          insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n        }\n      }, \n      \"css-loader\"\n    ]\n  }]\n}\n```\n注：**loader** 是从右向左、从下到上的执行顺序，故：**use: [\"style-loader\", \"css-loader\"]**\n\n#### postcss-loader + autoprefixer\n这两个的配合使用可以自动添加 **css** 的浏览器前缀。\n- autoprefixer：自动添加 **css** 的浏览器前缀。\n- postcss-loader：loader 处理 autoprefixer。\n\n```\n// 使用 postcss-loader \nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader,\n      \"css-loader\",\n      \"postcss-loader\" // 注意顺序\n    ]\n  }]\n}\n```\n\n- 根目录下新建 postcss.config.js 文件\n\n```\nmodule.exports = {\n  plugins: [\n    require(\"autoprefixer\")\n  ]\n}\n```\n\n#### babel-loader + @babel/core + @babel/preset-env\n作用：转化 es6 语法\n  \n```\nmodule: { // 模块\n  rules: [{\n    test: /\\.js$/,\n    use: {\n      loader: \"babel-loader\",\n      options: { // 用 babel-loader 需要把 es6 转化为 es5\n        presets: [\n          \"@babel/preset-env\", // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块\n        ],\n        // plugins: [...] // 其他的小插件\n      }\n    }\n  }]\n}\n```\n\n#### expose-loader\n作用：暴露全局的 **loader**，暴露到 **window** 上。\n\n```\n// 一般情况\nimport $ from 'jquery';\nconsole.log(window.$); // undefined\n// 内联 loader 方式\nimport $ from 'expose-loader?$!jquery';\nconsole.log(window.$);\n// 其他方式：在每个模块中注入\nnew webpack.ProvidePlugin({\n  $: \"jquery\"\n})\nconsole.log($);\nconsole.log(window.$); // undefined\n```\n\n#### file-loader && url-loader && html-withimg-loader\n在 **webpack** 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。\n\n- file-loader：**js** 文件中通过 **import** 方式引进图片。\n- html-withimg-loader：**html** 文件中通过 **scr** 方式引进图片。\n- 在 **css** 中使用图片，**style-loader** 已经做了处理。\n- url-loader：将图片转化为 **base64**\n\n```\nmodule: {\n  rules: [\n    {\n      test: /\\.(png|jpg|gif)$/,\n      use: {\n        loader: \"url-loader\",\n        options: {\n          limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader\n          // publicPath: \"http://\", // 公共路径前缀\n        }\n      }\n    },\n    {\n      test: /\\.html$/,\n      use: [\"html-withimg-loader\"]\n    }\n  ]\n}\n```\n`\n## 模块 module -- noParse\n作用：不解析指定包的依赖关系。\n\n```\nmodule: {\n  noParse: /jquery/\n}\n```\n\n## 模块 module -- exclude\n作用：排除\n\n```\nmodule: {\n  exclude: /node_module/\n}\n```\n\n## 模块 module -- include\n作用：包含\n\n```\nmodule: {\n  include: /src/\n}\n```\n\n\n\n## 区分不同环境，实现开发和生产配置的分离\n将 **webpack** 的配置文件划分为以下文件：\n\n- webpack.base.js：基本、共有的配置。\n- webpack.dev.js：开发配置。\n- webpack.prod.js：生产配置。\n\n使用 **webpack-merger** 插件：\n- 安装 **webpack-merge** 插件；\n- 引进目标模块\n\n```\nimport { smart } from \"webpack-merge\";\n```\n\n- 使用\n\n```\nconst base = require(\"webpack.base.js);\n\nmodule.exports = smart(base, {\n  ...\n})\n```\n\n## webpack 自带优化\n- **import** 语法（生成环境），**tree-shaking** 自动删除没有用到的代码；\n- **es6** 模块会把语法放到 **default** 上；\n- 自动省略可以简化的代码；\n- **scope hosting**，作用域提升。\n\n## webpack 懒加载\n- 通过 **import** 实现（该语法内部由 **jsonp** 实现），返回的是一个 **promise**。\n- 要在 **babel-loader** 中添加 **@babel/plugin-syntax-dynamic-import** 插件。\n- **vue** 和 **react** 的l懒加载都是这样实现的。\n\n```\n/*\n* 模拟点击加载 source.js 的内容\n*/\n// 1\n{\n  loader: 'babel-loader',\n  options: {\n    presets: [\n      '@babel/preset-env'\n    ],\n    plugins: [\n      '@babel/plugin-syntax-dynamic-import'\n    ]\n  },\n}\n// 2\nlet btn = document.createElement('button');\nbtn.innerHTML = 'btn';\nbtn.addEventListener('click', function () {\n  // 内部由 jsonp 实现动态加载文件\n  import('./source.js')\n    .then(data => {\n      console.log(data);\n    })\n})\ndocument.body.appendChild(btn);\n\n```\n\n点击按钮后结果如下：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fa79ce43578285a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 热更新 / 热替换 / Hot Module Replacement / HMR\n热更新：页面只更新改动的模块。\n\n- **devServer** 开始 **hot** 热更新模块。\n- 使用 **webpack** 内置热更新插件。\n  - NamedModulesPlugin\n  - HotModuleReplacementPlugin\n\n```\n// devServer 配置\ndevServer: {\n  port: 8089,\n  contentBase: path.resolve(__dirname + '/dist/'),\n  compress: true,\n  progress: true,\n  // open: true\n  hot: true, // 开启热更新，只更新更改的模块\n},\n// 添加插件\nplugins: [\n  new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径\n  new webpack.HotModuleReplacementPlugin(), // 热更新\n]\n```\n\n- 使用热更新\n\n```\nimport source from './source.js';\n\nconsole.log(source);\n\n// 添加热更新操作，不然不会实现热更新\nif (module.hot) {\nmodule.hot.accept('./source.js', () => {\n  require('./source.js');\n})\n```\n\n## 多线程打包\n使用 **happypack** 可以实现多线程打包。\n\n- 安装并引进 **happypack**;\n- 改写 **module**;\n- **plugin** 配置。\n\n```\n// 改写 module\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      // use: {\n      //   loader: 'babel-loader',\n      //   options: {\n      //     presets: [\n      //       '@babel/preset-env'\n      //     ]\n      //   }\n      // }\n      use: {\n        loader: 'Happypack/loader?id=js',\n      }\n    },\n  ]\n}\n// plugin 配置\nplugins: [\n  new Happypack({\n    id: 'js',\n    use: [\n      {\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            '@babel/preset-env'\n          ]\n        }\n      }\n    ]\n  }),\n]\n```\n\n## 多页面打包\n\n```\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n    home: \"./src/home.js\",\n    about: \"./src/about.js\",\n    other: \"./src/other.js\"\n  },\n  output: {\n    path: path.resolve(__dirname + \"/build/\"),\n    filename: \"[name].js\",\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"home.html\",\n      chunks: [\"home\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"other.html\",\n      chunks: [\"other\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"about.html\",\n      chunks: [\"about\"]\n    }),\n  ]\n}\n```\n\n## 多页面打包抽离公共代码块\n打包 **多页面** 需要将公共的代码块抽离出来进行优化：\n\n```\noptimation: {\n  splitChunks: {  // 分割代码块\n    cacheGroups: {  // 缓存组\n      common: {  // 公共的模块\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      },\n      vender: {  // 第三方模块\n        priority: 1,  // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用\n        test: /node_modules/,  // 抽离出来\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      }\n    }\n  }\n}\n```\n\n## Tapable\n**webpack** 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 **Tapable**，通过 **Tapable** 实现各种钩子（如同步钩子异步钩子）。而 **Tapable** 核心是依赖于 **发布订阅者模式**。\n\n- 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tap** 注册。\n\n使用：\n```\nconst { SyncHook } = require('tapable');\n\nclass Hook {\n  constructor() {\n    this.hooks = {\n      arch: new SyncHook(['name'])\n    }\n  }\n  tap() { // 注册监听事件\n    this.hooks.arch.tap('vue', (name) => {\n      console.log('vue', name);\n    })\n    this.hooks.arch.tap('react', (name) => {\n      console.log('react', name);\n    })\n  }\n  start() { // 开始\n    this.hooks.arch.call('Ertsul')\n  }\n}\nlet h = new Hook();\nh.tap();\nh.start();\n```\n\n- 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tapAsync** 注册。\n\nsetTimeout()方式使用：\n\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapAsync('vue', (name, cb) => {\n      setTimeout(() => {\n        console.log('vue', name);\n        cb && cb();\n      }, 1000)\n    })\n    this.hooks.arch.tapAsync('react', (name, cb) => {\n      setTimeout(() => {\n        console.log('react', name);\n        cb && cb();\n      }, 1000)\n    })\n  }\n  start() {\n    this.hooks.arch.callAsync('Ertsul', () => {\n      console.log('All finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\nPromise()方式使用：\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapPromise('vue', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('vue', name);\n          resolve();\n        }, 1000)\n      })\n    })\n    this.hooks.arch.tapPromise('react', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('react', name);\n          resolve();\n        }, 1000)\n      })\n    })\n  }\n  start() {\n    this.hooks.arch.promise('Ertsul').then(() => {\n      console.log('hook all finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\n#### Synchook 同步钩子\n实现：\n```\nclass Synchook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      task(...args);\n    })\n  }\n}\n\nlet hook = new Synchook(['Synchook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n![image.png](https://upload-images.jianshu.io/upload_images/659084-1d12026d2f938c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncBailHook 同步熔断钩子\nSynchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。\n\n实现：\n```\n// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数\nclass Syncbailhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let ret = ''; // 当前函数的返回值\n    let index = 0; // 当前任务数组的索引\n    do {\n      ret = this.tasks[index++](...args);\n    } while (ret === undefined && index < this.tasks.length)\n  }\n}\n\nlet hook = new Syncbailhook(['Syncbailhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-3a46a477c8b08d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncWaterfallHook 同步瀑布钩子\nSyncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。\n\n实现：\n```\n/**\n * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系\n * 上一个函数的执行返回结果在当前函数的输入\n */\nclass Syncwaterfallhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let [first, ...others] = this.tasks;\n    let ret = first(...args);\n    others.reduce((prev, current) => {\n      return current(prev);\n    }, ret)\n  }\n}\n\nlet hook = new Syncwaterfallhook(['Syncwaterfallhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return 'vue learnt';\n})\nhook.tap('react', (data) => {\n  console.log('react', data);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-5ccbc856cac523cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncLoopHook 同步循环钩子\n同步循环钩子回让某个函数执行一定的次数。\n\n实现：\n```\n// Tapable Syncloophook 同步循环钩子\nclass Syncloophook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      let ret = '';\n      do {\n        ret = task(...args);\n      } while (ret != undefined);\n    })\n  }\n}\n\nlet hook = new Syncloophook(['Syncloophook']);\nconst total = 3;\nlet index = 0;\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return ++index === total ? undefined : 'continue';\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fd5d933715541d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### AsyncParallelHook 异步并发钩子 回调函数方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapAsync(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  callAsync(...args) { // 发布事件\n    let finalCallback = args.pop();\n    let index = 0;\n    const done = () => {\n      index++;\n      if (index === this.tasks.length) {\n        finalCallback();\n      }\n    }\n    this.tasks.forEach(task => {\n      task(...args, done);\n    })\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapAsync('vue', (name, cb) => {\n  setTimeout(() => {\n    console.log('vue', name);\n    cb && cb();\n  }, 1000)\n})\nhook.tapAsync('react', (name, cb) => {\n  setTimeout(() => {\n    console.log('react', name);\n    cb && cb();\n  }, 1000)\n})\nhook.callAsync('Ertsul', () => {\n  console.log('All hook finished!');\n});\n```\n\n#### AsyncParallelHook 异步并发钩子 Promise方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapPromise(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  promise(...args) { // 发布事件\n    let tasks = this.tasks.map(task => task(...args));\n    return Promise.all(tasks);\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapPromise('vue', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('vue', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.tapPromise('react', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('react', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.promise('Ertsul').then(() => {\n  console.log('All hooks finished!');\n})\n```\n\n#### AsyncSeriesHook 异步串行钩子\n#### AsyncWaterfallHook 异步瀑布流钩子","tags":["frontEnd","webpack"]},{"title":"hello-hexo","url":"/2019/02/16/hello-hexo/","content":"## Hello Hexo\n决定把简书的文章转移到 **hexo** 上。"}]