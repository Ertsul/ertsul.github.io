[{"title":"js/es6小知识大杂烩","url":"/2019/02/16/js-es6小知识大杂烩/","content":"\n#### 合并两个数组\n- 数组的解构 **[...arr1, ...arr2]**\n- Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。\n- arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。\n\n```\nlet arr1 = [1, 2, 3];\nlet arr2 = [4, 5, 6];\nlet arr3 = [...arr1,  ...arr2];\nconsole.log(arr3);\nArray.prototype.push.apply(arr1,  arr2);\nconsole.log(arr1);\n```\n\n#### arguments/伪数组 转化为数组\n- [...arguments]\n- Array.prototype.slice.call(arguments)\n\n```\n(function Fn() {\n    let arr = [...arguments, 'Ertsul'];\n    console.log(arr);\n})('zero');\n(function Fn1() {\n    let arr = Array.prototype.slice.call(arguments);\n    console.log(arr);\n})('zero');\n```\n\n#### 判断字符类型\n- Object.prototype.toString.call()\n- typeof\n- instanceof\n\n#### 创建实例的方法\n- 字面量 let obj = {...}\n- new Object()构造函数\n- 构造函数\n- Object.create()\n- 工厂模式\n\n```\n// 字面量\nlet obj1 = {\n    name: 'zero',\n    age: 22\n};\n// Object 构造函数\nlet obj2 = new Object();\nobj2.name = 'zero';\nconsole.log(obj2.name);\n// 工厂模式\nfunction Person(name) {\n    let obj = new Object();\n    obj.name = name;\n    return obj;\n}\nlet p1 = Person('zero');\nconsole.log(p1.name);\n// 构造函数\nfunction Animal(name) {\n    this.name = name;\n}\nlet a2 = new Animal('dog');\nconsole.log(a2.name);\n```\n\n#### 继承的方法 -- 8种\n- 通过原型继承\n  - 缺点：引用类型存在共享问题。\n\n````\nfunction Fn1() { ... }\nfunction Fn2() { ... }\nFn2.prototype = new Fn1();\n````\n\n- 构造函数：通过 **call** 更改 **this** 指向；实际上是调用了父类的构造函数。\n  - 缺点：父类中的方法（构造函数中）子类不可见。\n\n````\nfunction Fn1() { ... }\nfunction Fn2() { \n  Fn1.call(this);   // 将 this 绑定到 Fn1\n}\n````\n\n````\nfunction SuperType(){\n    \n}\nSuperType.prototype.sayHi = function(){\n    console.log('Hi');\n}\n\nfunction subType(){\n    SuperType.call(this);\n}\n\nlet superIns = new SuperType();\nsuperIns.sayHi();   // Hi\n\nlet subIns = new subType();\nsubIns.sayHi();     // Uncaught TypeError\n````\n\n- 组合继承（原型 + 构造）\n属性通过构造函数继承；方法通过原型继承。记得要更改 **Fn2.prototype.constructor** 的指向，指向子类。\n\n````\n// 组合继承\nfunction Fn1() {\n    this.name = 'zero'\n}\n\nFn1.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction Fn2() {\n    // 继承属性\n    Fn1.call(this);\n    this.age = 22;\n}\n// 继承方法\nFn2.prototype = new Fn1();\nFn2.prototype.constructor = Fn2;   // 需要修复构造函数指向\n\nFn2.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nlet f = new Fn2();\nf.sayName();\nf.sayAge();\n````\n\n- 实例继承\n在一个函数内实例化，然后添加新属性，并返回该对象。\n\n````\nfunction Fn() { ... }\nfunction Fn2(name) {\n let obj = new Fn();\n obj.name = name;\n return obj;\n}\n````\n\n- 原型式继承\n将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。\n\n````\nfunction SuperType(name) {\n    this.name = name\n}\n\nfunction Object(o){\n    function F(){}\n    F.prototype = o;\n    return new F();\n}\n\nlet subType = Object(new SuperType('zero'));\nconsole.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__\n````\n\n- 拷贝继承\n将原型/父类上的属性全部拷贝到子类上。\n\n````\n// 拷贝继承\nfunction Fn1() {\n    this.name = 'zero';\n    this.age = 22\n}\nfunction Fn2() {\n    let f1 = new Fn1();\n    // 注意这里要用 in 操作符\n    for (let item in f1) {\n        Fn2.prototype[item] = f1[item];\n    }\n    Fn2.prototype.ownFun = function () {\n        console.log('my own function.');\n    }\n}\n\nlet f = new Fn2();\nconsole.log(f.name + \", \" + f.age);\nf.ownFun();\n````\n\n- 寄生组合式模型\n  - 通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。\n  - 通过构造函数实现属性的继承。\n\n````\n// 寄生组合式继承\nfunction inheritPrototype(subType, superType) {\n    // 创建对象：新建的对象指向父类的原型\n    let prototype = Object(superType.prototype);\n    // 增强对象：新建对象的 constructor 指向子类\n    prototype.constructor = subType;\n    // 指定对象：子类的原型指向新建对象\n    subType.prototype = prototype;\n}\n\nfunction Fn1() {\n    this.name = 'Ertsul';\n}\n\nFn1.prototype.sayName = function () {\n    console.log(this.name);\n};\n\nfunction Fn2() {\n    Fn1.call(this);\n    this.age = 22;\n}\n\ninheritPrototype(Fn2, Fn1);\n\nFn2.prototype.sayAge = function () {\n    console.log(this.age);\n};\n\nlet f = new Fn2();\nf.sayName();f.sayAge();\n````\n\n- es6 的 extends \n\n````\n// class\nclass F1 {\n    constructor(name) {\n        this.name = name;\n    }\n}\n\nclass F2 extends F1 {\n    constructor(name, age){\n        super(name);    // 调用父类的构造函数\n        this.age = age;\n    }\n    showMsg(){\n        console.log(this.name + ', ' + this.age);\n    }\n}\n\nlet p = new F2('zero', 22);\np.showMsg();  // zero, 22\n````\n\n#### 比较两个对象是否相等\n- 遍历对象对象进行判断。\n- 将对象转化为字符串进行判断。\n\n````\nlet obj1 = {\n    name: 'a',\n    age: 1\n}\nlet obj2 = obj1;\nlet obj3 = {\n    name: 'a',\n    age: 2\n}\nconsole.log(JSON.stringify(obj1));\nconsole.log(JSON.parse(JSON.stringify(obj1)));\nconsole.log(JSON.stringify(obj1) == JSON.stringify(obj2));  // true\nconsole.log(JSON.stringify(obj1) == JSON.stringify(obj3));  // false    \n````\n\n#### 封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行\n\n````\nfunction time(time){\n    return new Promise((resolve, reject) => {\n        setTimeout(resolve, time);\n    })\n}\n\nlet t = new time(5000);\nt.then((a, b) => {\n    console.log('time');\n})\n````\n\n#### 原型相关的API\n- Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例\n- Object.getPrototypeOf(p1)：获取原型\n- p1.hasOwnProperty('name')：判断某个属性是否属于某个实例（只能获取属性实例）\n- in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中）\n\n````\nfunction Person(name, age) {\n    this.name = name;\n    this.age = age;\n}\n\nlet p1 = new Person('Ertsul', 22);\nconsole.log(Person.prototype);      // constructor f\nconsole.log(Person.prototype.constructor);  // Person\nconsole.log(Person.prototype.__proto__);    // constructor 的原型\nconsole.log(p1.__proto__);      // // constructor f\n\nconsole.log(Person.prototype.isPrototypeOf(p1));    // true\nconsole.log(Person.isPrototypeOf(p1));      // false\nconsole.log(Object.getPrototypeOf(p1));     // constructor f\n\nconsole.log(p1.hasOwnProperty('name'));     // true 存在实例中\n\nPerson.prototype.num = 100\n\nconsole.log(p1.hasOwnProperty('num'));      // fasle    存在原型中\n\nconsole.log('num' in p1);   // true 不管是实例还是原型中\n````\n\n#### js 判断数组类型\n- arr instanceof Array\n- arr.constructor === Array\n\n````\nlet arr = [1, 2, 3];\nlet obj = {}\nfunction judgeFn(arr){\n    // return arr.constructor === Array ? true : false\n    return arr instanceof Array ? true : false\n}\nconsole.log(judgeFn(arr));  // true\nconsole.log(judgeFn(obj )); // false\n````\n\n#### 日期格式化\n````\n/* 日期格式化 */\nfunction formatNumber(num) {\n\tconst n = `${num}`;\t\t// 转化为字符串\n\treturn n[1] ? n : `0${n}`;\n}\nfunction formatTime(date){\n\t// 年 月 日\n\tconst year = date.getFullYear();\n\tconst month = date.getMonth() + 1;\n\tconst day = date.getDate();\n\t// 时 分 秒\n\tconst hour = date.getHours();\n\tconst minute = date.getMinutes();\n\tconst second = date.getSeconds();\n\n\treturn `${[year, month, day].map(formatNumber).join('-')} ${[hour, minute, second].map(formatNumber).join(':')}`\n}\nlet time = new Date();\nconsole.log(time);\t\t// Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间)\nlet t1 = formatTime(time);\nconsole.log(t1);\t\t// 2018-08-14 16:52:06\n````\n\n#### 字符串转化为标准日期格式\n````\n/* 字符串转化为标准日期格式 */\nfunction time2string(str) {\n\tconst chunks = str.split(' ');\n\tconst date = chunks[0].split('-');\n\tconst time = chunks[1].split(':');\n\n\treturn new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]);\n}\nlet str = \"2018-08-14 23:59:59\";\nlet t2 = time2string(str);\nconsole.log(t2);\t// Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间)\n````\n#### 防抖节流\n````\n/* 防抖节流 debounce throttle */\n// 防抖 - 连续快速触发的解决方案\nfunction debounce(fn, wait) {\n\tlet timeout = null;\t// 初始化 timer 定时器\n\treturn function (){\n\t\ttimeout && clearTimeout(timeout);\t// 清空定时器\n\t\ttimeout = setTimeout(fn, wait);\t\t// 设置定时器\n\t}\n}\n// 节流 - 一定时间内请求一次 -- 定时器法\nfunction throttle1(fn, wait) {\n\tlet timer = null;\t// 初始化 timer 定时器\n\treturn function () {\n\t\tlet context = this;\t\t// 保存上下文 this\n\t\tlet args = arguments;\t// 记录参数\n\t\tif(!timer) {\t// 定时器为空\n\t\t\ttimer = setTimeout(() => {\n\t\t\t\tfn.apply(context, args);\n\t\t\t\ttimer = null;\t// 清空定时器\n\t\t\t}, wait);\n\t\t}\n\t}\n}\n// 节流 - 一定时间内请求一次 -- 时间戳法\nfunction throttle2(fn, wait) {\n\tlet prev = Date.now();\t// 记录前一个时间\n\treturn function () {\n\t\tlet context = this;\t\t// 保存上下文 this\n\t\tlet args = arguments;\t// 记录参数\n\t\tlet now = Date.now(); \t// 记录当前时间\n\t\tif(now - prev >= wait){\t\t// 时间戳大于设置的时间\n\t\t\tfn.apply(context, args);\n\t\t\tprev = Date.now();\t// 记录前一个时间\n\t\t}\n\t}\n}\n\n// window.addEventListener('scroll', debounce(() => {\n //    console.log(Math.random());\n// }, 500));\n// window.addEventListener('scroll', throttle1(() => {\n// \tconsole.log(Math.random());\n// }, 1000));\nwindow.addEventListener('scroll', throttle2(() => {\n\tconsole.log(Math.random());\n}, 1000))\n````\n- JSON.stringfy(obj, [replace, space])\n  - 巧用第二个参数，可以实现json对象的过滤替换。\n  - 第三个参数，是缩进的空格数。    \n  - 如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。\n```\nlet obj1 = {\n    name: 'zero',\n    age: 22,\n    hobby: 'ball'\n};\n\nlet str1 = JSON.stringify(obj1);\nconsole.log(str1, typeof str1, str1.constructor === String);    // {\"name\":\"zero\",\"age\":22,\"hobby\":\"ball\"} string true\nlet str2 = JSON.stringify(obj1, (key, value) => {\n    if(value === 'zero') {\n        return 'Ertsul.'\n    }else {\n        return value;\n    }\n});\nconsole.log(str2);  // {\"name\":\"Ertsul.\",\"age\":22,\"hobby\":\"ball\"}\n\nlet obj2 = {\n    num: 100,\n    toJSON(){\n        return 'apple'\n    }\n};\n\nlet str3 = JSON.stringify(obj2);\nconsole.log(str3);  // apple\n```\n\n- 数组的 sort()\nsort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。\n如果要对数组的数字进行排序，则需要：\n>array.sort((val1, val2) => {return val - val2});\n\n通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。\n\n```\nlet arr10 = [1, 2, 19, 12, 22];\nconsole.log(arr10.sort()); // [1, 12, 19, 2, 22]\nconsole.log(arr10.sort((val1, val2) => {  // [1, 2, 12, 19, 22]\n  return val1 - val2;\n}));  \n```\n\n- reduce函数\n> reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。\n\n其完整的函数为： \n\n```\narr.reduce((prev, next, cur, srcArr) => {\n  ......\n}, initVal)\n```\n\n- prev: 上次返回的值\n- next: 下一个数组元素的值\n- cur: 当前数组元素的索引值\n- scrArr: 源数组\n- initVal: 设置第一次的 **prev**\n\n例子 1：\n```\nlet arr = ['apple', 'pear', 'bananas'];\narr.reduce((prev, next, cur, arr) => {\n  console.warn(prev, next, cur, arr);\n  return next;\n}, 'fruit')\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-65c2bd1bf155dfaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n例子 2：统计一个数组中单词出现的次数\n```\n// 统计数组中单词出现的次数\nlet arr = [\"apple\", \"orange\", \"apple\", \"orange\", \"pear\", \"orange\", \"bananas\", \"bananas\"];\nfunction getCount(arr) {\n  return arr.reduce((prev, next, cur) => {\n    prev[next] = (prev[next] + 1) || 1\n    return prev;\n  }, {})\n}\nconsole.warn(getCount(arr));  // {apple: 2, orange: 3, pear: 1, bananas: 2}\n```\n\n- Object.seal()\n防止对象纂改：不能添加也不能删除属性\n\n```\nlet obj = {\n  name: 'Ersul'\n}\nObject.seal(obj); // 防止对象纂改：不能删除也不能添加属性\ndelete obj.name;\nconsole.warn(obj.name); // Ertsul\nobj.age = 22;\nconsole.warn(obj.age); // undefined\n```\n\n- Object.freeze()\n冻结对象，不能修改对象任何属性的值。如若\n\n```\nlet obj = {\n  name: 'Ersul'\n}\n\nObject.freeze(obj); // 冻结对象，不能修改属性的值\nobj.name = 'Zero';\nconsole.warn(obj.name); // Ertsul\n```\n\n- 数组字符串的相互转化\n```\n// 数组 --> 字符串 : join()\nlet arr3 = [1, 2, 3, 4, 5];\nconsole.log(arr3.join('-'));\n// 字符串 --> 数组 : split()\nlet str = 'apple,pear,bananas';\nconsole.log(str.split(','));\n```","tags":["frontEnd","js","es6"]},{"title":"webpack学习笔记","url":"/2019/02/16/webpack学习笔记/","content":"\n## 项目构建\n- 新建项目文件夹\n- npm init\n- 设置项目目录结构，结构如下：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-bd9163add73e9ea0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n- **build** 目录是 webpack 打包后的生成目录，**index.html** 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。\n- **src** 目录是项目源文件，**template.html** 是 html 文件模板。\n- **webpack.config.js** 是配置 **webpack** 的总文件。\n\n```\nmodule.exports = { ... }\n```\n\n## 模式 mode\n\n```\nmode: \"development\", // development or production\n```\n\n## 入口 entry\n设置打包的入口文件, entry: filepath\n\n```\nentry: \"./src/index.js\", // 入口\n```\n\n## 输出 output\n设置打包后的输出文件，output: { ... }\n\n```\noutput: { // 输出\n  filename: \"bundle.[hash:8].js\",\n  path: path.resolve(__dirname + '/build'),\n  // publicPath: \"http://\", // 公共路径前缀\n},\n```\n注：\n- **path** 后面应是绝对路径。\n- **bundle.[hash:8].js** 中的 **[hash:8]** 可以在每次打包后都在文件后面追加 hash 值。\n\n通过上面三项，可以实现一个简单的 **webpack** 打包配置。在 **package.json** 添加脚本或直接执行 **./node_modules/.bin/webpack** 即可实现打包：\n\n```\n\"build\": \"./node_modules/.bin/webpack\",\n```\n\n## webpack-dev-server\nwebpack 开发服务器，用于开发时候的配置：\n- yarn add taco --dev webpack-dev-server / npm install --save-dev webpack-dev-server\n- 基本配置如下：\n\n```\ndevServer: { // 开发服务器\n  port: 3001,\n  contentBase: path.resolve(__dirname + '/build'), // 本地服务器目录\n  progress: true, // 进度条\n  open: true, // 自动打开浏览器\n  compress: true, // 压缩\n  // 1. 代理\n  proxy: {\n    \"/api\": {\n      target: \"\",\n      pathRewrite: {\n        \"/api\": \"\"\n      }\n    }\n  },\n  // 2. 用 express 内置钩子模拟数据\n  before(app) {\n    app.get(\"/api\", (req, res) => { ... })\n  },\n  // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件\n},\n},\n```\n\n- 在 **package.json** 添加脚本即可：\n\n```\n\"dev\": \"webpack-dev-server\"\n```\n\n## source-map && eval-source-map && cheap-module-source-map && cheap-module-eval-source-map\n\n作用：源码映射，报错时显示出错的位置。\n\n- source-map：会单独生成一个 **sourcemap** 文件；会显示行列。\n- eval-source-map：不会单独生成一个 **sourcemap** 文件，会将生成的 **sourcemap** 放到打包后的 **html** 文件；会显示行和列。\n- cheap-module-source-map：会生成 **sourcemap** 文件，不会显示列。\n- cheap-module-eval-source-map：不会生成 **sourcemap** 文件，集成在 **html** 文件中，不会显示列。\n\n```\ndevtool: \"source-map\", // 源码映射\n```\n\n## watch\n作用：监控代码实时变化，进行编译打包。\n\n```\nwatch: true, // 监控代码实时变化，进行编译打包\nwatchOptions: {\n  poll: 1000, // 多毫秒监控一次\n  aggreatement: 500, // 防抖\n  ignored: \"node_modules\" // 忽略文件夹\n},\n```\n\n## resolve\n作用：解析第三方包\n\n```\nresolve: { // 解析 第三方包\n  modules: [\n    path.resolve(\"node_modules\"), // 在当前目录下查找模块 \n    path.resolve(\"other_modules\"), // 在其他目录下查找模块 \n  ],\n  // 自动添加扩展名，主要是 import 时候使用, 依次解析\n  extensions: [\".js\", \".css\", \".json\", \".vue\"],\n  // 比如引用 bootstrap 的 css 样式\n  // 方式一： bootstrap 的主入口\n  mainFields: [\"style\", \"main\"],\n  // 方式二：别名  \n  // alias: {\n  //   bootstrap: \"bootstrap/dist/css/bootstrap.css\"\n  // }\n},\n```\n\n## 插件\nwebpack 的插件配置是一个数组，里面存放着各种各样的插件。\n\n```\nplugins: [\n new pluginName(...)\n]\n```\n\n#### html-webpack-plugin\n插件作用：打包时候自动根据 **html** 模板生成目标 **html** 文件，自动生成目标打包目录；另外，可配置 **html** 的相关打包配置，如：压缩，去双引号等。\n\n```\nnew HtmlWebpackPlugin({\n  filename: \"index.html\", // 目标文件名称\n  template: path.resolve(__dirname + '/src/template.html'), // 模板文件\n  minify: { // 压缩配置\n    removeAttributeQuotes: true, // 去双引号\n    collapseWhitespace: true, // 不换行\n  },\n  hash: true // 生成 hash 戳\n})\n```\n\n#### mini-css-extract-plugin\n作用：将生成的 **css样式** 抽离成一个 **css文件**，并将该样式文件引进目标 **html** 文件中。\n\n```\nplugins: [ // 插件\n  new MiniCssExtractPlugin({\n    filename: \"main.css\",\n  })\n],\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序\n      \"css-loader\"\n    ]\n  }]\n}\n```\n\n注：这里抽离出来的 **main.css** 文件并没有压缩，要通过手动添加以下两个插件到优化项：\n- optimize-css-assets-webpack-plugin\n- uglifyjs-webpack-plugin\n\n```\noptimization: { // 优化项\n  minimizer: [\n    new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件\n    new UglifyjsWebpackPlugin({\n      cache: true,\n      parallel: true,\n    }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置\n  ]\n},\n```\n\n#### optimize-css-assets-webpack-plugin\n插件作用：压缩抽离出来的 **main.css** 文件。但是，使用了 **optimize-css-assets-webpack-plugin** 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 **uglifyjs-webpack-plugin** 。\n\n#### uglifyjs-webpack-plugin\n插件作用：压缩打包后的 **js** 文件。\n\n#### clean-webpack-plugin\n作用：清理文件\n\n```\nplugins: [\n new CleanWebpackPlugin(\"./build\")\n]\n```\n\n#### copy-webpack-plugin\n作用：将某些文件拷贝到打包后的文件夹。\n\n```\nnew CopyWebpackPlugin([\n  {from: \"./copy\", to: \"./\"}\n])\n```\n\n#### banner-plugin\n作用：版权声明，是 **webpack** 的内置模块。\n\n```\nnew webpack.BannerPlugin(\"@copyright by Ertsul\")\n```\n\n#### webpack.DefinePlugin({ ... })\n作用：定义环境变量。\n\n```\nplugins: [\n  new webpack.DefinePlugin({\n    DEV: JSON.stringify(\"development\"),\n    PRO: JSON.stringify(\"production\")\n  })\n]\n```\n\n#### webpacfk.IgnorePlugin()\n作用：忽略模块的引进\n\n```\nplugins: [\n  new webpack.IgnorePlugin(/\\./locale/, /moment/)\n]\n```\n\n注：如果直接使用 **DEV: 'development'** 的话，会把 **DEV** 直接替换为 **引号内部的内容**。如：**console.log(DEV)**，会变成 **console.log(dev)**，最后的结果是 **undefined**。所以，需要通过 **JSON.stringfy()** 进行转化。\n\n## 模块 module\n模块主要是各种 **loader**，作用：解析各种类型的文件。\n\n```\nmodule: { \n rules: [\n   {\n     test: regx,\n     use: [loadName]\n   }\n ]\n}\n```\n\n#### css-loader / style-loader\n- css-loader：主要是用于解析在 **css** 文件中通过 **@import** 方式引进其他的 **css** 文件。\n- style-loader: 主要是用于将 **js** 文件中通过 **require** 方式引进的 **css** 文件插入到目标 **html** 文件的 **head** 中（插到最后，层级最高）。\n\n```\n// 数组方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\"style-loader\", \"css-loader\"] // loader 数组\n  }]\n}\n// 对象方式\nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/, // 正则\n    use: [\n      {\n        loader: \"style-loader\",\n        options: {\n          insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n        }\n      }, \n      \"css-loader\"\n    ]\n  }]\n}\n```\n注：**loader** 是从右向左、从下到上的执行顺序，故：**use: [\"style-loader\", \"css-loader\"]**\n\n#### postcss-loader + autoprefixer\n这两个的配合使用可以自动添加 **css** 的浏览器前缀。\n- autoprefixer：自动添加 **css** 的浏览器前缀。\n- postcss-loader：loader 处理 autoprefixer。\n\n```\n// 使用 postcss-loader \nmodule: { // 模块\n  rules: [{\n    test: /\\.css$/,\n    use: [\n      // {\n      //   loader: \"style-loader\",\n      //   options: {\n      //     insertAt: \"top\" // 插到 head 标签的顶部，更改优先级\n      //   }\n      // },\n      MiniCssExtractPlugin.loader,\n      \"css-loader\",\n      \"postcss-loader\" // 注意顺序\n    ]\n  }]\n}\n```\n\n- 根目录下新建 postcss.config.js 文件\n\n```\nmodule.exports = {\n  plugins: [\n    require(\"autoprefixer\")\n  ]\n}\n```\n\n#### babel-loader + @babel/core + @babel/preset-env\n作用：转化 es6 语法\n  \n```\nmodule: { // 模块\n  rules: [{\n    test: /\\.js$/,\n    use: {\n      loader: \"babel-loader\",\n      options: { // 用 babel-loader 需要把 es6 转化为 es5\n        presets: [\n          \"@babel/preset-env\", // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块\n        ],\n        // plugins: [...] // 其他的小插件\n      }\n    }\n  }]\n}\n```\n\n#### expose-loader\n作用：暴露全局的 **loader**，暴露到 **window** 上。\n\n```\n// 一般情况\nimport $ from 'jquery';\nconsole.log(window.$); // undefined\n// 内联 loader 方式\nimport $ from 'expose-loader?$!jquery';\nconsole.log(window.$);\n// 其他方式：在每个模块中注入\nnew webpack.ProvidePlugin({\n  $: \"jquery\"\n})\nconsole.log($);\nconsole.log(window.$); // undefined\n```\n\n#### file-loader && url-loader && html-withimg-loader\n在 **webpack** 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。\n\n- file-loader：**js** 文件中通过 **import** 方式引进图片。\n- html-withimg-loader：**html** 文件中通过 **scr** 方式引进图片。\n- 在 **css** 中使用图片，**style-loader** 已经做了处理。\n- url-loader：将图片转化为 **base64**\n\n```\nmodule: {\n  rules: [\n    {\n      test: /\\.(png|jpg|gif)$/,\n      use: {\n        loader: \"url-loader\",\n        options: {\n          limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader\n          // publicPath: \"http://\", // 公共路径前缀\n        }\n      }\n    },\n    {\n      test: /\\.html$/,\n      use: [\"html-withimg-loader\"]\n    }\n  ]\n}\n```\n`\n## 模块 module -- noParse\n作用：不解析指定包的依赖关系。\n\n```\nmodule: {\n  noParse: /jquery/\n}\n```\n\n## 模块 module -- exclude\n作用：排除\n\n```\nmodule: {\n  exclude: /node_module/\n}\n```\n\n## 模块 module -- include\n作用：包含\n\n```\nmodule: {\n  include: /src/\n}\n```\n\n\n\n## 区分不同环境，实现开发和生产配置的分离\n将 **webpack** 的配置文件划分为以下文件：\n\n- webpack.base.js：基本、共有的配置。\n- webpack.dev.js：开发配置。\n- webpack.prod.js：生产配置。\n\n使用 **webpack-merger** 插件：\n- 安装 **webpack-merge** 插件；\n- 引进目标模块\n\n```\nimport { smart } from \"webpack-merge\";\n```\n\n- 使用\n\n```\nconst base = require(\"webpack.base.js);\n\nmodule.exports = smart(base, {\n  ...\n})\n```\n\n## webpack 自带优化\n- **import** 语法（生成环境），**tree-shaking** 自动删除没有用到的代码；\n- **es6** 模块会把语法放到 **default** 上；\n- 自动省略可以简化的代码；\n- **scope hosting**，作用域提升。\n\n## webpack 懒加载\n- 通过 **import** 实现（该语法内部由 **jsonp** 实现），返回的是一个 **promise**。\n- 要在 **babel-loader** 中添加 **@babel/plugin-syntax-dynamic-import** 插件。\n- **vue** 和 **react** 的l懒加载都是这样实现的。\n\n```\n/*\n* 模拟点击加载 source.js 的内容\n*/\n// 1\n{\n  loader: 'babel-loader',\n  options: {\n    presets: [\n      '@babel/preset-env'\n    ],\n    plugins: [\n      '@babel/plugin-syntax-dynamic-import'\n    ]\n  },\n}\n// 2\nlet btn = document.createElement('button');\nbtn.innerHTML = 'btn';\nbtn.addEventListener('click', function () {\n  // 内部由 jsonp 实现动态加载文件\n  import('./source.js')\n    .then(data => {\n      console.log(data);\n    })\n})\ndocument.body.appendChild(btn);\n\n```\n\n点击按钮后结果如下：\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fa79ce43578285a0.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n## 热更新 / 热替换 / Hot Module Replacement / HMR\n热更新：页面只更新改动的模块。\n\n- **devServer** 开始 **hot** 热更新模块。\n- 使用 **webpack** 内置热更新插件。\n  - NamedModulesPlugin\n  - HotModuleReplacementPlugin\n\n```\n// devServer 配置\ndevServer: {\n  port: 8089,\n  contentBase: path.resolve(__dirname + '/dist/'),\n  compress: true,\n  progress: true,\n  // open: true\n  hot: true, // 开启热更新，只更新更改的模块\n},\n// 添加插件\nplugins: [\n  new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径\n  new webpack.HotModuleReplacementPlugin(), // 热更新\n]\n```\n\n- 使用热更新\n\n```\nimport source from './source.js';\n\nconsole.log(source);\n\n// 添加热更新操作，不然不会实现热更新\nif (module.hot) {\nmodule.hot.accept('./source.js', () => {\n  require('./source.js');\n})\n```\n\n## 多线程打包\n使用 **happypack** 可以实现多线程打包。\n\n- 安装并引进 **happypack**;\n- 改写 **module**;\n- **plugin** 配置。\n\n```\n// 改写 module\nmodule: {\n  rules: [\n    {\n      test: /\\.js$/,\n      // use: {\n      //   loader: 'babel-loader',\n      //   options: {\n      //     presets: [\n      //       '@babel/preset-env'\n      //     ]\n      //   }\n      // }\n      use: {\n        loader: 'Happypack/loader?id=js',\n      }\n    },\n  ]\n}\n// plugin 配置\nplugins: [\n  new Happypack({\n    id: 'js',\n    use: [\n      {\n        loader: 'babel-loader',\n        options: {\n          presets: [\n            '@babel/preset-env'\n          ]\n        }\n      }\n    ]\n  }),\n]\n```\n\n## 多页面打包\n\n```\nconst path = require(\"path\");\nconst HtmlWebpackPlugin = require(\"html-webpack-plugin\");\n\nmodule.exports = {\n  mode: \"production\",\n  entry: {\n    home: \"./src/home.js\",\n    about: \"./src/about.js\",\n    other: \"./src/other.js\"\n  },\n  output: {\n    path: path.resolve(__dirname + \"/build/\"),\n    filename: \"[name].js\",\n  },\n  plugins: [\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"home.html\",\n      chunks: [\"home\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"other.html\",\n      chunks: [\"other\"]\n    }),\n    new HtmlWebpackPlugin({\n      template: path.resolve(__dirname + \"/src/template.html\"),\n      filename: \"about.html\",\n      chunks: [\"about\"]\n    }),\n  ]\n}\n```\n\n## 多页面打包抽离公共代码块\n打包 **多页面** 需要将公共的代码块抽离出来进行优化：\n\n```\noptimation: {\n  splitChunks: {  // 分割代码块\n    cacheGroups: {  // 缓存组\n      common: {  // 公共的模块\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      },\n      vender: {  // 第三方模块\n        priority: 1,  // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用\n        test: /node_modules/,  // 抽离出来\n        chunks: 'initial',  // 从哪里开始，initial 即：入口\n        miniSize: 0,  // 大小大于多少字节的时候抽离\n        miniChunks: 2  // 引用多少次的时候抽离\n      }\n    }\n  }\n}\n```\n\n## Tapable\n**webpack** 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 **Tapable**，通过 **Tapable** 实现各种钩子（如同步钩子异步钩子）。而 **Tapable** 核心是依赖于 **发布订阅者模式**。\n\n- 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tap** 注册。\n\n使用：\n```\nconst { SyncHook } = require('tapable');\n\nclass Hook {\n  constructor() {\n    this.hooks = {\n      arch: new SyncHook(['name'])\n    }\n  }\n  tap() { // 注册监听事件\n    this.hooks.arch.tap('vue', (name) => {\n      console.log('vue', name);\n    })\n    this.hooks.arch.tap('react', (name) => {\n      console.log('react', name);\n    })\n  }\n  start() { // 开始\n    this.hooks.arch.call('Ertsul')\n  }\n}\nlet h = new Hook();\nh.tap();\nh.start();\n```\n\n- 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 **tapAsync** 注册。\n\nsetTimeout()方式使用：\n\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapAsync('vue', (name, cb) => {\n      setTimeout(() => {\n        console.log('vue', name);\n        cb && cb();\n      }, 1000)\n    })\n    this.hooks.arch.tapAsync('react', (name, cb) => {\n      setTimeout(() => {\n        console.log('react', name);\n        cb && cb();\n      }, 1000)\n    })\n  }\n  start() {\n    this.hooks.arch.callAsync('Ertsul', () => {\n      console.log('All finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\nPromise()方式使用：\n```\nconst { AsyncParallelHook } = require('tapable');\n\nclass AsyncHook {\n  constructor() {\n    this.hooks = {\n      arch: new AsyncParallelHook(['name'])\n    }\n  }\n  tap() {\n    this.hooks.arch.tapPromise('vue', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('vue', name);\n          resolve();\n        }, 1000)\n      })\n    })\n    this.hooks.arch.tapPromise('react', (name) => {\n      return new Promise((resolve, reject) => {\n        setTimeout(() => {\n          console.log('react', name);\n          resolve();\n        }, 1000)\n      })\n    })\n  }\n  start() {\n    this.hooks.arch.promise('Ertsul').then(() => {\n      console.log('hook all finished!');\n    })\n  }\n}\n\nconst a = new AsyncHook();\na.tap();\na.start();\n```\n\n#### Synchook 同步钩子\n实现：\n```\nclass Synchook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      task(...args);\n    })\n  }\n}\n\nlet hook = new Synchook(['Synchook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n![image.png](https://upload-images.jianshu.io/upload_images/659084-1d12026d2f938c58.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncBailHook 同步熔断钩子\nSynchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。\n\n实现：\n```\n// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数\nclass Syncbailhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let ret = ''; // 当前函数的返回值\n    let index = 0; // 当前任务数组的索引\n    do {\n      ret = this.tasks[index++](...args);\n    } while (ret === undefined && index < this.tasks.length)\n  }\n}\n\nlet hook = new Syncbailhook(['Syncbailhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-3a46a477c8b08d40.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncWaterfallHook 同步瀑布钩子\nSyncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。\n\n实现：\n```\n/**\n * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系\n * 上一个函数的执行返回结果在当前函数的输入\n */\nclass Syncwaterfallhook {\n  constructor(args) {\n    this.tasks = [];\n  }\n  tap(name, task) {\n    this.tasks.push(task);\n  }\n  call(...args) {\n    let [first, ...others] = this.tasks;\n    let ret = first(...args);\n    others.reduce((prev, current) => {\n      return current(prev);\n    }, ret)\n  }\n}\n\nlet hook = new Syncwaterfallhook(['Syncwaterfallhook']);\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return 'vue learnt';\n})\nhook.tap('react', (data) => {\n  console.log('react', data);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-5ccbc856cac523cf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### SyncLoopHook 同步循环钩子\n同步循环钩子回让某个函数执行一定的次数。\n\n实现：\n```\n// Tapable Syncloophook 同步循环钩子\nclass Syncloophook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tap(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  call(...args) { // 发布事件\n    this.tasks.forEach(task => {\n      let ret = '';\n      do {\n        ret = task(...args);\n      } while (ret != undefined);\n    })\n  }\n}\n\nlet hook = new Syncloophook(['Syncloophook']);\nconst total = 3;\nlet index = 0;\nhook.tap('vue', (name) => {\n  console.log('vue', name);\n  return ++index === total ? undefined : 'continue';\n})\nhook.tap('react', (name) => {\n  console.log('react', name);\n})\nhook.call('Ertsul');\n```\n\n![image.png](https://upload-images.jianshu.io/upload_images/659084-fd5d933715541d45.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240)\n\n#### AsyncParallelHook 异步并发钩子 回调函数方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapAsync(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  callAsync(...args) { // 发布事件\n    let finalCallback = args.pop();\n    let index = 0;\n    const done = () => {\n      index++;\n      if (index === this.tasks.length) {\n        finalCallback();\n      }\n    }\n    this.tasks.forEach(task => {\n      task(...args, done);\n    })\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapAsync('vue', (name, cb) => {\n  setTimeout(() => {\n    console.log('vue', name);\n    cb && cb();\n  }, 1000)\n})\nhook.tapAsync('react', (name, cb) => {\n  setTimeout(() => {\n    console.log('react', name);\n    cb && cb();\n  }, 1000)\n})\nhook.callAsync('Ertsul', () => {\n  console.log('All hook finished!');\n});\n```\n\n#### AsyncParallelHook 异步并发钩子 Promise方式\n实现：\n```\n// Tapable Asynchook 异步钩子\nclass asyncparallelhook {\n  constructor(args) { // args => ['Synchook']\n    this.tasks = []; // 注册事件数组\n  }\n  tapPromise(name, task) { //  注册事件\n    this.tasks.push(task);\n  }\n  promise(...args) { // 发布事件\n    let tasks = this.tasks.map(task => task(...args));\n    return Promise.all(tasks);\n  }\n}\n\nlet hook = new asyncparallelhook(['asyncparallelhook']);\nhook.tapPromise('vue', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('vue', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.tapPromise('react', (name) => {\n  return new Promise((resolve, reject) => {\n    setTimeout(() => {\n      console.log('react', name);\n      resolve();\n    }, 1000)\n  })\n})\nhook.promise('Ertsul').then(() => {\n  console.log('All hooks finished!');\n})\n```\n\n#### AsyncSeriesHook 异步串行钩子\n#### AsyncWaterfallHook 异步瀑布流钩子","tags":["frontEnd","webpack"]},{"title":"hello-hexo","url":"/2019/02/16/hello-hexo/","content":"## Hello Hexo\n决定把简书的文章转移到 **hexo** 上。"}]