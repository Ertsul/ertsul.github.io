{"meta":{"title":"Ertsul","subtitle":null,"description":"Ertsul's Blog","author":"Ertsul","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-02-16T14:42:19.000Z","updated":"2019-02-16T15:13:21.129Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Stay Hungry, stay foolish."}],"posts":[{"title":"js/es6小知识大杂烩","slug":"js-es6小知识大杂烩","date":"2019-02-16T15:46:09.000Z","updated":"2019-02-16T15:49:02.348Z","comments":true,"path":"2019/02/16/js-es6小知识大杂烩/","link":"","permalink":"http://yoursite.com/2019/02/16/js-es6小知识大杂烩/","excerpt":"","text":"合并两个数组 数组的解构 […arr1, …arr2] Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。 arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。 123456let arr1 = [1, 2, 3];let arr2 = [4, 5, 6];let arr3 = [...arr1, ...arr2];console.log(arr3);Array.prototype.push.apply(arr1, arr2);console.log(arr1); arguments/伪数组 转化为数组 […arguments] Array.prototype.slice.call(arguments) 12345678(function Fn() &#123; let arr = [...arguments, &apos;Ertsul&apos;]; console.log(arr);&#125;)(&apos;zero&apos;);(function Fn1() &#123; let arr = Array.prototype.slice.call(arguments); console.log(arr);&#125;)(&apos;zero&apos;); 判断字符类型 Object.prototype.toString.call() typeof instanceof 创建实例的方法 字面量 let obj = {…} new Object()构造函数 构造函数 Object.create() 工厂模式 1234567891011121314151617181920212223// 字面量let obj1 = &#123; name: &apos;zero&apos;, age: 22&#125;;// Object 构造函数let obj2 = new Object();obj2.name = &apos;zero&apos;;console.log(obj2.name);// 工厂模式function Person(name) &#123; let obj = new Object(); obj.name = name; return obj;&#125;let p1 = Person(&apos;zero&apos;);console.log(p1.name);// 构造函数function Animal(name) &#123; this.name = name;&#125;let a2 = new Animal(&apos;dog&apos;);console.log(a2.name); 继承的方法 – 8种 通过原型继承 缺点：引用类型存在共享问题。 123function Fn1() &#123; ... &#125;function Fn2() &#123; ... &#125;Fn2.prototype = new Fn1(); 构造函数：通过 call 更改 this 指向；实际上是调用了父类的构造函数。 缺点：父类中的方法（构造函数中）子类不可见。 1234function Fn1() &#123; ... &#125;function Fn2() &#123; Fn1.call(this); // 将 this 绑定到 Fn1&#125; 12345678910111213141516function SuperType()&#123; &#125;SuperType.prototype.sayHi = function()&#123; console.log(&apos;Hi&apos;);&#125;function subType()&#123; SuperType.call(this);&#125;let superIns = new SuperType();superIns.sayHi(); // Hilet subIns = new subType();subIns.sayHi(); // Uncaught TypeError 组合继承（原型 + 构造）属性通过构造函数继承；方法通过原型继承。记得要更改 Fn2.prototype.constructor 的指向，指向子类。 12345678910111213141516171819202122232425// 组合继承function Fn1() &#123; this.name = &apos;zero&apos;&#125;Fn1.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Fn2() &#123; // 继承属性 Fn1.call(this); this.age = 22;&#125;// 继承方法Fn2.prototype = new Fn1();Fn2.prototype.constructor = Fn2; // 需要修复构造函数指向Fn2.prototype.sayAge = function () &#123; console.log(this.age);&#125;;let f = new Fn2();f.sayName();f.sayAge(); 实例继承在一个函数内实例化，然后添加新属性，并返回该对象。 123456function Fn() &#123; ... &#125;function Fn2(name) &#123; let obj = new Fn(); obj.name = name; return obj;&#125; 原型式继承将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。 123456789101112function SuperType(name) &#123; this.name = name&#125;function Object(o)&#123; function F()&#123;&#125; F.prototype = o; return new F();&#125;let subType = Object(new SuperType(&apos;zero&apos;));console.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__ 拷贝继承将原型/父类上的属性全部拷贝到子类上。 12345678910111213141516171819// 拷贝继承function Fn1() &#123; this.name = &apos;zero&apos;; this.age = 22&#125;function Fn2() &#123; let f1 = new Fn1(); // 注意这里要用 in 操作符 for (let item in f1) &#123; Fn2.prototype[item] = f1[item]; &#125; Fn2.prototype.ownFun = function () &#123; console.log(&apos;my own function.&apos;); &#125;&#125;let f = new Fn2();console.log(f.name + &quot;, &quot; + f.age);f.ownFun(); 寄生组合式模型 通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。 通过构造函数实现属性的继承。 12345678910111213141516171819202122232425262728293031// 寄生组合式继承function inheritPrototype(subType, superType) &#123; // 创建对象：新建的对象指向父类的原型 let prototype = Object(superType.prototype); // 增强对象：新建对象的 constructor 指向子类 prototype.constructor = subType; // 指定对象：子类的原型指向新建对象 subType.prototype = prototype;&#125;function Fn1() &#123; this.name = &apos;Ertsul&apos;;&#125;Fn1.prototype.sayName = function () &#123; console.log(this.name);&#125;;function Fn2() &#123; Fn1.call(this); this.age = 22;&#125;inheritPrototype(Fn2, Fn1);Fn2.prototype.sayAge = function () &#123; console.log(this.age);&#125;;let f = new Fn2();f.sayName();f.sayAge(); es6 的 extends 12345678910111213141516171819// classclass F1 &#123; constructor(name) &#123; this.name = name; &#125;&#125;class F2 extends F1 &#123; constructor(name, age)&#123; super(name); // 调用父类的构造函数 this.age = age; &#125; showMsg()&#123; console.log(this.name + &apos;, &apos; + this.age); &#125;&#125;let p = new F2(&apos;zero&apos;, 22);p.showMsg(); // zero, 22 比较两个对象是否相等 遍历对象对象进行判断。 将对象转化为字符串进行判断。 12345678910111213let obj1 = &#123; name: &apos;a&apos;, age: 1&#125;let obj2 = obj1;let obj3 = &#123; name: &apos;a&apos;, age: 2&#125;console.log(JSON.stringify(obj1));console.log(JSON.parse(JSON.stringify(obj1)));console.log(JSON.stringify(obj1) == JSON.stringify(obj2)); // trueconsole.log(JSON.stringify(obj1) == JSON.stringify(obj3)); // false 封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行12345678910function time(time)&#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(resolve, time); &#125;)&#125;let t = new time(5000);t.then((a, b) =&gt; &#123; console.log(&apos;time&apos;);&#125;) 原型相关的API Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例 Object.getPrototypeOf(p1)：获取原型 p1.hasOwnProperty(‘name’)：判断某个属性是否属于某个实例（只能获取属性实例） in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中） 12345678910111213141516171819202122function Person(name, age) &#123; this.name = name; this.age = age;&#125;let p1 = new Person(&apos;Ertsul&apos;, 22);console.log(Person.prototype); // constructor fconsole.log(Person.prototype.constructor); // Personconsole.log(Person.prototype.__proto__); // constructor 的原型console.log(p1.__proto__); // // constructor fconsole.log(Person.prototype.isPrototypeOf(p1)); // trueconsole.log(Person.isPrototypeOf(p1)); // falseconsole.log(Object.getPrototypeOf(p1)); // constructor fconsole.log(p1.hasOwnProperty(&apos;name&apos;)); // true 存在实例中Person.prototype.num = 100console.log(p1.hasOwnProperty(&apos;num&apos;)); // fasle 存在原型中console.log(&apos;num&apos; in p1); // true 不管是实例还是原型中 js 判断数组类型 arr instanceof Array arr.constructor === Array 12345678let arr = [1, 2, 3];let obj = &#123;&#125;function judgeFn(arr)&#123; // return arr.constructor === Array ? true : false return arr instanceof Array ? true : false&#125;console.log(judgeFn(arr)); // trueconsole.log(judgeFn(obj )); // false 日期格式化123456789101112131415161718192021/* 日期格式化 */function formatNumber(num) &#123; const n = `$&#123;num&#125;`; // 转化为字符串 return n[1] ? n : `0$&#123;n&#125;`;&#125;function formatTime(date)&#123; // 年 月 日 const year = date.getFullYear(); const month = date.getMonth() + 1; const day = date.getDate(); // 时 分 秒 const hour = date.getHours(); const minute = date.getMinutes(); const second = date.getSeconds(); return `$&#123;[year, month, day].map(formatNumber).join(&apos;-&apos;)&#125; $&#123;[hour, minute, second].map(formatNumber).join(&apos;:&apos;)&#125;`&#125;let time = new Date();console.log(time); // Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间)let t1 = formatTime(time);console.log(t1); // 2018-08-14 16:52:06 字符串转化为标准日期格式1234567891011/* 字符串转化为标准日期格式 */function time2string(str) &#123; const chunks = str.split(&apos; &apos;); const date = chunks[0].split(&apos;-&apos;); const time = chunks[1].split(&apos;:&apos;); return new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]);&#125;let str = &quot;2018-08-14 23:59:59&quot;;let t2 = time2string(str);console.log(t2); // Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间) 防抖节流12345678910111213141516171819202122232425262728293031323334353637383940414243444546/* 防抖节流 debounce throttle */// 防抖 - 连续快速触发的解决方案function debounce(fn, wait) &#123; let timeout = null; // 初始化 timer 定时器 return function ()&#123; timeout &amp;&amp; clearTimeout(timeout); // 清空定时器 timeout = setTimeout(fn, wait); // 设置定时器 &#125;&#125;// 节流 - 一定时间内请求一次 -- 定时器法function throttle1(fn, wait) &#123; let timer = null; // 初始化 timer 定时器 return function () &#123; let context = this; // 保存上下文 this let args = arguments; // 记录参数 if(!timer) &#123; // 定时器为空 timer = setTimeout(() =&gt; &#123; fn.apply(context, args); timer = null; // 清空定时器 &#125;, wait); &#125; &#125;&#125;// 节流 - 一定时间内请求一次 -- 时间戳法function throttle2(fn, wait) &#123; let prev = Date.now(); // 记录前一个时间 return function () &#123; let context = this; // 保存上下文 this let args = arguments; // 记录参数 let now = Date.now(); // 记录当前时间 if(now - prev &gt;= wait)&#123; // 时间戳大于设置的时间 fn.apply(context, args); prev = Date.now(); // 记录前一个时间 &#125; &#125;&#125;// window.addEventListener(&apos;scroll&apos;, debounce(() =&gt; &#123; // console.log(Math.random());// &#125;, 500));// window.addEventListener(&apos;scroll&apos;, throttle1(() =&gt; &#123;// console.log(Math.random());// &#125;, 1000));window.addEventListener(&apos;scroll&apos;, throttle2(() =&gt; &#123; console.log(Math.random());&#125;, 1000)) JSON.stringfy(obj, [replace, space]) 巧用第二个参数，可以实现json对象的过滤替换。 第三个参数，是缩进的空格数。 如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。1234567891011121314151617181920212223242526let obj1 = &#123; name: &apos;zero&apos;, age: 22, hobby: &apos;ball&apos;&#125;;let str1 = JSON.stringify(obj1);console.log(str1, typeof str1, str1.constructor === String); // &#123;&quot;name&quot;:&quot;zero&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;&#125; string truelet str2 = JSON.stringify(obj1, (key, value) =&gt; &#123; if(value === &apos;zero&apos;) &#123; return &apos;Ertsul.&apos; &#125;else &#123; return value; &#125;&#125;);console.log(str2); // &#123;&quot;name&quot;:&quot;Ertsul.&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;&#125;let obj2 = &#123; num: 100, toJSON()&#123; return &apos;apple&apos; &#125;&#125;;let str3 = JSON.stringify(obj2);console.log(str3); // apple 数组的 sort()sort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。如果要对数组的数字进行排序，则需要： array.sort((val1, val2) =&gt; {return val - val2}); 通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。 12345let arr10 = [1, 2, 19, 12, 22];console.log(arr10.sort()); // [1, 12, 19, 2, 22]console.log(arr10.sort((val1, val2) =&gt; &#123; // [1, 2, 12, 19, 22] return val1 - val2;&#125;)); reduce函数 reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。 其完整的函数为： 123arr.reduce((prev, next, cur, srcArr) =&gt; &#123; ......&#125;, initVal) prev: 上次返回的值 next: 下一个数组元素的值 cur: 当前数组元素的索引值 scrArr: 源数组 initVal: 设置第一次的 prev 例子 1：12345let arr = [&apos;apple&apos;, &apos;pear&apos;, &apos;bananas&apos;];arr.reduce((prev, next, cur, arr) =&gt; &#123; console.warn(prev, next, cur, arr); return next;&#125;, &apos;fruit&apos;) 例子 2：统计一个数组中单词出现的次数123456789// 统计数组中单词出现的次数let arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;bananas&quot;, &quot;bananas&quot;];function getCount(arr) &#123; return arr.reduce((prev, next, cur) =&gt; &#123; prev[next] = (prev[next] + 1) || 1 return prev; &#125;, &#123;&#125;)&#125;console.warn(getCount(arr)); // &#123;apple: 2, orange: 3, pear: 1, bananas: 2&#125; Object.seal()防止对象纂改：不能添加也不能删除属性 12345678let obj = &#123; name: &apos;Ersul&apos;&#125;Object.seal(obj); // 防止对象纂改：不能删除也不能添加属性delete obj.name;console.warn(obj.name); // Ertsulobj.age = 22;console.warn(obj.age); // undefined Object.freeze()冻结对象，不能修改对象任何属性的值。如若 1234567let obj = &#123; name: &apos;Ersul&apos;&#125;Object.freeze(obj); // 冻结对象，不能修改属性的值obj.name = &apos;Zero&apos;;console.warn(obj.name); // Ertsul 数组字符串的相互转化123456// 数组 --&gt; 字符串 : join()let arr3 = [1, 2, 3, 4, 5];console.log(arr3.join(&apos;-&apos;));// 字符串 --&gt; 数组 : split()let str = &apos;apple,pear,bananas&apos;;console.log(str.split(&apos;,&apos;));","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"http://yoursite.com/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"http://yoursite.com/tags/js/"},{"name":"es6","slug":"es6","permalink":"http://yoursite.com/tags/es6/"}]},{"title":"webpack学习笔记","slug":"webpack学习笔记","date":"2019-02-16T15:20:58.000Z","updated":"2019-02-16T15:37:00.383Z","comments":true,"path":"2019/02/16/webpack学习笔记/","link":"","permalink":"http://yoursite.com/2019/02/16/webpack学习笔记/","excerpt":"","text":"项目构建 新建项目文件夹 npm init 设置项目目录结构，结构如下： build 目录是 webpack 打包后的生成目录，index.html 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。 src 目录是项目源文件，template.html 是 html 文件模板。 webpack.config.js 是配置 webpack 的总文件。 1module.exports = &#123; ... &#125; 模式 mode1mode: &quot;development&quot;, // development or production 入口 entry设置打包的入口文件, entry: filepath 1entry: &quot;./src/index.js&quot;, // 入口 输出 output设置打包后的输出文件，output: { … } 12345output: &#123; // 输出 filename: &quot;bundle.[hash:8].js&quot;, path: path.resolve(__dirname + &apos;/build&apos;), // publicPath: &quot;http://&quot;, // 公共路径前缀&#125;, 注： path 后面应是绝对路径。 bundle.[hash:8].js 中的 [hash:8] 可以在每次打包后都在文件后面追加 hash 值。 通过上面三项，可以实现一个简单的 webpack 打包配置。在 package.json 添加脚本或直接执行 ./node_modules/.bin/webpack 即可实现打包： 1&quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;, webpack-dev-serverwebpack 开发服务器，用于开发时候的配置： yarn add taco –dev webpack-dev-server / npm install –save-dev webpack-dev-server 基本配置如下： 12345678910111213141516171819202122devServer: &#123; // 开发服务器 port: 3001, contentBase: path.resolve(__dirname + &apos;/build&apos;), // 本地服务器目录 progress: true, // 进度条 open: true, // 自动打开浏览器 compress: true, // 压缩 // 1. 代理 proxy: &#123; &quot;/api&quot;: &#123; target: &quot;&quot;, pathRewrite: &#123; &quot;/api&quot;: &quot;&quot; &#125; &#125; &#125;, // 2. 用 express 内置钩子模拟数据 before(app) &#123; app.get(&quot;/api&quot;, (req, res) =&gt; &#123; ... &#125;) &#125;, // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件&#125;,&#125;, 在 package.json 添加脚本即可： 1&quot;dev&quot;: &quot;webpack-dev-server&quot; source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map作用：源码映射，报错时显示出错的位置。 source-map：会单独生成一个 sourcemap 文件；会显示行列。 eval-source-map：不会单独生成一个 sourcemap 文件，会将生成的 sourcemap 放到打包后的 html 文件；会显示行和列。 cheap-module-source-map：会生成 sourcemap 文件，不会显示列。 cheap-module-eval-source-map：不会生成 sourcemap 文件，集成在 html 文件中，不会显示列。 1devtool: &quot;source-map&quot;, // 源码映射 watch作用：监控代码实时变化，进行编译打包。 123456watch: true, // 监控代码实时变化，进行编译打包watchOptions: &#123; poll: 1000, // 多毫秒监控一次 aggreatement: 500, // 防抖 ignored: &quot;node_modules&quot; // 忽略文件夹&#125;, resolve作用：解析第三方包 123456789101112131415resolve: &#123; // 解析 第三方包 modules: [ path.resolve(&quot;node_modules&quot;), // 在当前目录下查找模块 path.resolve(&quot;other_modules&quot;), // 在其他目录下查找模块 ], // 自动添加扩展名，主要是 import 时候使用, 依次解析 extensions: [&quot;.js&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.vue&quot;], // 比如引用 bootstrap 的 css 样式 // 方式一： bootstrap 的主入口 mainFields: [&quot;style&quot;, &quot;main&quot;], // 方式二：别名 // alias: &#123; // bootstrap: &quot;bootstrap/dist/css/bootstrap.css&quot; // &#125;&#125;, 插件webpack 的插件配置是一个数组，里面存放着各种各样的插件。 123plugins: [ new pluginName(...)] html-webpack-plugin插件作用：打包时候自动根据 html 模板生成目标 html 文件，自动生成目标打包目录；另外，可配置 html 的相关打包配置，如：压缩，去双引号等。 123456789new HtmlWebpackPlugin(&#123; filename: &quot;index.html&quot;, // 目标文件名称 template: path.resolve(__dirname + &apos;/src/template.html&apos;), // 模板文件 minify: &#123; // 压缩配置 removeAttributeQuotes: true, // 去双引号 collapseWhitespace: true, // 不换行 &#125;, hash: true // 生成 hash 戳&#125;) mini-css-extract-plugin作用：将生成的 css样式 抽离成一个 css文件，并将该样式文件引进目标 html 文件中。 1234567891011121314151617181920plugins: [ // 插件 new MiniCssExtractPlugin(&#123; filename: &quot;main.css&quot;, &#125;)],module: &#123; // 模块 rules: [&#123; test: /\\.css$/, use: [ // &#123; // loader: &quot;style-loader&quot;, // options: &#123; // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // &#125; // &#125;, MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序 &quot;css-loader&quot; ] &#125;]&#125; 注：这里抽离出来的 main.css 文件并没有压缩，要通过手动添加以下两个插件到优化项： optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin 123456789optimization: &#123; // 优化项 minimizer: [ new OptimizeCssAssetsWebpackPlugin(&#123;&#125;), // 压缩抽离的 css 文件 new UglifyjsWebpackPlugin(&#123; cache: true, parallel: true, &#125;) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置 ]&#125;, optimize-css-assets-webpack-plugin插件作用：压缩抽离出来的 main.css 文件。但是，使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 uglifyjs-webpack-plugin 。 uglifyjs-webpack-plugin插件作用：压缩打包后的 js 文件。 clean-webpack-plugin作用：清理文件 123plugins: [ new CleanWebpackPlugin(&quot;./build&quot;)] copy-webpack-plugin作用：将某些文件拷贝到打包后的文件夹。 123new CopyWebpackPlugin([ &#123;from: &quot;./copy&quot;, to: &quot;./&quot;&#125;]) banner-plugin作用：版权声明，是 webpack 的内置模块。 1new webpack.BannerPlugin(&quot;@copyright by Ertsul&quot;) webpack.DefinePlugin({ … })作用：定义环境变量。 123456plugins: [ new webpack.DefinePlugin(&#123; DEV: JSON.stringify(&quot;development&quot;), PRO: JSON.stringify(&quot;production&quot;) &#125;)] webpacfk.IgnorePlugin()作用：忽略模块的引进 123plugins: [ new webpack.IgnorePlugin(/\\./locale/, /moment/)] 注：如果直接使用 DEV: ‘development’ 的话，会把 DEV 直接替换为 引号内部的内容。如：console.log(DEV)，会变成 console.log(dev)，最后的结果是 undefined。所以，需要通过 JSON.stringfy() 进行转化。 模块 module模块主要是各种 loader，作用：解析各种类型的文件。 12345678module: &#123; rules: [ &#123; test: regx, use: [loadName] &#125; ]&#125; css-loader / style-loader css-loader：主要是用于解析在 css 文件中通过 @import 方式引进其他的 css 文件。 style-loader: 主要是用于将 js 文件中通过 require 方式引进的 css 文件插入到目标 html 文件的 head 中（插到最后，层级最高）。 12345678910111213141516171819202122// 数组方式module: &#123; // 模块 rules: [&#123; test: /\\.css$/, // 正则 use: [&quot;style-loader&quot;, &quot;css-loader&quot;] // loader 数组 &#125;]&#125;// 对象方式module: &#123; // 模块 rules: [&#123; test: /\\.css$/, // 正则 use: [ &#123; loader: &quot;style-loader&quot;, options: &#123; insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 &#125; &#125;, &quot;css-loader&quot; ] &#125;]&#125; 注：loader 是从右向左、从下到上的执行顺序，故：use: [“style-loader”, “css-loader”] postcss-loader + autoprefixer这两个的配合使用可以自动添加 css 的浏览器前缀。 autoprefixer：自动添加 css 的浏览器前缀。 postcss-loader：loader 处理 autoprefixer。 1234567891011121314151617// 使用 postcss-loader module: &#123; // 模块 rules: [&#123; test: /\\.css$/, use: [ // &#123; // loader: &quot;style-loader&quot;, // options: &#123; // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // &#125; // &#125;, MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;postcss-loader&quot; // 注意顺序 ] &#125;]&#125; 根目录下新建 postcss.config.js 文件 12345module.exports = &#123; plugins: [ require(&quot;autoprefixer&quot;) ]&#125; babel-loader + @babel/core + @babel/preset-env作用：转化 es6 语法 1234567891011121314module: &#123; // 模块 rules: [&#123; test: /\\.js$/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; // 用 babel-loader 需要把 es6 转化为 es5 presets: [ &quot;@babel/preset-env&quot;, // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块 ], // plugins: [...] // 其他的小插件 &#125; &#125; &#125;]&#125; expose-loader作用：暴露全局的 loader，暴露到 window 上。 123456789101112// 一般情况import $ from &apos;jquery&apos;;console.log(window.$); // undefined// 内联 loader 方式import $ from &apos;expose-loader?$!jquery&apos;;console.log(window.$);// 其他方式：在每个模块中注入new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;&#125;)console.log($);console.log(window.$); // undefined file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader在 webpack 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。 file-loader：js 文件中通过 import 方式引进图片。 html-withimg-loader：html 文件中通过 scr 方式引进图片。 在 css 中使用图片，style-loader 已经做了处理。 url-loader：将图片转化为 base64 123456789101112131415161718module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: &#123; loader: &quot;url-loader&quot;, options: &#123; limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader // publicPath: &quot;http://&quot;, // 公共路径前缀 &#125; &#125; &#125;, &#123; test: /\\.html$/, use: [&quot;html-withimg-loader&quot;] &#125; ]&#125; ` 模块 module – noParse作用：不解析指定包的依赖关系。 123module: &#123; noParse: /jquery/&#125; 模块 module – exclude作用：排除 123module: &#123; exclude: /node_module/&#125; 模块 module – include作用：包含 123module: &#123; include: /src/&#125; 区分不同环境，实现开发和生产配置的分离将 webpack 的配置文件划分为以下文件： webpack.base.js：基本、共有的配置。 webpack.dev.js：开发配置。 webpack.prod.js：生产配置。 使用 webpack-merger 插件： 安装 webpack-merge 插件； 引进目标模块 1import &#123; smart &#125; from &quot;webpack-merge&quot;; 使用 12345const base = require(&quot;webpack.base.js);module.exports = smart(base, &#123; ...&#125;) webpack 自带优化 import 语法（生成环境），tree-shaking 自动删除没有用到的代码； es6 模块会把语法放到 default 上； 自动省略可以简化的代码； scope hosting，作用域提升。 webpack 懒加载 通过 import 实现（该语法内部由 jsonp 实现），返回的是一个 promise。 要在 babel-loader 中添加 @babel/plugin-syntax-dynamic-import 插件。 vue 和 react 的l懒加载都是这样实现的。 1234567891011121314151617181920212223242526/** 模拟点击加载 source.js 的内容*/// 1&#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos; ], plugins: [ &apos;@babel/plugin-syntax-dynamic-import&apos; ] &#125;,&#125;// 2let btn = document.createElement(&apos;button&apos;);btn.innerHTML = &apos;btn&apos;;btn.addEventListener(&apos;click&apos;, function () &#123; // 内部由 jsonp 实现动态加载文件 import(&apos;./source.js&apos;) .then(data =&gt; &#123; console.log(data); &#125;)&#125;)document.body.appendChild(btn); 点击按钮后结果如下： 热更新 / 热替换 / Hot Module Replacement / HMR热更新：页面只更新改动的模块。 devServer 开始 hot 热更新模块。 使用 webpack 内置热更新插件。 NamedModulesPlugin HotModuleReplacementPlugin 1234567891011121314// devServer 配置devServer: &#123; port: 8089, contentBase: path.resolve(__dirname + &apos;/dist/&apos;), compress: true, progress: true, // open: true hot: true, // 开启热更新，只更新更改的模块&#125;,// 添加插件plugins: [ new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径 new webpack.HotModuleReplacementPlugin(), // 热更新] 使用热更新 123456789import source from &apos;./source.js&apos;;console.log(source);// 添加热更新操作，不然不会实现热更新if (module.hot) &#123;module.hot.accept(&apos;./source.js&apos;, () =&gt; &#123; require(&apos;./source.js&apos;);&#125;) 多线程打包使用 happypack 可以实现多线程打包。 安装并引进 happypack; 改写 module; plugin 配置。 1234567891011121314151617181920212223242526272829303132333435// 改写 modulemodule: &#123; rules: [ &#123; test: /\\.js$/, // use: &#123; // loader: &apos;babel-loader&apos;, // options: &#123; // presets: [ // &apos;@babel/preset-env&apos; // ] // &#125; // &#125; use: &#123; loader: &apos;Happypack/loader?id=js&apos;, &#125; &#125;, ]&#125;// plugin 配置plugins: [ new Happypack(&#123; id: &apos;js&apos;, use: [ &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos; ] &#125; &#125; ] &#125;),] 多页面打包1234567891011121314151617181920212223242526272829303132const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; mode: &quot;production&quot;, entry: &#123; home: &quot;./src/home.js&quot;, about: &quot;./src/about.js&quot;, other: &quot;./src/other.js&quot; &#125;, output: &#123; path: path.resolve(__dirname + &quot;/build/&quot;), filename: &quot;[name].js&quot;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;home.html&quot;, chunks: [&quot;home&quot;] &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;other.html&quot;, chunks: [&quot;other&quot;] &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;about.html&quot;, chunks: [&quot;about&quot;] &#125;), ]&#125; 多页面打包抽离公共代码块打包 多页面 需要将公共的代码块抽离出来进行优化： 123456789101112131415161718optimation: &#123; splitChunks: &#123; // 分割代码块 cacheGroups: &#123; // 缓存组 common: &#123; // 公共的模块 chunks: &apos;initial&apos;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 &#125;, vender: &#123; // 第三方模块 priority: 1, // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用 test: /node_modules/, // 抽离出来 chunks: &apos;initial&apos;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 &#125; &#125; &#125;&#125; Tapablewebpack 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 Tapable，通过 Tapable 实现各种钩子（如同步钩子异步钩子）。而 Tapable 核心是依赖于 发布订阅者模式。 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tap 注册。 使用：1234567891011121314151617181920212223const &#123; SyncHook &#125; = require(&apos;tapable&apos;);class Hook &#123; constructor() &#123; this.hooks = &#123; arch: new SyncHook([&apos;name&apos;]) &#125; &#125; tap() &#123; // 注册监听事件 this.hooks.arch.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name); &#125;) this.hooks.arch.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name); &#125;) &#125; start() &#123; // 开始 this.hooks.arch.call(&apos;Ertsul&apos;) &#125;&#125;let h = new Hook();h.tap();h.start(); 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tapAsync 注册。 setTimeout()方式使用： 1234567891011121314151617181920212223242526272829303132const &#123; AsyncParallelHook &#125; = require(&apos;tapable&apos;);class AsyncHook &#123; constructor() &#123; this.hooks = &#123; arch: new AsyncParallelHook([&apos;name&apos;]) &#125; &#125; tap() &#123; this.hooks.arch.tapAsync(&apos;vue&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); cb &amp;&amp; cb(); &#125;, 1000) &#125;) this.hooks.arch.tapAsync(&apos;react&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); cb &amp;&amp; cb(); &#125;, 1000) &#125;) &#125; start() &#123; this.hooks.arch.callAsync(&apos;Ertsul&apos;, () =&gt; &#123; console.log(&apos;All finished!&apos;); &#125;) &#125;&#125;const a = new AsyncHook();a.tap();a.start(); Promise()方式使用：123456789101112131415161718192021222324252627282930313233343536const &#123; AsyncParallelHook &#125; = require(&apos;tapable&apos;);class AsyncHook &#123; constructor() &#123; this.hooks = &#123; arch: new AsyncParallelHook([&apos;name&apos;]) &#125; &#125; tap() &#123; this.hooks.arch.tapPromise(&apos;vue&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); resolve(); &#125;, 1000) &#125;) &#125;) this.hooks.arch.tapPromise(&apos;react&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); resolve(); &#125;, 1000) &#125;) &#125;) &#125; start() &#123; this.hooks.arch.promise(&apos;Ertsul&apos;).then(() =&gt; &#123; console.log(&apos;hook all finished!&apos;); &#125;) &#125;&#125;const a = new AsyncHook();a.tap();a.start(); Synchook 同步钩子实现：12345678910111213141516171819202122class Synchook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tap(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; call(...args) &#123; // 发布事件 this.tasks.forEach(task =&gt; &#123; task(...args); &#125;) &#125;&#125;let hook = new Synchook([&apos;Synchook&apos;]);hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name);&#125;)hook.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name);&#125;)hook.call(&apos;Ertsul&apos;); SyncBailHook 同步熔断钩子Synchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。 实现：12345678910111213141516171819202122232425// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数class Syncbailhook &#123; constructor(args) &#123; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; let ret = &apos;&apos;; // 当前函数的返回值 let index = 0; // 当前任务数组的索引 do &#123; ret = this.tasks[index++](...args); &#125; while (ret === undefined &amp;&amp; index &lt; this.tasks.length) &#125;&#125;let hook = new Syncbailhook([&apos;Syncbailhook&apos;]);hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name);&#125;)hook.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name);&#125;)hook.call(&apos;Ertsul&apos;); SyncWaterfallHook 同步瀑布钩子Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。 实现：1234567891011121314151617181920212223242526272829/** * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系 * 上一个函数的执行返回结果在当前函数的输入 */class Syncwaterfallhook &#123; constructor(args) &#123; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; let [first, ...others] = this.tasks; let ret = first(...args); others.reduce((prev, current) =&gt; &#123; return current(prev); &#125;, ret) &#125;&#125;let hook = new Syncwaterfallhook([&apos;Syncwaterfallhook&apos;]);hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name); return &apos;vue learnt&apos;;&#125;)hook.tap(&apos;react&apos;, (data) =&gt; &#123; console.log(&apos;react&apos;, data);&#125;)hook.call(&apos;Ertsul&apos;); SyncLoopHook 同步循环钩子同步循环钩子回让某个函数执行一定的次数。 实现：1234567891011121314151617181920212223242526272829// Tapable Syncloophook 同步循环钩子class Syncloophook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tap(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; call(...args) &#123; // 发布事件 this.tasks.forEach(task =&gt; &#123; let ret = &apos;&apos;; do &#123; ret = task(...args); &#125; while (ret != undefined); &#125;) &#125;&#125;let hook = new Syncloophook([&apos;Syncloophook&apos;]);const total = 3;let index = 0;hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name); return ++index === total ? undefined : &apos;continue&apos;;&#125;)hook.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name);&#125;)hook.call(&apos;Ertsul&apos;); AsyncParallelHook 异步并发钩子 回调函数方式实现：123456789101112131415161718192021222324252627282930313233343536373839// Tapable Asynchook 异步钩子class asyncparallelhook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tapAsync(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; callAsync(...args) &#123; // 发布事件 let finalCallback = args.pop(); let index = 0; const done = () =&gt; &#123; index++; if (index === this.tasks.length) &#123; finalCallback(); &#125; &#125; this.tasks.forEach(task =&gt; &#123; task(...args, done); &#125;) &#125;&#125;let hook = new asyncparallelhook([&apos;asyncparallelhook&apos;]);hook.tapAsync(&apos;vue&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); cb &amp;&amp; cb(); &#125;, 1000)&#125;)hook.tapAsync(&apos;react&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); cb &amp;&amp; cb(); &#125;, 1000)&#125;)hook.callAsync(&apos;Ertsul&apos;, () =&gt; &#123; console.log(&apos;All hook finished!&apos;);&#125;); AsyncParallelHook 异步并发钩子 Promise方式实现：12345678910111213141516171819202122232425262728293031323334// Tapable Asynchook 异步钩子class asyncparallelhook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tapPromise(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; promise(...args) &#123; // 发布事件 let tasks = this.tasks.map(task =&gt; task(...args)); return Promise.all(tasks); &#125;&#125;let hook = new asyncparallelhook([&apos;asyncparallelhook&apos;]);hook.tapPromise(&apos;vue&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); resolve(); &#125;, 1000) &#125;)&#125;)hook.tapPromise(&apos;react&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); resolve(); &#125;, 1000) &#125;)&#125;)hook.promise(&apos;Ertsul&apos;).then(() =&gt; &#123; console.log(&apos;All hooks finished!&apos;);&#125;) AsyncSeriesHook 异步串行钩子AsyncWaterfallHook 异步瀑布流钩子","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"http://yoursite.com/tags/frontEnd/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"hello-hexo","slug":"hello-hexo","date":"2019-02-16T15:15:09.000Z","updated":"2019-02-16T15:39:13.780Z","comments":true,"path":"2019/02/16/hello-hexo/","link":"","permalink":"http://yoursite.com/2019/02/16/hello-hexo/","excerpt":"","text":"Hello Hexo决定把简书的文章转移到 hexo 上。","categories":[],"tags":[]}]}