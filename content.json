{"meta":{"title":"Ertsul","subtitle":null,"description":"Ertsul's Blog","author":"Ertsul","url":"http://yoursite.com"},"pages":[{"title":"about","date":"2019-02-16T14:42:19.000Z","updated":"2019-02-16T15:13:21.129Z","comments":true,"path":"about/index.html","permalink":"http://yoursite.com/about/index.html","excerpt":"","text":"Stay Hungry, stay foolish."}],"posts":[{"title":"webpack学习笔记","slug":"webpack学习笔记","date":"2019-02-16T15:20:58.000Z","updated":"2019-02-16T15:28:58.244Z","comments":true,"path":"2019/02/16/webpack学习笔记/","link":"","permalink":"http://yoursite.com/2019/02/16/webpack学习笔记/","excerpt":"","text":"项目构建 新建项目文件夹 npm init 设置项目目录结构，结构如下：{:width=”150px” height=”200px” } build 目录是 webpack 打包后的生成目录，index.html 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。 src 目录是项目源文件，template.html 是 html 文件模板。 webpack.config.js 是配置 webpack 的总文件。 1module.exports = &#123; ... &#125; 模式 mode1mode: &quot;development&quot;, // development or production 入口 entry设置打包的入口文件, entry: filepath 1entry: &quot;./src/index.js&quot;, // 入口 输出 output设置打包后的输出文件，output: { … } 12345output: &#123; // 输出 filename: &quot;bundle.[hash:8].js&quot;, path: path.resolve(__dirname + &apos;/build&apos;), // publicPath: &quot;http://&quot;, // 公共路径前缀&#125;, 注： path 后面应是绝对路径。 bundle.[hash:8].js 中的 [hash:8] 可以在每次打包后都在文件后面追加 hash 值。 通过上面三项，可以实现一个简单的 webpack 打包配置。在 package.json 添加脚本或直接执行 ./node_modules/.bin/webpack 即可实现打包： 1&quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;, webpack-dev-serverwebpack 开发服务器，用于开发时候的配置： yarn add taco –dev webpack-dev-server / npm install –save-dev webpack-dev-server 基本配置如下： 12345678910111213141516171819202122devServer: &#123; // 开发服务器 port: 3001, contentBase: path.resolve(__dirname + &apos;/build&apos;), // 本地服务器目录 progress: true, // 进度条 open: true, // 自动打开浏览器 compress: true, // 压缩 // 1. 代理 proxy: &#123; &quot;/api&quot;: &#123; target: &quot;&quot;, pathRewrite: &#123; &quot;/api&quot;: &quot;&quot; &#125; &#125; &#125;, // 2. 用 express 内置钩子模拟数据 before(app) &#123; app.get(&quot;/api&quot;, (req, res) =&gt; &#123; ... &#125;) &#125;, // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件&#125;,&#125;, 在 package.json 添加脚本即可： 1&quot;dev&quot;: &quot;webpack-dev-server&quot; source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map作用：源码映射，报错时显示出错的位置。 source-map：会单独生成一个 sourcemap 文件；会显示行列。 eval-source-map：不会单独生成一个 sourcemap 文件，会将生成的 sourcemap 放到打包后的 html 文件；会显示行和列。 cheap-module-source-map：会生成 sourcemap 文件，不会显示列。 cheap-module-eval-source-map：不会生成 sourcemap 文件，集成在 html 文件中，不会显示列。 1devtool: &quot;source-map&quot;, // 源码映射 watch作用：监控代码实时变化，进行编译打包。 123456watch: true, // 监控代码实时变化，进行编译打包watchOptions: &#123; poll: 1000, // 多毫秒监控一次 aggreatement: 500, // 防抖 ignored: &quot;node_modules&quot; // 忽略文件夹&#125;, resolve作用：解析第三方包 123456789101112131415resolve: &#123; // 解析 第三方包 modules: [ path.resolve(&quot;node_modules&quot;), // 在当前目录下查找模块 path.resolve(&quot;other_modules&quot;), // 在其他目录下查找模块 ], // 自动添加扩展名，主要是 import 时候使用, 依次解析 extensions: [&quot;.js&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.vue&quot;], // 比如引用 bootstrap 的 css 样式 // 方式一： bootstrap 的主入口 mainFields: [&quot;style&quot;, &quot;main&quot;], // 方式二：别名 // alias: &#123; // bootstrap: &quot;bootstrap/dist/css/bootstrap.css&quot; // &#125;&#125;, 插件webpack 的插件配置是一个数组，里面存放着各种各样的插件。 123plugins: [ new pluginName(...)] html-webpack-plugin插件作用：打包时候自动根据 html 模板生成目标 html 文件，自动生成目标打包目录；另外，可配置 html 的相关打包配置，如：压缩，去双引号等。 123456789new HtmlWebpackPlugin(&#123; filename: &quot;index.html&quot;, // 目标文件名称 template: path.resolve(__dirname + &apos;/src/template.html&apos;), // 模板文件 minify: &#123; // 压缩配置 removeAttributeQuotes: true, // 去双引号 collapseWhitespace: true, // 不换行 &#125;, hash: true // 生成 hash 戳&#125;) mini-css-extract-plugin作用：将生成的 css样式 抽离成一个 css文件，并将该样式文件引进目标 html 文件中。 1234567891011121314151617181920plugins: [ // 插件 new MiniCssExtractPlugin(&#123; filename: &quot;main.css&quot;, &#125;)],module: &#123; // 模块 rules: [&#123; test: /\\.css$/, use: [ // &#123; // loader: &quot;style-loader&quot;, // options: &#123; // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // &#125; // &#125;, MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序 &quot;css-loader&quot; ] &#125;]&#125; 注：这里抽离出来的 main.css 文件并没有压缩，要通过手动添加以下两个插件到优化项： optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin 123456789optimization: &#123; // 优化项 minimizer: [ new OptimizeCssAssetsWebpackPlugin(&#123;&#125;), // 压缩抽离的 css 文件 new UglifyjsWebpackPlugin(&#123; cache: true, parallel: true, &#125;) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置 ]&#125;, optimize-css-assets-webpack-plugin插件作用：压缩抽离出来的 main.css 文件。但是，使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 uglifyjs-webpack-plugin 。 uglifyjs-webpack-plugin插件作用：压缩打包后的 js 文件。 clean-webpack-plugin作用：清理文件 123plugins: [ new CleanWebpackPlugin(&quot;./build&quot;)] copy-webpack-plugin作用：将某些文件拷贝到打包后的文件夹。 123new CopyWebpackPlugin([ &#123;from: &quot;./copy&quot;, to: &quot;./&quot;&#125;]) banner-plugin作用：版权声明，是 webpack 的内置模块。 1new webpack.BannerPlugin(&quot;@copyright by Ertsul&quot;) webpack.DefinePlugin({ … })作用：定义环境变量。 123456plugins: [ new webpack.DefinePlugin(&#123; DEV: JSON.stringify(&quot;development&quot;), PRO: JSON.stringify(&quot;production&quot;) &#125;)] webpacfk.IgnorePlugin()作用：忽略模块的引进 123plugins: [ new webpack.IgnorePlugin(/\\./locale/, /moment/)] 注：如果直接使用 DEV: ‘development’ 的话，会把 DEV 直接替换为 引号内部的内容。如：console.log(DEV)，会变成 console.log(dev)，最后的结果是 undefined。所以，需要通过 JSON.stringfy() 进行转化。 模块 module模块主要是各种 loader，作用：解析各种类型的文件。 12345678module: &#123; rules: [ &#123; test: regx, use: [loadName] &#125; ]&#125; css-loader / style-loader css-loader：主要是用于解析在 css 文件中通过 @import 方式引进其他的 css 文件。 style-loader: 主要是用于将 js 文件中通过 require 方式引进的 css 文件插入到目标 html 文件的 head 中（插到最后，层级最高）。 12345678910111213141516171819202122// 数组方式module: &#123; // 模块 rules: [&#123; test: /\\.css$/, // 正则 use: [&quot;style-loader&quot;, &quot;css-loader&quot;] // loader 数组 &#125;]&#125;// 对象方式module: &#123; // 模块 rules: [&#123; test: /\\.css$/, // 正则 use: [ &#123; loader: &quot;style-loader&quot;, options: &#123; insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 &#125; &#125;, &quot;css-loader&quot; ] &#125;]&#125; 注：loader 是从右向左、从下到上的执行顺序，故：use: [“style-loader”, “css-loader”] postcss-loader + autoprefixer这两个的配合使用可以自动添加 css 的浏览器前缀。 autoprefixer：自动添加 css 的浏览器前缀。 postcss-loader：loader 处理 autoprefixer。 1234567891011121314151617// 使用 postcss-loader module: &#123; // 模块 rules: [&#123; test: /\\.css$/, use: [ // &#123; // loader: &quot;style-loader&quot;, // options: &#123; // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // &#125; // &#125;, MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;postcss-loader&quot; // 注意顺序 ] &#125;]&#125; 根目录下新建 postcss.config.js 文件 12345module.exports = &#123; plugins: [ require(&quot;autoprefixer&quot;) ]&#125; babel-loader + @babel/core + @babel/preset-env作用：转化 es6 语法 1234567891011121314module: &#123; // 模块 rules: [&#123; test: /\\.js$/, use: &#123; loader: &quot;babel-loader&quot;, options: &#123; // 用 babel-loader 需要把 es6 转化为 es5 presets: [ &quot;@babel/preset-env&quot;, // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块 ], // plugins: [...] // 其他的小插件 &#125; &#125; &#125;]&#125; expose-loader作用：暴露全局的 loader，暴露到 window 上。 123456789101112// 一般情况import $ from &apos;jquery&apos;;console.log(window.$); // undefined// 内联 loader 方式import $ from &apos;expose-loader?$!jquery&apos;;console.log(window.$);// 其他方式：在每个模块中注入new webpack.ProvidePlugin(&#123; $: &quot;jquery&quot;&#125;)console.log($);console.log(window.$); // undefined file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader在 webpack 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。 file-loader：js 文件中通过 import 方式引进图片。 html-withimg-loader：html 文件中通过 scr 方式引进图片。 在 css 中使用图片，style-loader 已经做了处理。 url-loader：将图片转化为 base64 123456789101112131415161718module: &#123; rules: [ &#123; test: /\\.(png|jpg|gif)$/, use: &#123; loader: &quot;url-loader&quot;, options: &#123; limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader // publicPath: &quot;http://&quot;, // 公共路径前缀 &#125; &#125; &#125;, &#123; test: /\\.html$/, use: [&quot;html-withimg-loader&quot;] &#125; ]&#125; ` 模块 module – noParse作用：不解析指定包的依赖关系。 123module: &#123; noParse: /jquery/&#125; 模块 module – exclude作用：排除 123module: &#123; exclude: /node_module/&#125; 模块 module – include作用：包含 123module: &#123; include: /src/&#125; 区分不同环境，实现开发和生产配置的分离将 webpack 的配置文件划分为以下文件： webpack.base.js：基本、共有的配置。 webpack.dev.js：开发配置。 webpack.prod.js：生产配置。 使用 webpack-merger 插件： 安装 webpack-merge 插件； 引进目标模块 1import &#123; smart &#125; from &quot;webpack-merge&quot;; 使用 12345const base = require(&quot;webpack.base.js);module.exports = smart(base, &#123; ...&#125;) webpack 自带优化 import 语法（生成环境），tree-shaking 自动删除没有用到的代码； es6 模块会把语法放到 default 上； 自动省略可以简化的代码； scope hosting，作用域提升。 webpack 懒加载 通过 import 实现（该语法内部由 jsonp 实现），返回的是一个 promise。 要在 babel-loader 中添加 @babel/plugin-syntax-dynamic-import 插件。 vue 和 react 的l懒加载都是这样实现的。 1234567891011121314151617181920212223242526/** 模拟点击加载 source.js 的内容*/// 1&#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos; ], plugins: [ &apos;@babel/plugin-syntax-dynamic-import&apos; ] &#125;,&#125;// 2let btn = document.createElement(&apos;button&apos;);btn.innerHTML = &apos;btn&apos;;btn.addEventListener(&apos;click&apos;, function () &#123; // 内部由 jsonp 实现动态加载文件 import(&apos;./source.js&apos;) .then(data =&gt; &#123; console.log(data); &#125;)&#125;)document.body.appendChild(btn); 点击按钮后结果如下： 热更新 / 热替换 / Hot Module Replacement / HMR热更新：页面只更新改动的模块。 devServer 开始 hot 热更新模块。 使用 webpack 内置热更新插件。 NamedModulesPlugin HotModuleReplacementPlugin 1234567891011121314// devServer 配置devServer: &#123; port: 8089, contentBase: path.resolve(__dirname + &apos;/dist/&apos;), compress: true, progress: true, // open: true hot: true, // 开启热更新，只更新更改的模块&#125;,// 添加插件plugins: [ new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径 new webpack.HotModuleReplacementPlugin(), // 热更新] 使用热更新 123456789import source from &apos;./source.js&apos;;console.log(source);// 添加热更新操作，不然不会实现热更新if (module.hot) &#123;module.hot.accept(&apos;./source.js&apos;, () =&gt; &#123; require(&apos;./source.js&apos;);&#125;) 多线程打包使用 happypack 可以实现多线程打包。 安装并引进 happypack; 改写 module; plugin 配置。 1234567891011121314151617181920212223242526272829303132333435// 改写 modulemodule: &#123; rules: [ &#123; test: /\\.js$/, // use: &#123; // loader: &apos;babel-loader&apos;, // options: &#123; // presets: [ // &apos;@babel/preset-env&apos; // ] // &#125; // &#125; use: &#123; loader: &apos;Happypack/loader?id=js&apos;, &#125; &#125;, ]&#125;// plugin 配置plugins: [ new Happypack(&#123; id: &apos;js&apos;, use: [ &#123; loader: &apos;babel-loader&apos;, options: &#123; presets: [ &apos;@babel/preset-env&apos; ] &#125; &#125; ] &#125;),] 多页面打包1234567891011121314151617181920212223242526272829303132const path = require(&quot;path&quot;);const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;);module.exports = &#123; mode: &quot;production&quot;, entry: &#123; home: &quot;./src/home.js&quot;, about: &quot;./src/about.js&quot;, other: &quot;./src/other.js&quot; &#125;, output: &#123; path: path.resolve(__dirname + &quot;/build/&quot;), filename: &quot;[name].js&quot;, &#125;, plugins: [ new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;home.html&quot;, chunks: [&quot;home&quot;] &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;other.html&quot;, chunks: [&quot;other&quot;] &#125;), new HtmlWebpackPlugin(&#123; template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;about.html&quot;, chunks: [&quot;about&quot;] &#125;), ]&#125; 多页面打包抽离公共代码块打包 多页面 需要将公共的代码块抽离出来进行优化： 123456789101112131415161718optimation: &#123; splitChunks: &#123; // 分割代码块 cacheGroups: &#123; // 缓存组 common: &#123; // 公共的模块 chunks: &apos;initial&apos;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 &#125;, vender: &#123; // 第三方模块 priority: 1, // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用 test: /node_modules/, // 抽离出来 chunks: &apos;initial&apos;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 &#125; &#125; &#125;&#125; Tapablewebpack 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 Tapable，通过 Tapable 实现各种钩子（如同步钩子异步钩子）。而 Tapable 核心是依赖于 发布订阅者模式。 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tap 注册。 使用：1234567891011121314151617181920212223const &#123; SyncHook &#125; = require(&apos;tapable&apos;);class Hook &#123; constructor() &#123; this.hooks = &#123; arch: new SyncHook([&apos;name&apos;]) &#125; &#125; tap() &#123; // 注册监听事件 this.hooks.arch.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name); &#125;) this.hooks.arch.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name); &#125;) &#125; start() &#123; // 开始 this.hooks.arch.call(&apos;Ertsul&apos;) &#125;&#125;let h = new Hook();h.tap();h.start(); 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tapAsync 注册。 setTimeout()方式使用： 1234567891011121314151617181920212223242526272829303132const &#123; AsyncParallelHook &#125; = require(&apos;tapable&apos;);class AsyncHook &#123; constructor() &#123; this.hooks = &#123; arch: new AsyncParallelHook([&apos;name&apos;]) &#125; &#125; tap() &#123; this.hooks.arch.tapAsync(&apos;vue&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); cb &amp;&amp; cb(); &#125;, 1000) &#125;) this.hooks.arch.tapAsync(&apos;react&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); cb &amp;&amp; cb(); &#125;, 1000) &#125;) &#125; start() &#123; this.hooks.arch.callAsync(&apos;Ertsul&apos;, () =&gt; &#123; console.log(&apos;All finished!&apos;); &#125;) &#125;&#125;const a = new AsyncHook();a.tap();a.start(); Promise()方式使用：123456789101112131415161718192021222324252627282930313233343536const &#123; AsyncParallelHook &#125; = require(&apos;tapable&apos;);class AsyncHook &#123; constructor() &#123; this.hooks = &#123; arch: new AsyncParallelHook([&apos;name&apos;]) &#125; &#125; tap() &#123; this.hooks.arch.tapPromise(&apos;vue&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); resolve(); &#125;, 1000) &#125;) &#125;) this.hooks.arch.tapPromise(&apos;react&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); resolve(); &#125;, 1000) &#125;) &#125;) &#125; start() &#123; this.hooks.arch.promise(&apos;Ertsul&apos;).then(() =&gt; &#123; console.log(&apos;hook all finished!&apos;); &#125;) &#125;&#125;const a = new AsyncHook();a.tap();a.start(); Synchook 同步钩子实现：12345678910111213141516171819202122class Synchook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tap(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; call(...args) &#123; // 发布事件 this.tasks.forEach(task =&gt; &#123; task(...args); &#125;) &#125;&#125;let hook = new Synchook([&apos;Synchook&apos;]);hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name);&#125;)hook.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name);&#125;)hook.call(&apos;Ertsul&apos;); SyncBailHook 同步熔断钩子Synchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。 实现：12345678910111213141516171819202122232425// Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数class Syncbailhook &#123; constructor(args) &#123; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; let ret = &apos;&apos;; // 当前函数的返回值 let index = 0; // 当前任务数组的索引 do &#123; ret = this.tasks[index++](...args); &#125; while (ret === undefined &amp;&amp; index &lt; this.tasks.length) &#125;&#125;let hook = new Syncbailhook([&apos;Syncbailhook&apos;]);hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name);&#125;)hook.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name);&#125;)hook.call(&apos;Ertsul&apos;); SyncWaterfallHook 同步瀑布钩子Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。 实现：1234567891011121314151617181920212223242526272829/** * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系 * 上一个函数的执行返回结果在当前函数的输入 */class Syncwaterfallhook &#123; constructor(args) &#123; this.tasks = []; &#125; tap(name, task) &#123; this.tasks.push(task); &#125; call(...args) &#123; let [first, ...others] = this.tasks; let ret = first(...args); others.reduce((prev, current) =&gt; &#123; return current(prev); &#125;, ret) &#125;&#125;let hook = new Syncwaterfallhook([&apos;Syncwaterfallhook&apos;]);hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name); return &apos;vue learnt&apos;;&#125;)hook.tap(&apos;react&apos;, (data) =&gt; &#123; console.log(&apos;react&apos;, data);&#125;)hook.call(&apos;Ertsul&apos;); SyncLoopHook 同步循环钩子同步循环钩子回让某个函数执行一定的次数。 实现：1234567891011121314151617181920212223242526272829// Tapable Syncloophook 同步循环钩子class Syncloophook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tap(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; call(...args) &#123; // 发布事件 this.tasks.forEach(task =&gt; &#123; let ret = &apos;&apos;; do &#123; ret = task(...args); &#125; while (ret != undefined); &#125;) &#125;&#125;let hook = new Syncloophook([&apos;Syncloophook&apos;]);const total = 3;let index = 0;hook.tap(&apos;vue&apos;, (name) =&gt; &#123; console.log(&apos;vue&apos;, name); return ++index === total ? undefined : &apos;continue&apos;;&#125;)hook.tap(&apos;react&apos;, (name) =&gt; &#123; console.log(&apos;react&apos;, name);&#125;)hook.call(&apos;Ertsul&apos;); AsyncParallelHook 异步并发钩子 回调函数方式实现：123456789101112131415161718192021222324252627282930313233343536373839// Tapable Asynchook 异步钩子class asyncparallelhook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tapAsync(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; callAsync(...args) &#123; // 发布事件 let finalCallback = args.pop(); let index = 0; const done = () =&gt; &#123; index++; if (index === this.tasks.length) &#123; finalCallback(); &#125; &#125; this.tasks.forEach(task =&gt; &#123; task(...args, done); &#125;) &#125;&#125;let hook = new asyncparallelhook([&apos;asyncparallelhook&apos;]);hook.tapAsync(&apos;vue&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); cb &amp;&amp; cb(); &#125;, 1000)&#125;)hook.tapAsync(&apos;react&apos;, (name, cb) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); cb &amp;&amp; cb(); &#125;, 1000)&#125;)hook.callAsync(&apos;Ertsul&apos;, () =&gt; &#123; console.log(&apos;All hook finished!&apos;);&#125;); AsyncParallelHook 异步并发钩子 Promise方式实现：12345678910111213141516171819202122232425262728293031323334// Tapable Asynchook 异步钩子class asyncparallelhook &#123; constructor(args) &#123; // args =&gt; [&apos;Synchook&apos;] this.tasks = []; // 注册事件数组 &#125; tapPromise(name, task) &#123; // 注册事件 this.tasks.push(task); &#125; promise(...args) &#123; // 发布事件 let tasks = this.tasks.map(task =&gt; task(...args)); return Promise.all(tasks); &#125;&#125;let hook = new asyncparallelhook([&apos;asyncparallelhook&apos;]);hook.tapPromise(&apos;vue&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;vue&apos;, name); resolve(); &#125;, 1000) &#125;)&#125;)hook.tapPromise(&apos;react&apos;, (name) =&gt; &#123; return new Promise((resolve, reject) =&gt; &#123; setTimeout(() =&gt; &#123; console.log(&apos;react&apos;, name); resolve(); &#125;, 1000) &#125;)&#125;)hook.promise(&apos;Ertsul&apos;).then(() =&gt; &#123; console.log(&apos;All hooks finished!&apos;);&#125;) AsyncSeriesHook 异步串行钩子AsyncWaterfallHook 异步瀑布流钩子","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"http://yoursite.com/tags/frontEnd/"},{"name":"webpack","slug":"webpack","permalink":"http://yoursite.com/tags/webpack/"}]},{"title":"hello-hexo","slug":"hello-hexo","date":"2019-02-16T15:15:09.000Z","updated":"2019-02-16T15:15:33.035Z","comments":true,"path":"2019/02/16/hello-hexo/","link":"","permalink":"http://yoursite.com/2019/02/16/hello-hexo/","excerpt":"","text":"Hello Hexo","categories":[],"tags":[]}]}