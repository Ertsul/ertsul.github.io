{"meta":{"title":"Ertsul","subtitle":"","description":"Ertsul's Blog","author":"Ertsul","url":"https://ertsul.github.io"},"pages":[{"title":"分类","date":"2014-12-22T04:39:04.000Z","updated":"2019-11-11T15:17:06.936Z","comments":true,"path":"categories/index.html","permalink":"https://ertsul.github.io/categories/index.html","excerpt":"","text":""},{"title":"about","date":"2019-02-16T14:42:19.000Z","updated":"2019-02-16T15:13:21.129Z","comments":true,"path":"about/index.html","permalink":"https://ertsul.github.io/about/index.html","excerpt":"","text":"Stay Hungry, stay foolish."},{"title":"标签","date":"2019-11-11T15:20:47.000Z","updated":"2019-11-11T15:32:45.298Z","comments":true,"path":"tags/index.html","permalink":"https://ertsul.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"可视化搭建平台（三）- 打包","slug":"可视化搭建平台（三）-打包","date":"2021-03-28T08:59:23.000Z","updated":"2021-03-28T09:09:22.417Z","comments":true,"path":"2021/03/28/可视化搭建平台（三）-打包/","link":"","permalink":"https://ertsul.github.io/2021/03/28/可视化搭建平台（三）-打包/","excerpt":"","text":"通过生成的 jsonData，可以拿到页面的基本信息 pageInfo，如：背景色、title等，还有页面布局 layout。主要处理两个问题： 通过 jsonData 数据实现页面渲染； 打包生成 html。 打包目录结构└───build 目录：主要存放 webpack 相关配置 | └───static.js // 封装 webpack.run() 方法 | └───webpack.base.config.js // webpack 基本配置 |───src | └───App.vue // server 端入口 | └───main.js // client 端入口 | └──index.tpl.html // 页面模板 | └───components.js // 组件引进注册 |───create-html | └───待页面名称 目录 | └───config.js // webpack 发布相关配置 | └───data.js // jsonData 获取相关逻辑 |───html 目录：打包输出 | └───static 目录：静态资源目录 | └───... | └──待页面名称.html // 输出的页面 |───index.js // 打包入口文件 打包相关webpack 公共基本配置 - webpack.base.config.js用到的 webpack 插件有：vue-loader、optimize-css-assets-webpack-plugin、html-webpack-plugin、html-webpack-inline-source-plugin、ptimize-css-assets-webpack-plugin、babel-loader等。 常规的 webpack 配置跳过，说下 plugins 配置： plugins(type) { const common = [ new VueLoaderPlugin(), new MiniCssExtractPlugin({ filename: &#39;[name].[contenthash:6].css&#39;, chunkFilename: &#39;[id].[contenthash:6].css&#39;, }), new OptimizeCssAssetsWebpackPlugin(), ] const onDemand = { server: [], client: [ new HtmlWebpackPlugin({ filename: &#39;index.template.html&#39;, template: path.resolve(__dirname, &#39;../src/index.tpl.html&#39;), inlineSource: &#39;.css$&#39;, minify: { collapseWhitespace: true, }, }), new OptimizeCSSAssetsPlugin({}), new HtmlWebpackInlineSourcePlugin(), ], } return [].concat(common).concat(onDemand[type] || []) }, 这通过传入 type 类型判断，判断是 client 端还是 server 端。公共需要的是 vue-loader，但 client 需要的是 html-webpack-plugin。 client webpack 配置除了 webpack.base.config.js 公共配置，client 的 webpack 需要配置的有：entry、output、端判断变量等。 const clientWebpackConfig = { ...webpackBaseConfig, mode, entry: path.resolve(__dirname, &#39;./src/main.js&#39;), output: { path: path.resolve(__dirname, &#39;.&#39;, publishConfig.outputPath), filename: &#39;[name].[contenthash:8].js&#39;, publicPath: publishConfig.publicPath, }, plugins: [ ...webpackBaseConfig.plugins(&#39;client&#39;), new webpack.DefinePlugin({ &#39;process.env&#39;: JSON.stringify({ IS_SERVER: false, }), }), ], } server webpack 配置除了 webpack.base.config.js 公共配置，server 的 webpack 需要配置的有：entry、output、端判断变量等。 const serverWebpackConfig = { ...webpackBaseConfig, mode, entry: { app: path.resolve(__dirname, &#39;./src/App.vue&#39;), }, output: { path: path.resolve(__dirname, &#39;.&#39;, publishConfig.outputPath), libraryTarget: &#39;commonjs&#39;, publicPath: publishConfig.publicPath, }, plugins: [ ...webpackBaseConfig.plugins(&#39;server&#39;), new webpack.DefinePlugin({ &#39;process.env&#39;: JSON.stringify({ IS_SERVER: true, }), }), ], } static.js - webpack.run 封装这里封装要给 Static 类，输入 webpack 配置，输出打包好的 bundle。 const webpack = require(&#39;webpack&#39;) class Static { constructor(options) { this.options = options } run() { const webpacks = [] Object.keys(this.options).forEach((k) =&gt; { webpacks.push(webpack(this.options[k])) }) return Promise.all( webpacks.map( (web) =&gt; new Promise((reslove) =&gt; { web.run((err, stats) =&gt; { reslove() }) }) ) ) } } module.exports = { Static, } server 入口 - 渲染生成页面通过封装一个入口组件 App.vue，将 jsonData 通过 props 传入，然后通过 js 引进相关的渲染组件，最后通过 v-for 配合动态组件&lt;component :is=&quot;&quot; /&gt;可以实现 组件渲染。 &lt;template&gt; &lt;div class=&quot;h5-page&quot; :style=&quot;pageStyle&quot;&gt; &lt;div class=&quot;layout-item&quot; v-for=&quot;(item, index) in layout&quot; :key=&quot;index&quot;&gt; &lt;component :is=&quot;item.component&quot; :dynamicStyle=&quot;item.config&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import components from &quot;./components.js&quot;; export default { name: &quot;H5Page&quot;, components: components, props: { pageConfig: { type: Object, default: () =&gt; [], }, }, data() { return { layout: [], }; }, computed: { pageStyle() { return { backgroundColor: this.$props.pageConfig.pageInfo.backgroundColor || &quot;#fff&quot;, }; }, }, created() { this.bindComponent(); }, methods: { /** * 给每个布局绑定唯一组件 */ bindComponent() { if (!Object.keys(components).length) { return; } // 给 layout 绑定对应组件 const layout = this.$props.pageConfig.layout || []; if (!layout.length) { return; } layout.forEach((item) =&gt; { item.component = components[item.type]; }); this.layout = layout; }, }, }; &lt;/script&gt; &lt;style lang=&quot;scss&quot;&gt; .h5-page { width: 100vw; } &lt;/style&gt; 这里将组件注入单独抽离，后期有新的组件使用，改动 components.js 即可。 /************************ 组件注册 ************************/ if (!process.env.IS_SERVER) { // 解决：UnhandledPromiseRejectionWarning: ReferenceError: window is not defined 问题 const H5Editor = require(&#39;h5-editor&#39;) module.exports = { EdText: H5Editor.default.EdText, EdImage: H5Editor.default.EdImage } } 注意：上面有一个全局变量（通过 webpack.DefinePlugin 插件注入变量）判断是服务端还是客户端的判断，因为打包使用的是vue-server-renderer相关逻辑。故：存在两个端，client 和 server，server 端没有 window、document 等对象。 client 入口 - 注入全局数据 window.__initData__主要做两件事： 挂载 Vue 实例到目标节点； 注入全局 window.__ininData__ import Vue from &#39;vue&#39; import App from &#39;./App.vue&#39; let props = {} if (window.__initData__) { props = { pageConfig: window.__initData__.pageConfig } } new Vue({ components: { App: App }, render: (h) =&gt; h(&#39;App&#39;, { props }), }).$mount(&#39;#app&#39;) 页面 html 模板&lt;!DOCTYPE html&gt; &lt;html style=&quot;font-size:100px;&quot;&gt; &lt;head&gt; &lt;title&gt;{{ title }}&lt;/title&gt; &lt;meta charset=&quot;utf-8&quot;&gt; &lt;meta http-equiv=&quot;X-UA-Compatible&quot; content=&quot;IE=edge&quot;&gt; &lt;meta name=&quot;viewport&quot; content=&quot;width=device-width,initial-scale=1.0,initial-scale=1.0,maximum-scale=1.0,user-scalable=no,minimal-ui&quot;&gt; &lt;meta name=&quot;description&quot; content=&quot;{{description}}&quot; /&gt; &lt;/head&gt; &lt;body style=&quot;font-size: 16px&quot;&gt; &lt;div id=&quot;app&quot;&gt; &lt;!--vue-ssr-outlet--&gt; &lt;/div&gt; &lt;script&gt; {{{ script }}} &lt;/script&gt; &lt;/body&gt; &lt;/html&gt; index.js - 构建打包使用的是vue-server-renderer相关逻辑。 主要做几件事： 通过 webpack 打包输出 templateHtml 和 bundle.js（还没有注入页面数据 window.__initData__） const compiler = new Static({ app: appWebpackConfig, client: clientWebpackConfig, }) await compiler.run() 通过 vue-server-renderer结合 templateHtml 和 bundle.js 生成 renderer 对象 const renderer = require(&#39;vue-server-renderer&#39;).createRenderer({ template: fs.readFileSync(&#39;./html/static/index.template.html&#39;, &#39;utf-8&#39;), }) const main = require(path.resolve( __dirname, `./${publishConfig.outputPath}/app.js` )) 通过 /create-html/待打包页面名/data.js脚本获取 jsonData 数据 将 jsonData 相关数据通过 context，注入到模板页面中 const pageConfigData = await dataHandler() const { title = &#39;&#39;, description = &#39;&#39; } = pageConfigData.pageInfo const context = { title, description, script: `window.__initData__=${JSON.stringify({ pageConfig: pageConfigData, })}`, } const app = new Vue({ data: {}, components: { App: main.default }, render: (h) =&gt; h(&#39;App&#39;, { props: { pageConfig: pageConfigData } }), }) 通过 renderer 对象输出 html 并写入到目标目录下。 renderer.renderToString(app, context, (err, html) =&gt; { if (!html) { return } const filePath = path.resolve(__dirname, `${publishConfig.filePath}`) fse.ensureDirSync(filePath) // name 为 nodejs 命令行参数：待打包页面名称 fs.writeFile(`${filePath}/${name}.html`, html, function(err) { if (err) { console.error(`&gt;&gt;&gt;&gt; 生成 ${name} 页面失败!`, err) return } console.log( `${publishConfig.filePath}/${name}.html` + &#39;:数据写入成功！&#39; ) }) }) over~","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ertsul.github.io/tags/Vue/"},{"name":"可视化搭建平台","slug":"可视化搭建平台","permalink":"https://ertsul.github.io/tags/可视化搭建平台/"},{"name":"webpack","slug":"webpack","permalink":"https://ertsul.github.io/tags/webpack/"}]},{"title":"可视化搭建平台（二）- 实现","slug":"可视化搭建平台（二）-实现","date":"2021-03-28T08:58:59.000Z","updated":"2021-03-28T09:11:27.401Z","comments":true,"path":"2021/03/28/可视化搭建平台（二）-实现/","link":"","permalink":"https://ertsul.github.io/2021/03/28/可视化搭建平台（二）-实现/","excerpt":"","text":"页面效果： 主要解决两个问题： 组件的拖拽； 渲染组件 component 和样式修改组件 styleComponent 数据流转问题。 组件的拖拽和克隆组件拖拽这里使用到的是这个基于 sortable.js，使用 Vue 进行封装的组件 Vue.Draggable。具体使用官方文档和相关例子都很详细。 主要使用两个功能： 拖拽：更改页面布局 克隆：将左边渲染组件列表中的组件拖拽克隆到中间页面预览区域 拖拽h5-editor 组件使用方式： &lt;h5-editor v-model=&quot;jsonData&quot; :data=&quot;data&quot;&gt;&lt;/h5-editor&gt; &lt;template&gt; &lt;draggable class=&quot;dragArea list-group&quot; v-model=&quot;layout&quot; tag=&quot;div&quot; v-bind=&quot;dragOptions&quot; @start=&quot;startDragLayout&quot; @end=&quot;finishDragLayout&quot; group=&quot;preview&quot; &gt; &lt;div v-for=&quot;(element, index) in layout&quot; :key=&quot;index&quot;&gt; // ... &lt;component :is=&quot;element.component&quot; :dynamicStyle=&quot;element.dynamicStyle&quot;&gt;&lt;/component&gt; &lt;/div&gt; &lt;/draggable&gt; &lt;/template&gt; &lt;script&gt; export default { model: { prop: &quot;jsonData&quot;, event: &quot;changePageInfo&quot;, }, props: { // 页面初始化数据 data: { type: Array, default: () =&gt; [], }, }, data() { return { layout: [] } }, computed: { // 主要是定义一些属性 dragOptions() { return { animation: 200, // 动画执行时间 group: &quot;preview&quot;, // 这个 group 的作用是，设置渲染区域的 group 和左边组件列表的 group 相同，在同一 group 中，即可进行克隆 disabled: false, ghostClass: &quot;ghost&quot;, // 组件拖动还未放下的样式 }; }, }, // ... 其他实现细节忽略 watch: { // ... } } &lt;/script&gt; 实现 v-model，监听 layout 是否变更，然后派发 changePageInfo 事件即可实现 v-model。 &lt;draggable&gt;&lt;/draggable&gt; 标签是 Vue.Draggable 封装好的组件，只要把我们的布局数组 layout 跟内部进行判定，即可实现拖拽和 layout 数据更新。 而&lt;draggable&gt;&lt;/draggable&gt;标签内部通过一个 v-for循环包裹，结合 Vue 动态组件 &lt;component :is=&quot;&quot; /&gt; 即可实现组件的展示。 注：@start、@end等事件的绑定，函数的参数里面有新旧索引等重要信息可利用。 克隆h5-editor 组件使用方式： &lt;h5-editor v-model=&quot;jsonData&quot; :data=&quot;data&quot;&gt;&lt;/h5-editor&gt; &lt;draggable class=&quot;all-coms__box dragArea list-group&quot; :list=&quot;baseComponentsData&quot; :group=&quot;{ name: &#39;preview&#39;, pull: &#39;clone&#39;, put: false }&quot; :clone=&quot;clone&quot; :sort=&quot;false&quot; @end=&quot;finishClone&quot; &gt; &lt;/draggable&gt; 克隆组件跟拖拽组件多了两个设置属性： group：设置组别，组别跟预览区域的组别一样，都是 preview； sort：禁止自身列表重新排序。 显示对应的样式修改组件在中间预览区域点击一个组件后，右边样式修改区域会显示对应的组件。这个逻辑实现比较简单，因为每个组件都有对应的索引，通过对应索引显示对应组件即可，结合 Vue 动态组件 &lt;component :is=&quot;&quot; /&gt; 即可实现组件的展示。 修改对应的渲染组件样式当样式修改组件向上派发事件 changeStyle，父组件 h5-editor 就可以监听到事件触发和携带新的样式对象，然后通过修改 layout 对应索引的 dynamicStyle 属性值（$set()触发），即可修改对应渲染组件样式。 可视化搭建平台（三）-打包","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ertsul.github.io/tags/Vue/"},{"name":"可视化搭建平台","slug":"可视化搭建平台","permalink":"https://ertsul.github.io/tags/可视化搭建平台/"},{"name":"webpack","slug":"webpack","permalink":"https://ertsul.github.io/tags/webpack/"}]},{"title":"可视化搭建平台（一）- 流程","slug":"可视化搭建平台（一）-流程","date":"2021-03-28T08:58:33.000Z","updated":"2021-03-28T09:10:52.425Z","comments":true,"path":"2021/03/28/可视化搭建平台（一）-流程/","link":"","permalink":"https://ertsul.github.io/2021/03/28/可视化搭建平台（一）-流程/","excerpt":"","text":"做一个更加通用的可视化搭建平台，用户通过 npm 安装 h5-editor (包名)，就可以直接使用了。 可以使用的功能有： 拖拽组件、删除组件； 修改页面基本信息，如：页面标题、页面背景色等； 修改组件样式，如：组件大小、颜色等； 可以使用基础组件（组件内提供）； 可以使用自定义组件（用户自己实现的组件）； 打包生成静态化页面。 应用场景：面对不同业务所需的组件不同，因此抽离并且封装内部数据流通，封装基础组件。 最终页面效果如下： 页面布局 数据流转主要数据流转如下图： 上图就是数据流转的使用图：通过将基础组件信息传入 h5-editor，然后输出一份 json 数据，然后通过这份 json 数据打包生成 html 页面。 组件最后的使用方式为： &lt;h5-editor v-model=&quot;jsonData&quot; :data=&quot;data&quot;&gt;&lt;/h5-editor&gt; 数据格式及流转外部传入 h5-editor 组件信息外部传入基本数据信息 data 格式如下： [ { component, // 渲染组件 styleComponent, // 渲染组件对应修改样式的组件 dynamicStyle, // 组件样式 props }, { // ... } ] component：渲染组件，即拖拽添加到页面、最后显示到实际页面上的组件； styleComponent：渲染组件对应的样式修改组件。即在中间预览区域点击了一个组件后，右边区域显示对应的样式修改组件。 dynamicStyle：该属性是传入到组件内部的 props 对象。 h5-editor 输出数据格式h5-editor 调用者和 h5-editor 组件通过 v-model 共享一份 jsonData 数据。有两个作用： 调用者实时拿到 jsonData 数据； 可用于草稿 jsonData 数据的传入初始化 h5-editor 组件信息。 jsonData 数据格式如下： { // 基本配置信息 pageInfo: { title: &#39;&#39;, // 页面标题 description: &#39;&#39;, // 页面描述 backgroundColor: &#39;&#39;, // 页面背景色 // ... }, // 页面布局信息 layout: [ { type: &#39;&#39;, // 组件类型，对用 component.name dynamicStyle: { // 页面样式信息 // ... } } ] } 数据流转过程渲染组件 component 和 样式修改组件 styleComponent 都包含这个 props 对象，这样一旦样式修改组件 styleComponent 修改了样式，就通过向父级组件派发样式修改事件 changeStyle（通过 this.$emit(&#39;changeStyle&#39;, newDynamicStyleObj)派发），这样父级组件 h5-editor 就可以接收到样式修改事件和新的样式值，然后将新的样式值注入到渲染组件 component 的 dynamicStyle props 中，最后将页面样式进行更新。 总结：h5-editor 在渲染组件 component 和样式修改组件 styleComponent 之间扮演的角色只是数据转发的作用。 可视化搭建平台（二）-实现","categories":[],"tags":[{"name":"Vue","slug":"Vue","permalink":"https://ertsul.github.io/tags/Vue/"},{"name":"可视化搭建平台","slug":"可视化搭建平台","permalink":"https://ertsul.github.io/tags/可视化搭建平台/"},{"name":"webpack","slug":"webpack","permalink":"https://ertsul.github.io/tags/webpack/"}]},{"title":"flutter 知识点记录","slug":"flutter-知识点记录","date":"2021-03-21T08:52:56.000Z","updated":"2021-03-28T09:03:06.262Z","comments":true,"path":"2021/03/21/flutter-知识点记录/","link":"","permalink":"https://ertsul.github.io/2021/03/21/flutter-知识点记录/","excerpt":"","text":"Flutter 记录1. Button 限制宽高使用 SizeBox 进行包裹。 Widget _arrowIcon = SizedBox( width: duSetWidth(18.0), child: FlatButton( padding: EdgeInsets.all(0), onPressed: () { print(&#39;_arrowIcon tap&#39;); }, child: Icon( IconFont.iconmore, color: AppColors.grayThirdColor, size: duSetFontSize(14), ), ), ); 2.获取目标 widget 相关信息使用 GlobalKey() // 定义变量 GlobalKey _Key = GlobalKey(); // 绑定 widget Center( key: _Key, child: Text(&#39;content&#39;) ); // 使用 RenderBox _box = _alphabetListKey?.currentContext?.findRenderObject(); _box.localToGlobal(Offset.zero); // offset // ... 3.沉浸式状态栏void _statusBar([String color]) { // 白色沉浸式状态栏颜色 白色文字 SystemUiOverlayStyle light = SystemUiOverlayStyle( systemNavigationBarColor: Color(0xFF000000), systemNavigationBarDividerColor: null, /// 注意安卓要想实现沉浸式的状态栏 需要底部设置透明色 statusBarColor: Colors.transparent, systemNavigationBarIconBrightness: Brightness.light, statusBarIconBrightness: Brightness.light, statusBarBrightness: Brightness.dark, ); // 黑色沉浸式状态栏颜色 黑色文字 SystemUiOverlayStyle dark = SystemUiOverlayStyle( systemNavigationBarColor: Color(0xFF000000), systemNavigationBarDividerColor: null, /// 注意安卓要想实现沉浸式的状态栏 需要底部设置透明色 statusBarColor: Colors.transparent, systemNavigationBarIconBrightness: Brightness.light, statusBarIconBrightness: Brightness.dark, statusBarBrightness: Brightness.light, ); &quot;white&quot; == color?.trim() ? SystemChrome.setSystemUIOverlayStyle(light) : SystemChrome.setSystemUIOverlayStyle(dark); } 4.获取顶部状态栏高度 MediaQuery.of(context).padding.top MediaQueryData.fromWindow(window).padding.top 5.安全区域，比如：iphone 12等全面屏底部遮挡问题 SafeArea 6.国际化初始化生命周期问题问题：在 initState 直接调用 DemoLocalizations.of(context).all 原因：initState 生命周期的作用主要是将当前的 state 与上下文 buildContext 产生关联，此时的上下文还不能使用。 解决方案： initState 添加异步逻辑 Future.delayed(Duration.zero, () { // ... }); 放 didChangeDependencies 生命周期 7.切换 tab，addListener 触发两次点击切换tab的时候执行了一个动画效果，滑动切换的时候是没有的，在这个过程中触发了一次Listener，所以触发了两次addListener方法。 解决方案：在 addListener 中添加判断 if(_newsTabController.index == _newsTabController.animation.value) { //... } if(_newsTabController.indexIsChanging) { //... } 8.stack 溢出部分点击失效问题如下图：蓝色区域为父级 stack 容器，灰色容器（1+2）为 stack 子级样式，由于 2 溢出父级容器，出现问题：2 点击事件不生效。 解决办法：更改布局，父级容器包裹整个区域，不让其溢出。 9.vscdoe 多渠道 flavor 配置根目录添加 .vscode/launch.json 配置文件，添加配置： { &quot;version&quot;: &quot;xxx&quot;, &quot;configurations&quot;: [ { &quot;name&quot;: &quot;wapcar&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;dart&quot;, &quot;args&quot;: [ &quot;--flavor&quot;, &quot;wapcar&quot; ] }, { &quot;name&quot;: &quot;autofun&quot;, &quot;request&quot;: &quot;launch&quot;, &quot;type&quot;: &quot;dart&quot;, &quot;args&quot;: [ &quot;--flavor&quot;, &quot;autofun&quot; ] } ] } 10.json 序列化 安装依赖 dependencies: json_annotation: ^3.1.1 dev_dependencies: build_runner: ^1.10.13 json_serializable: ^3.5.1 创建模型类 user.dart import &#39;package:json_annotation/json_annotation.dart&#39;; /// This allows the `User` class to access private members in /// the generated file. The value for this is *.g.dart, where /// the star denotes the source file name. part &#39;user.g.dart&#39;; /// An annotation for the code generator to know that this class needs the /// JSON serialization logic to be generated. @JsonSerializable() class User { User(this.name, this.email); String name; String email; /// A necessary factory constructor for creating a new User instance /// from a map. Pass the map to the generated `_$UserFromJson()` constructor. /// The constructor is named after the source class, in this case, User. factory User.fromJson(Map&lt;String, dynamic&gt; json) =&gt; _$UserFromJson(json); /// `toJson` is the convention for a class to declare support for serialization /// to JSON. The implementation simply calls the private, generated /// helper method `_$UserToJson`. Map&lt;String, dynamic&gt; toJson() =&gt; _$UserToJson(this); } 执行命令 flutter pub run build_runner build 后生成 user.g.dart 文件 11.延迟加载库 12.获取屏幕宽高double _screenHeight = MediaQuery.of(context).size.height double _screenWidth = MediaQuery.of(context).size.width 13.解决 bottomNavigationBar切换 tabbar 刷新页面，原有状态消失问题 AutomaticKeepAliveClientMixin IndexedStack Scaffold( bottomNavigationBar: _buildBottomNavigationBar(), body: IndexedStack( // indexedStack 可以确保 tabbar 时候不刷新页面 index: _selectedIndex, children: _contentListView, ), ); 14.切换 tabbar 保存状态class _HomeRecommednedState extends State&lt;HomeRecommedned&gt; with AutomaticKeepAliveClientMixin { @override bool get wantKeepAlive =&gt; true; // with AutomaticKeepAliveClientMixin + 设置 wantKeepAlive 为 true，确保顶部切换 tabbar 保存 state } 15.FutrueBuilder / StreamBuilder作用：异步 UI 更新。两者都可以用于接收异步事件数据。 区别： futureBuilder 只有一个响应，类似于 js 中的 Promise。 streamBuilder 可以接收多个异步操作的结果，常用于多次读取数据的异步任务场景。 16. Flutter 布局约束链接：https://flutter.cn/docs/development/ui/layout/constraints","categories":[{"name":"flutter","slug":"flutter","permalink":"https://ertsul.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://ertsul.github.io/tags/flutter/"}]},{"title":"flutter 字母联动列表","slug":"flutter-字母联动列表","date":"2020-12-20T11:13:22.000Z","updated":"2021-03-28T09:03:10.880Z","comments":true,"path":"2020/12/20/flutter-字母联动列表/","link":"","permalink":"https://ertsul.github.io/2020/12/20/flutter-字母联动列表/","excerpt":"","text":"flutter 字母联动列表网上的第三方包，用的最多就是：azListView。 但是它有 bug：当列表到达页面底部的时候，滑动最后几个字母，还会触发回弹到屏幕顶部。如下： 经过分析，一开始以为是 ListView 的 physics 属性影响，physics 介绍： ClampingScrollPhysics：Android下微光效果。 BouncingScrollPhysics：iOS下弹性效果。 NeverScrollableScrollPhysics：禁止滚动。 但是设置该属性其实没有效果，还是会出现上面的问题。 后面多次测试 ListView，发现是 ListView 跳转事件 jumpTo 的影响，后面改用 animateTo，animateTo 的用法如下： _scrollController.animateTo( offsetHeight, duration: Duration(milliseconds: 10), curve: Curves.linear, ) 但是又有新的问题： 当连续快速滑动的时候，这个 duration 相当于多了个防抖的作用。 点击字母列表的时候，也会有问题。 效果如下： azListView 存在问题： azListView 包体较大； 存在的问题修改源码耗时较久。 自己实现，效果如下： 布局整个页面用 Stack 布局，分为： 主列表（头部 + 城市列表） 主列表顶部字母提示 字母列表（字母列表 + 当前字母提示） 代码如下： /// _buildBody Widget _buildBody() { return Stack( children: [ _buildMainListView(), _buildSusBarView(), Positioned( top: duSetHeight(120), right: duSetWidth(10), child: Row( mainAxisAlignment: MainAxisAlignment.center, children: [_buildAlphabetListView()], ), ), ], ); } GestureDetectorGestureDetector 文档链接 onVerticalDragUpdate：滑动更新 onVerticalDragEnd：滑动结束 … 主要思路1.初始化的时候，先计算获取以下数值。 计算主列表每个字母分组需要跳转的 offsetTopList 和每个字母分组所占用的高度 groupHeight； 【计算：遍历字母列表，字母的 offsetTop = 之前的所有字母所有的 offsetTop 累加；当前字母的 groupHeight = 每个主列表项 itemHeight * 每个字母分组数量。】 /// 计算主列表每个字母需要滚动的距离和每个字母项所占用的高度 void _calcEachLetterOffsetTop() { List&lt;String&gt; _alphabetList = widget.alphabetList; /// offset top _alphabetListOffsetTopMap[_alphabetList[0]] = 0; // &#39;#&#39; header offsetTop _alphabetListOffsetTopMap[_alphabetList[1]] = widget.headerHeight; // 第一个字母，滚动距离为顶部 header 高度 offsettop /// height _alphabetListHeightMap[_alphabetList[0]] = widget.headerHeight; // &#39;#&#39; header height _alphabetListHeightMap[_alphabetList[1]] = widget.alphabetCountMap[_alphabetList[1]] * widget.mainListItemHeight + widget.guideBarHeight; // 第一个字母所占用的高度 // 第二项开始循环 for (int i = 2; i &lt; _alphabetList.length; i++) { String _curLetter = _alphabetList[i]; // 当前字母 // 保存当前字母项的高度 _alphabetListHeightMap[_curLetter] = widget.alphabetCountMap[_curLetter] * widget.mainListItemHeight + widget.guideBarHeight; // 计算主列表每一个字母项需要滚动的 offsetTop（之前的所有字母所有的 offsetTop 累加） double _offsetTopSum = 0.0; for (int j = i - 1; j &gt; 0; j--) { String _preLetter = _alphabetList[j]; // 之前的字母 // 将之前所有字母的高度累加 // 主列表每个字母单元高度 = 子项数量 * 子项高度 + 主列表导航条高度 _offsetTopSum += widget.alphabetCountMap[_preLetter] * widget.mainListItemHeight + widget.guideBarHeight; } _alphabetListOffsetTopMap[_curLetter] = _offsetTopSum + widget.headerHeight; // 设置当前字母的滚动 offsetTop } } 获取主列表不需要滚动的字母列表。 【计算：从字母表后面遍历，将每个字母分组所占用的高度 groupHeight 进行累加，与屏幕的高度进行比较，如果累加结果小于屏幕高度，则对该字母进行标记。】 主要代码如下： /// 获取主列表不需要滚动的字母列表 void _getNotScrollAlphebetList() { final _screenHeight = duSetHeight(MediaQuery.of(context).size.height); // 屏幕高度 // final _screenHeight = duSetHeight(size.height); double _heightSum = 0.0; // 判断那些字母不需要触发列表滚动，从后面字母开始循环累加，判断是否小于屏幕高度 for (int i = widget.alphabetList.length - 1; i &gt;= 0; i--) { String _curLetter = widget.alphabetList[i]; bool _ifLessThanScreenHeight = _heightSum + _alphabetListHeightMap[_curLetter] &lt;= _screenHeight; if (_ifLessThanScreenHeight) { _heightSum += _alphabetListHeightMap[_curLetter]; // 累加 _notScrollAlphabetLst.insert(0, _curLetter); // 添加到列表 } else { break; } } } 2. 滑动主列表，获取当前的字母，更新右侧字母表状态和更新顶部字母导航条。 获取主列表当前滑动位置的 screenOffsetTop； 遍历 offsetTopList，判断 screenOffsetTop 在哪两个字母的区间内，则可以定位到目标字母。 主要代码如下： /// 更新字母表当前激活的字母 void _updateAlphebetListView() { // 主列表上锁中（滚动执行中），直接返回 if (_mainListScrollLock == true) return; List&lt;String&gt; _alphabetList = widget.alphabetList; // 监听主列表滚动，判断主列表的 offsetTop 在哪两个字母的 offsetTop 区间内，将右侧字母导航列表激活为当前字母 for (int i = 0; i &lt; widget.alphabetList.length; i++) { // 不为最后一个字母 + 主列表 offsetTop 大于当前字母的 offsetTop + 主列表的 offsetTop 小于下一个字母的 offsetTop bool _ifInCurRange = i != widget.alphabetList.length - 1 &amp;&amp; _scrollController.offset &lt;= _alphabetListOffsetTopMap[_alphabetList[i + 1]] &amp;&amp; _scrollController.offset &gt; _alphabetListOffsetTopMap[_alphabetList[i]]; if (_ifInCurRange) { _selectedAlphabetIndex = i; // 设置字母表选中字母索引 _mainListScrollLock = false; // 解锁 setState(() {}); return; } } } 3. 滑动字母表，获取当前的字母，主列表跳转到目标字母和更新顶部字母导航条。 获取字母表当前位置相对于字母表容器顶部的高度 paddingOffsetTop【获取字母表当前位置对于视窗的高度 - 字母表容器顶部的高度相对于视窗的高度】; 计算每个字母项占用字母表容器的高度 alphabetItemHeight 【(字母表容器的高度 - padding) / 字母数量】； 获取当前索引，paddingOffsetTop / alphabetItemHeight； 获取当前字母和主列表 offsetTopList 滚动高度， 更新视图。 主要代码如下： /// 滑动字母表：滚动主列表 + 更新字母列表 void _onVerticalDragUpdateHandle(DragUpdateDetails event, int index) { /// 更新字母表 if (_alphabetListOffset == null) { // 获取字母表的 margin top RenderBox _box = _alphabetListKey?.currentContext?.findRenderObject(); _alphabetListOffset = _box.localToGlobal(Offset.zero); } // 字母表的padding double _alphabetPadding = widget.alphabetListItemHeight; // 计算当前字母项索引：(当前活动的 dy - 字母表的 marginTop - 字母表的 padding) / 每个字母所占的高度 int _curActiveLetterIndex = ((event.globalPosition.dy - _alphabetListOffset.dy - _alphabetPadding) / widget.alphabetListItemHeight) .round(); if (_curActiveLetterIndex &lt; 0) { // 滑出字母表区域上面，保持为 0 _selectedAlphabetIndex = 0; } else if (_curActiveLetterIndex &gt;= widget.alphabetList.length) { // 滑出字母表区域下面，保持为最后一个 _selectedAlphabetIndex = widget.alphabetList.length - 1; } else { _selectedAlphabetIndex = _curActiveLetterIndex; } setState(() {}); /// 滚动主列表 String _curLetter = widget.alphabetList[_selectedAlphabetIndex]; // 获取当前字母项 _scrollMainList(_curLetter); } 4.当主列表已经滑动到底部，继续滑动字母表剩下的字母，判断当前字母时候标记为不需要滚动主列表，直接滑动列表底部，不滑动到字母分组位置。主要代码如下： /// 滚动主列表 void _scrollMainList(String letter) { if (_notScrollAlphabetLst.contains(letter)) { // 当前字母不需要滚动 _scrollController .jumpTo(_scrollController.position.maxScrollExtent); // 滚动到列表底部 return; } _scrollController.jumpTo( _alphabetListOffsetTopMap[letter], ); } 5. 主列表滚动锁。为防止出现上次滚动还没结束，下次滚动就开始执行的问题，给主列表滚动上锁。 /// 更新字母表当前激活的字母 void _updateAlphebetListView() { // 主列表上锁中（滚动执行中），直接返回 if (_mainListScrollLock) return; // ... }","categories":[{"name":"flutter","slug":"flutter","permalink":"https://ertsul.github.io/categories/flutter/"}],"tags":[{"name":"flutter","slug":"flutter","permalink":"https://ertsul.github.io/tags/flutter/"}]},{"title":"svg sprite","slug":"svg-sprite","date":"2020-08-09T06:33:26.000Z","updated":"2020-08-09T06:35:05.240Z","comments":true,"path":"2020/08/09/svg-sprite/","link":"","permalink":"https://ertsul.github.io/2020/08/09/svg-sprite/","excerpt":"","text":"svg sprite介绍svg sprite 不跟传统图片雪碧图一样是许多小图的集合。它是基于 svg，是很多 svg 的集合，每个 svg 元素都包含在标签&lt;symbol id=&quot;xxxx&quot;&gt;&lt;/symbol&gt;，这样就不用像图片雪碧图一样去请求一张大图。如下面就是一个 sprite.svg 文件： &lt;svg xmlns=&quot;http://www.w3.org/2000/svg&quot; xmlns:xlink=&quot;http://www.w3.org/1999/xlink&quot;&gt; &lt;defs&gt; &lt;symbol t=&quot;1595505780153&quot; class=&quot;icon&quot; viewBox=&quot;0 0 1024 1024&quot; version=&quot;1.1&quot; id=&quot;icon-logo&quot;&gt; &lt;path d=&quot;M680.97024 343.06048A238.26432 238.26432 0 0 0 512 273.05984c-131.93216 0-238.92992 106.97728-238.92992 238.92992S380.06784 750.94016 512 750.94016c120.29952 0 219.5968-89.05728 236.19584-204.81024H512v-68.27008h307.2v34.12992a313.1392 313.1392 0 0 1-1.9968 34.14016C800.2048 699.74016 670.12608 819.21024 512 819.21024c-169.66656 0-307.2-137.53344-307.2-307.22048 0-169.64608 137.53344-307.2 307.2-307.2 84.82816 0 161.62816 34.39616 217.23136 89.99936l-48.26112 48.27136z&quot; p-id=&quot;3177&quot;&gt;&lt;/path&gt; &lt;/symbol&gt; &lt;/defs&gt; &lt;/svg&gt; 当需要新增 svg icon 的时候，只需要添加新的 svg 在 symbol 上就行，每个 symbol 都有一个 id，用于使用的时候调用。 使用的时候，需要 &lt;use xlink:href=&quot;#xxxx&quot;&gt;&lt;/use&gt; 标签进行调用。当 sprite.svg 独立抽离成一个文件的时候，use 标签的格式为：&lt;use xlink:href=&quot;/path/sprite.svg#xxxx&quot;&gt;&lt;/use&gt;。如：使用上面的 logo icon，格式为： &lt;svg width=&quot;40&quot; height=&quot;40&quot;&gt; &lt;use xlink:href=&quot;/svg/sprite.svg#icon-logo&quot; x=&quot;0&quot; y=&quot;0&quot; /&gt; &lt;/svg&gt; svg sprite 更加方便的是，可以通过 css 属性fill:color;直接更改颜色： 结合 vue + webpack 使用主要是使用两个 loader ： svg-sprite-loader svgo-loader 在 vue.config.js中添加配置配置： 不抽离 sprite.svg 文件为独立的文件（集成在 html 文件中），一般用于开发环境。 vue.config.js 配置： chainWebpack(config) { config.module.rules.delete(&quot;svg&quot;); config.module .rule(&quot;svg&quot;) .test(/\\.svg$/) .use(&quot;svg-sprite&quot;) .loader(&quot;svg-sprite-loader&quot;) .options({ extract: false, // 默认不抽离 sprite.svg 为独立的文件 // spriteFilename: (svgPath) =&gt; `sprite${svgPath.substr(-4)}`, esModule: false, }) .end() } 封装 svgIcon 组件： &lt;template&gt; &lt;div class=&quot;svg-icon&quot;&gt; &lt;svg :style=&quot;styleObj&quot; :viewBox=&quot;svgCtx.viewBox&quot;&gt; &lt;use :id=&quot;svgCtx.id&quot; :xlink:href=&quot;&#39;#&#39; + svgCtx.id&quot;/&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; export default { props: { width: { type: String, default: &quot;40px&quot; }, height: { type: String, default: &quot;40px&quot; }, color: { type: String, default: &quot;&quot; }, svg: { type: Object, default: () =&gt; {}, required: true } }, computed: { styleObject() { // 样式对象 let styleObj = {}; this.width &amp;&amp; (styleObj.width = this.width); this.height &amp;&amp; (styleObj.height = this.height); this.color &amp;&amp; (styleObj.fill = this.color); return styleObj; }， svgCtx() { // 兼容 import 和 require 两种模式（require 模式下默认的 svg 对象在 default 中） // return this.svg.hasOwnProperty(&quot;default&quot;) ? this.svg.default : this.svg; return this.svg.default || this.svg; } } }; &lt;/script&gt; 组件使用： &lt;template&gt; &lt;div class=&quot;svg-container&quot;&gt; &lt;svgIcon :svg=&quot;logoSvg&quot;&gt;&lt;/svgIcon&gt; &lt;svgIcon :svg=&quot;playSvg&quot;&gt;&lt;/svgIcon&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; import svgIcon from &quot;../../src/components/svgIcon&quot; import logoSvg from &quot;../../src/assets/logo.svg&quot; import playSvg from &quot;../../src/assets/play.svg&quot; export default { components: {svgIcon}, data() { return { logoSvg: logoSvg, playSvg: playSvg }; }, }; &lt;/script&gt; 效果： 抽离 sprite.svg 文件为独立的文件，一般用户生产环境： 修改 vue.config.js 配置： config.module.rules.delete(&quot;svg&quot;); config.module .rule(&quot;svg&quot;) .test(/\\.svg$/) .use(&quot;svg-sprite&quot;) .loader(&quot;svg-sprite-loader&quot;) .options({ extract: true, // spriteFilename: (svgPath) =&gt; `sprite${svgPath.substr(-4)}`, esModule: false, }) .end() config.plugin(&quot;svg-sprite&quot;).use(require(&quot;svg-sprite-loader/plugin&quot;)); // 抽离 sprite.svg 必需 修改 svg 组件： &lt;template&gt; &lt;div class=&quot;svg-icon&quot;&gt; &lt;svg :style=&quot;styleObject&quot; :viewBox=&quot;svgCtx.viewBox&quot;&gt; &lt;!-- 指向打包后抽离的 sprite.svg 文件 --&gt; &lt;use :id=&quot;svgCtx.id&quot; :xlink:href=&quot;&#39;../dist/sprite.svg#&#39; + svgCtx.id&quot;/&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/template&gt; 其他不变，效果如下： 思考：怎么通过环境变量将生产模式和开发环境结合起来？ 结合开发模式和生产模式主要解决两个问题： vue.config.js 中的 extract 配置：false 和 true； svgIcon 中 xlink:href 指向问题。 通过环境变量即可。 修改 vue.config.js： const ifProd = process.env.NODE_ENV === &#39;production&#39;; // ... extract: ifProd, // ... 修改 svgIcon 组件： &lt;template&gt; &lt;div class=&quot;svg-icon&quot;&gt; &lt;svg :style=&quot;styleObject&quot; :viewBox=&quot;svgCtx.viewBox&quot;&gt; &lt;use :id=&quot;svgCtx.id&quot; :xlink:href=&quot;xlinkHref&quot;/&gt; &lt;/svg&gt; &lt;/div&gt; &lt;/template&gt; &lt;script&gt; // ... xlinkHref() { const ifProd = process.env.NODE_ENV === &#39;production&#39;; const svgCtxId = this.svgCtx.id; // 生产环境指向打包后抽离的 sprite.svg 文件 // 开发环境不抽离独立的 sprite.svg 文件 return ifProd ? `../dist/sprite.svg#${svgCtxId}` : `#${svgCtxId}`; } //... &lt;/script&gt; 问题用了 svg-sprite-loader 之后，不能通过 CSS 属性 fill:color;更改颜色。是因为这个 loader 默认给 svg 添加了 fill:none; 属性，导致更改不了。 解决办法：通过svgo-loader 解决。通过这个 loader 我们可以添加很多插件，这些插件是基于 svgo，svgo 在安装 svgo-loader 的时候自动安装了。下面是 svgo 的截图： 回归正题，修改 vue.config.js 配置，去除默认加上的 fill:none; 属性： // ... .use(&quot;svgo-loader&quot;) .loader(&quot;svgo-loader&quot;) .options({ plugins: [ { removeAttrs: { attrs: &quot;(fill|stroke)&quot;, } }, ], }) .end(); // ... 就这样，问题解决了~","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"Vue","slug":"frontEnd/Vue","permalink":"https://ertsul.github.io/categories/frontEnd/Vue/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"Vue","slug":"Vue","permalink":"https://ertsul.github.io/tags/Vue/"}]},{"title":"实现一个简易的webpack","slug":"实现一个简易的webpack","date":"2020-03-08T06:03:54.000Z","updated":"2020-03-08T08:11:02.441Z","comments":true,"path":"2020/03/08/实现一个简易的webpack/","link":"","permalink":"https://ertsul.github.io/2020/03/08/实现一个简易的webpack/","excerpt":"","text":"分析webpack 的官方解释如下： 本质上，webpack 是一个现代 JavaScript 应用程序的静态模块打包工具。当 webpack 处理应用程序时，它会在内部构建一个 依赖图(dependency graph)，此依赖图会映射项目所需的每个模块，并生成一个或多个 bundle。 简单理解，webpack 就是从入口开始，分析各个模块之间的相互依赖关系，最后将这些依赖模块生成 bundle。所以要手动实现一个 webpack，需要解决以下几个问题： 获取入口文件和出口文件的路径； 分析入口文件的相关模块依赖； 递归分析其他模块的相关模块依赖； 生成模块之间的依赖关系； 解决浏览器不能识别 require 的问题，生成 bundle。 实现文件目录结构└───lib 目录 | └───compiler.js // 主要 webpack 类，存放主要逻辑，如：调用 parser.js 相关方法，生成依赖关系图谱和 bundle。 | └───parser.js // 获取 AST、依赖模块和最后生成的 code |───src | └───index.js // 入口文件 | └───module1.js // 模块 1，被 index.js 引用 | └───module1-1.js // 模块 1-1，被 module1.js 引用 └───webpack.js // node 执行文件 └───webpack.config.js // webpack 配置信息 └───node_modules └───package.json webpack.config.js const path = require(&#39;path&#39;); module.exports = { entry: &#39;./src/index.js&#39;, output: { filename: &#39;bundle.js&#39;, path: path.resolve(__dirname, &#39;./dist&#39;) } } webpack.js 该文件作用是最后通过 node webpack.js 即可执行 webpack 代码逻辑，故：需要将 lib/compiler.js 引进并且执行，传入 webpack 的配置即可。 const Compiler = require(&quot;./lib/compiler&quot;); const options = require(&quot;./webpack.config.js&quot;); new Compiler(options).run(); 初始化 Compiler 类module.exports = class Compiler { constructor(options) { this.entry = options.entry; this.output = options.output; this.modules = []; // 存放所有依赖模块 } /** * 主要执行函数 */ run() { // ... } /** * 获取单个文件的依赖关系、文件名和执行代码 */ build(entryFile) { // ... } /** * 获取 bundle */ generateBundle() { // ... } } 实现 parser.js该文件主要实现由三点： 获取 AST； 获取文件的所有依赖； 生成执行代码。 在 index.js 中引进使用了 module1.js 模块，那么 index.js 的依赖模块就是 module1.js；在 module1.js 中引进使用了 module1-1.js 模块，那么 module1.js 的依赖模块就是 module1-1.js。想要获得模块的相关依赖模块，需要借助 AST（抽象语法树），从 AST 中我们可以获得模块的依赖。实现逻辑如下： 获取文件的绝对路径，通过 @babel/parser 将目标文件中的代码转化为 AST； 通过 @babel/traverse 分析 AST 中的 ImportDeclaration 方法，可以得到该模块的所有依赖模块； 通过 @babel/core 中的 transformFromAst 可以将 AST 转化为 js 代码。 最后所有的代码如下： const fs = require(&quot;fs&quot;); const path = require(&quot;path&quot;); const parser = require(&quot;@babel/parser&quot;); const traverse = require(&quot;@babel/traverse&quot;).default; const { transformFromAst } = require(&quot;@babel/core&quot;); module.exports = { // 分析模块，获取 ast getAst: fileName =&gt; { const content = fs.readFileSync(fileName, &quot;utf-8&quot;); const ast = parser.parse(content, { sourceType: &quot;module&quot; // module 模块模式 }); return ast; }, // 获取依赖 getDependencies: (ast, fileName) =&gt; { const dependencies = {}; // key: 相对路径 value: 根路径 traverse(ast, { ImportDeclaration({ node }) { // dependencies.push(node.source.value); // 提取 import 依赖的相对路径 const dirname = path.dirname(fileName); let newPath = path.join(dirname, node.source.value); // 拼接路径 if (!/\\.js$/.test(newPath)) { // 兼容解决 window 文件路径不带后缀问题 newPath += &quot;.js&quot;; } dependencies[node.source.value] = newPath; } }); return dependencies; }, // 转换代码 getCode: ast =&gt; { const { code } = transformFromAst(ast, null, { presets: [&quot;@babel/preset-env&quot;] }); return code; } }; 完成 compiler.js build()。这个方法的主要作用：获取单个文件的 AST、所有依赖模块的路径和执行代码。 build(entryFile) { const ast = getAst(entryFile); const dependencies = getDependencies(ast, entryFile); const code = getCode(ast); return { fileName: entryFile, dependencies, code }; } run()。这个方法的主要作用： 从入口文件开始调用 build 方法（获取单个文件的 AST、所有依赖模块的路径和执行代码）； 将 build 方法返回的获取单个文件的 AST、所有依赖模块的路径和执行代码存进 modules 数组； 循环遍历 modules 数组，判断每个数组单元是否有自己的依赖（dependencies是否为空 ），有则继续调用 build 方法； 数组结构转化为 key - value 格式，key 是每个模块的相对路径，value 是 build 返回的结果。 run() { const info = this.build(this.entry); this.modules.push(info); for (let i = 0; i &lt; this.modules.length; i++) { const item = this.modules[i]; const { dependencies } = item; if (dependencies) { for (let j in dependencies) { this.modules.push(this.build(dependencies[j])); } } } // 转换数据结构：数组 =&gt; 对象 const obj = {}; this.modules.forEach(item =&gt; { obj[item.fileName] = { dependencies: item.dependencies, code: item.code }; }); // 生成代码文件 this.generateBundle(obj); } generateBundle()。重写 require 方法，生成 bundle。 通过将 run 最后生成的 key - value 对象进行解析，通过 eval 执行代码，遇到 require() 方法，调用本地的 localRequire() 方法。 generateBundle(code) { // 获取输出信息 const filePath = path.join(this.output.path, this.output.filename); // dist 路径 const newCode = JSON.stringify(code); const bundle = `(function(graph){ function require(module) { function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]); } var exports = {}; (function(require, exports, code) { eval(code) })(localRequire, exports, graph[module].code) return exports; } require(&#39;${this.entry}&#39;); })(${newCode})`; fs.writeFileSync(filePath, bundle, &quot;utf-8&quot;); } 测试执行 node webpack.js，获取生成的 bundle.js。 (function(graph){ function require(module) { function localRequire(relativePath) { return require(graph[module].dependencies[relativePath]); } var exports = {}; (function(require, exports, code) { eval(code) })(localRequire, exports, graph[module].code) return exports; } require(&#39;./src/index.js&#39;); })({&quot;./src/index.js&quot;:{&quot;dependencies&quot;:{&quot;./module1.js&quot;:&quot;src\\\\module1.js&quot;},&quot;code&quot;:&quot;\\&quot;use strict\\&quot;;\\n\\nvar _module = require(\\&quot;./module1.js\\&quot;);\\n\\ndocument.write((0, _module.module1)());&quot;},&quot;src\\\\module1.js&quot;:{&quot;dependencies&quot;:{&quot;./module1-1.js&quot;:&quot;src\\\\module1-1.js&quot;},&quot;code&quot;:&quot;\\&quot;use strict\\&quot;;\\n\\nObject.defineProperty(exports, \\&quot;__esModule\\&quot;, {\\n value: true\\n});\\nexports.module1 = module1;\\n\\nvar _module = require(\\&quot;./module1-1.js\\&quot;);\\n\\nfunction module1() {\\n return &#39;module1&#39; + (0, _module.module2)();\\n}&quot;},&quot;src\\\\module1-1.js&quot;:{&quot;dependencies&quot;:{},&quot;code&quot;:&quot;\\&quot;use strict\\&quot;;\\n\\nObject.defineProperty(exports, \\&quot;__esModule\\&quot;, {\\n value: true\\n});\\nexports.module2 = module2;\\n\\nfunction module2() {\\n return &#39;module2&#39;;\\n}&quot;}}) 执行结果如下：","categories":[],"tags":[{"name":"webpack","slug":"webpack","permalink":"https://ertsul.github.io/tags/webpack/"}]},{"title":"小程序文件生成脚本","slug":"小程序文件生成脚本","date":"2020-02-06T05:59:43.000Z","updated":"2020-02-06T06:03:41.392Z","comments":true,"path":"2020/02/06/小程序文件生成脚本/","link":"","permalink":"https://ertsul.github.io/2020/02/06/小程序文件生成脚本/","excerpt":"","text":"痛点开发微信小程序，当需要新增页面或者组件的时候，需要手动增加一个目录和四个文件。如果是页面的话，还需要将页面路由添加到 app.json 文件中。这样一旦增加页面或者组件多了，是十分繁琐的。重复工作用脚本替代。 技术node.js 流程 读取命令行参数，获取目录类型和目录名称。 生成目录和四个文件。 如果是页面类型，则将页面路由添加到 app.json 文件中。 使用 安装依赖：npm install。 链接生成本地命令：npm link。 命令 make-mp-file -t page -n name make-mp-file -t component -n name 参数 -t 或 –type：page 或者 component -n 或 –name：组件或者页面名称。 github 地址链接地址","categories":[{"name":"minapp","slug":"minapp","permalink":"https://ertsul.github.io/categories/minapp/"}],"tags":[{"name":"minapp","slug":"minapp","permalink":"https://ertsul.github.io/tags/minapp/"}]},{"title":"广度优先搜索 BFS 和深度优先搜索 DFS","slug":"广度优先搜索-BFS-和深度优先搜索-DFS","date":"2019-12-14T13:29:53.000Z","updated":"2020-02-06T06:00:08.268Z","comments":true,"path":"2019/12/14/广度优先搜索-BFS-和深度优先搜索-DFS/","link":"","permalink":"https://ertsul.github.io/2019/12/14/广度优先搜索-BFS-和深度优先搜索-DFS/","excerpt":"","text":"最近在写 virtual dom 方面的逻辑，用到 BFS 和 DFS。总结一波~😀 Virtual Dom 的示例 json 如下： const vNode = { node: &quot;root&quot;, child: [ { node: &quot;element1&quot;, child: [ { node: &quot;element3&quot; }, { node: &quot;element4&quot; } ] }, { node: &quot;element2&quot; } ] }; Virtual Dom 的树如下： 广度优先搜索 BFSBFS ：逐层访问节点，从左到右访问完成一层访问后，访问下一层，且每个节点只访问一次。 上面的树用 BFS 顺序就是：root -&gt; element1 -&gt; element2 -&gt; element3 -&gt; element4。 实现思路： 设置队列 queue，就将根节点添加到队列 queue； 判断当队列 queue 是否为空，不为空则弹出队头节点 currentNode； 将队头节点 currentNode 添加到结果队列 lists； 判断队头节点 currentNode 是否有子节点，有则将子节点从左到右依次添加到队列 queue； 重复步骤2~4。 简单理解就是： 根节点进队列； 判断队头节点是否子节点，有则将子节点从左到右依次进队列，队头节点出队列。 重复2。 用 js 代码实现如下：（注意：判断条件为队列长度） /** * BFS 非递归写法 * @param {*} root 根节点 */ const BFS = root =&gt; { if (Object.prototype.toString.call(root) != &#39;[object Object]&#39;) { throw(new Error(&#39;root 类型错误！&#39;)); return; } let resLists = []; // 存放 BFS 节点队列 if (!Object.keys(root).length) { return lists; } let queue = []; // 临时队列，每遇到一个节点就存放进队列 queue.unshift(root); while (queue.length) { // queue 队列不为空，遍历临时队列 let currentNode = queue.pop(); // 弹出临时队列的一个节点 const hasChild = currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点 if (hasChild) { const childrenNodes = currentNode.child; // 子节点数组 for (let i = 0, len = childrenNodes.length; i &lt; len; i++) { const currentChildNode = childrenNodes[i]; // 当前子节点 queue.unshift(currentChildNode); // 添加到队列 } } resLists.push(currentNode); // 当前节点存放到 BFS 节点队列 } return resLists; }; 结果如下： 深度优先搜索 DFS DFS：对每一个可能的分支路径深入到不能再深入为止，且每个节点只访问一次。 上面的树用 BFS 顺序就是：root -&gt; element1 -&gt; element3 -&gt; element4 -&gt; element2。 实现思路1（非递归）: 根节点进栈 stack； 判断栈 stack 是否为空，判断栈顶元素是否有有子节点，有则将栈顶元素的子节点从右到左依次进栈； 弹出栈顶元素，存进 lists; 重复2~3； 简单理解就是： 根节点进栈； 弹出栈顶元素，判断栈顶元素是否子节点，有则将子节点从右到左依次进栈； 重复2。 代码如下：（注意：判断条件为栈长度） const DFS = root =&gt; { if (Object.prototype.toString.call(root) != &quot;[object Object]&quot;) { throw new Error(&quot;root 类型错误！&quot;); } let resLists = []; // 存放 BFS 节点队列 if (!Object.keys(root).length) { return lists; } let stack = []; // 栈，每遇到一个节点就存放进栈 stack.push(root); while (stack.length) { let currentNode = stack.pop(); // 弹出栈顶元素 const hasChild = currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点 if (hasChild) { const childrenNodes = currentNode.child; // 子节点数组 for (let i = childrenNodes.length - 1; i &gt;= 0; i--) { const currentChildNode = childrenNodes[i]; // 当前子节点 stack.push(currentChildNode); // 添加到队列 } } resLists.push(currentNode); // 当前节点存放到 DFS 结果列表 } return resLists; }; 实现思路2（递归）： 当前节点入栈 stack； 判断当前节点是否有子节点； 有子节点： 将子节点从右到左依次进行递归；（栈是先进后出 ） 所有子节点递归结束，当前节点出栈； 无： 当前节点出栈。 代码实现如下：（注意：判断关键为节点是否有子节点） var stack = []; // 栈 var lists = []; // 存放 DFS 节点 /** * 全局变量实现 * @param {*} currentNode : 当前节点 */ const DFS = currentNode =&gt; { let hasChild = currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点 stack.push(currentNode); // 推入栈 if (hasChild) { let len = currentNode.child.length; for (let i = len - 1; i &gt;= 0; i--) { const currentChildNode = currentNode.child[i]; // 当前子节点 DFS(currentChildNode); // 递归 } lists.unshift(stack.pop()); // 出栈 } else { lists.unshift(stack.pop()); // 出栈 } }; /** * 非全局变量方式实现 * @param {*} currentNode : 当前节点 * @param {*} cache : 缓存栈和节点 */ const DFS = (currentNode = {}, cache = { lists: [], stack: [] }) =&gt; { if (Object.prototype.toString.call(currentNode) != &quot;[object Object]&quot;) { throw new Error(&quot;root 类型错误！&quot;); } let hasChild = currentNode.hasOwnProperty(&quot;child&quot;) &amp;&amp; currentNode.child.length; // 判断当前节点是否有子节点 let { lists, stack } = cache; stack.push(currentNode); // 推入栈 if (hasChild) { let len = currentNode.child.length; for (let i = len - 1; i &gt;= 0; i--) { // 注意这里要从右向左循环，因为 stack 是先进后出 const currentChildNode = currentNode.child[i]; // 当前子节点 const { lists: newLists, stack: newStack } = DFS(currentChildNode, { lists, stack }); // 递归 lists = newLists; // 更新 lists stack = newStack; // 更新栈 } lists.unshift(stack.pop()); // 出栈 } else { lists.unshift(stack.pop()); // 出栈 } // 函数返回结果，如果栈中还有节点，证明还没回溯完成，则返回缓存；否则函数执行结束 const res = stack.length ? { lists: lists, stack: stack } : lists; return res; }; 结果如下：","categories":[],"tags":[{"name":"算法","slug":"算法","permalink":"https://ertsul.github.io/tags/算法/"}]},{"title":"小程序工程化","slug":"小程序工程化","date":"2019-11-05T14:36:57.000Z","updated":"2019-11-12T15:49:42.830Z","comments":true,"path":"2019/11/05/小程序工程化/","link":"","permalink":"https://ertsul.github.io/2019/11/05/小程序工程化/","excerpt":"","text":"gulp👉官方文档传送门 gulp 编译项目日常进行小程序开发，遇到的问题有： 如果在微信开发者工具进行开发的话，效率低； 不支持 less css预编译器 ； autoprefixer ； … 考虑到小程序是多页面应用，我们只要在 src 目录添加小程序初始化时所需要的相关配置文件，然后通过 gulp 将 src 下的代码搬移到 dist 打包目录即可。 项目结构└───gulpTask 目录：主要存放 gulp 代码逻辑 | └───baseConfig.js // gulp 路径和 blob 配置信息 | └───clean.js // 清理 dist nodejs 脚本文件 | └───taskControler.js // gulp 任务定义 |───src | └───common // 公共代码 | └───less | └───... | └───js | └───... | └───components // 组件 | └───... | └───pages // 页面 | └───... | └───router // 路由 | └───router.js // 路由处理逻辑 | └───routerPath.js // 路由表 | └───api // 请求数据接口统一处理 | └───api.js | └───http // http 网络请求 | └───baseConfig.js // 基本配置 | └───devConfig.js // 开发基本配置 | └───prodConfig.js // 生产基本配置 | └───request.js // 请求处理逻辑 | └───app.js | └───app.json | └───project.config.json | └───sitemap.json └───.eslintrc // eslint 配置 └───.gitignore // git 配置 └───gulpfile.js // gulp 主入口 └───package.json └───README.md gulp 配置文件 baseConfig.js将 gulp 相关路径和 blob 配置信息统一在 baseConfig.js 中进行配置。 const path = require(&quot;path&quot;); const srcPath = path.resolve(__dirname, &quot;../src&quot;); const distPath = path.resolve(__dirname, &quot;../dist&quot;); const isDev = process.argv.includes(&quot;--development&quot;); module.exports = { isDev, // 当前环境 srcPath, // src 源路径 distPath, // dist 编译目标路径 basePath: [ srcPath ], otherPath: [ srcPath, `!${srcPath}/**/**/*.less`, `!${srcPath}/**/**/*.wxml`, `!${srcPath}/**/**/*.json`, `!${srcPath}/**/**/*.js`, `!${srcPath}/static/icons/*.jpg`, `!${srcPath}/static/icons/*.png`, `!${srcPath}/static/images/*.jpg`, `!${srcPath}/static/images/*.png`, ], lessPath: [ // less blob `${srcPath}/**/**/*.less`, ], jsPath: [ // js blob `${srcPath}/**/**/*.js`, ], wxmlPath: [ // wxml blob `${srcPath}/**/**/*.wxml`, ], jsonPath: [ // json blob `${srcPath}/**/**/*.json`, ], lessImportPath: [ `${srcPath}/common/less/*.less` ], iconPath: [ `${srcPath}/static/icons/*.jpg`, `${srcPath}/static/icons/*.png` ], imagePath: [ `${srcPath}/static/images/*.jpg`, `${srcPath}/static/images/*.gif`, `${srcPath}/static/images/*.png` ] } gulp 开发流程主要流程如下： gulp 的各个任务：（taskControler.js 文件） 每次进行 gulp 任务前都要清空 dist 打包后的目录。主要代码如下： task(&quot;clean:dist&quot;, done =&gt; { // console.log(&quot;:::: clean:dist&quot;); src(baseConfig.distPath, { read: true, allowEmpty: true, }) .pipe(clean()) done(); }) 但是，上面这样处理会有问题：第二次运行 gulp 命名的时候会有文件权限等问题。故：dist 文件的处理通过 nodejs 进行处理。 // gulp-clean 清空 dist 命令会有权限等一系列问题，故：直接用 node 进行删除 dist const path = require(&quot;path&quot;); const chalk = require(&quot;chalk&quot;); const rimraf = require(&quot;rimraf&quot;); const distPath = path.resolve(__dirname, &#39;../dist&#39;); rimraf(distPath, err =&gt; { if (err) { console.log(chalk.red(err)); } }) 然后在 package.json 中配置脚本命令： &quot;scripts&quot;: { &quot;build:dev&quot;: &quot;node gulpTask/clean.js &amp;&amp; gulp dev --development&quot;, &quot;build:prod&quot;: &quot;node gulpTask/clean.js &amp;&amp; gulp prod --production&quot; }, 这样每次执行 gulp 命令前都会删除 dist 目录。 处理 less 文件。需要解决的问题有： 开发环境不压缩代码，生产环境压缩代码； 自动添加属性前缀，autoperfixer； 将 less 文件的后缀更改为 wxss； 将 less 文件内部的 @import 引用文件的后缀更改为 wxss。 主要代码如下： task(&quot;compile:less&quot;, done =&gt; { // console.log(&quot;:::: compile:less&quot;); src(baseConfig.lessPath, { base: &quot;src&quot; }) .pipe(changed(baseConfig.distPath)) .pipe(gulpif(!this.isDev, cleanCss())) .pipe(autoprefixer()) // .pipe(less({ // paths: baseConfig.lessImportPath, // plugins: [autoprefix] // })) .pipe(rename(function (path) { // 更改 .less 文件后缀为 .wxss path.extname = &quot;.wxss&quot;; })) .pipe(replace(/\\.less/g, &quot;.wxss&quot;)) // 修改 less 文件内部的引用 .less 文件后缀为 .wxss .pipe(dest(baseConfig.distPath)); done(); }) 这里遇到一个坑，用 less-plugin-autoprefix @import 会有问题，@import 语句会被删除。后面改用 gulp-autoprefixer。 处理 js 文件。需要解决的问题有： eslint 代码格式检查； 开发环境不压缩代码，生产环境压缩代码； 主要代码如下： task(&quot;compile:js&quot;, done =&gt; { // console.log(&quot;:::: compile:js&quot;); src(baseConfig.jsPath, { base: &quot;src&quot; }) .pipe(changed(baseConfig.distPath)) // .pipe(babel({ // 先通过 babel 转化语法然后才能进行压缩 --&gt; 微信开发者工具有 es6 转 es5 功能 // presets: [&quot;@babel/env&quot;] // })) .pipe(eslint()) // .pipe(eslint.format()) .pipe(gulpif(!this.isDev, uglify())) .pipe(dest(baseConfig.distPath)); done(); }) 这里原本加了 babel 进行 es6 到 es5 的转化，但是微信开发者工具本身就有这个功能，故去除。另一个坑是，用 gulp-uglify 不能进行 es6 代码的压缩，要用 gulp-uglify-es 。 处理 wxml 文件。需要解决的问题有： 开发环境不压缩代码，生产环境压缩代码； 主要代码如下： task(&quot;compile:wxml&quot;, done =&gt; { // console.log(&quot;:::: compile:wxml&quot;); src(baseConfig.wxmlPath, { base: &quot;src&quot; }) .pipe(changed(baseConfig.distPath)) .pipe(gulpif(!this.isDev, htmlmin({ collapseWhitespace: true }))) .pipe(dest(baseConfig.distPath)); done(); }) 处理 json 文件。需要解决的问题有： 开发环境不压缩代码，生产环境压缩代码； 主要代码如下： task(&quot;compile:json&quot;, done =&gt; { // console.log(&quot;:::: compile:json&quot;); src(baseConfig.jsonPath, { base: &quot;src&quot; }) .pipe(changed(baseConfig.distPath)) .pipe(gulpif(!this.isDev, prettyData({ type: &quot;minify&quot;, preserveComments: true, extensions: { &quot;json&quot;: &quot;json&quot;, } }))) .pipe(dest(baseConfig.distPath)); done(); }) 其他所有文件。 主要代码如下： task(&quot;compile:other&quot;, done =&gt; { // console.log(&quot;:::: compile:other&quot;); src(baseConfig.otherPath, { base: &quot;src&quot; }) .pipe(changed(baseConfig.distPath)) .pipe(dest(baseConfig.distPath)); done(); }) 图片压缩。 主要代码如下： task(&quot;minify:image&quot;, async done =&gt; { // console.log(&quot;:::: minify:image&quot;); src(baseConfig.imagePath, { base: &quot;src&quot; }) .pipe(imagemin([imagemin.optipng(), imagemin.gifsicle(), imagemin.jpegtran()])) .pipe(dest(baseConfig.distPath)) done(); }) 开发环境开启监控 watch。 主要代码如下： task(&quot;watch&quot;, done =&gt; { // console.log(&quot;:::: compile:other&quot;); watch(baseConfig.basePath, { base: &quot;src&quot; }, series(&quot;compile:less&quot;, &quot;compile:js&quot;, &quot;compile:wxml&quot;, &quot;compile:json&quot;, &quot;compile:other&quot;, &quot;minify:image&quot;)) done(); }) 最后，将任务进行 id 绑定处理，还有不同环境的区分。主要代码如下： task(&quot;default&quot;, parallel(&quot;compile:less&quot;, &quot;compile:js&quot;, &quot;compile:wxml&quot;, &quot;compile:json&quot;, &quot;compile:other&quot;, &quot;minify:image&quot;)); task(`dev-${id}`, series(&quot;default&quot;, &quot;watch&quot;)); task(`prod-${id}`, series(&quot;default&quot;)); gulp 入口文件处理：（gulpfile.js 文件）主要是对不同环境的区分，还有 taskControler.js 定义的各个任务进行引用。主要代码如下： const { task, series } = require(&quot;gulp&quot;); const TaskControler = require(&quot;./gulpTask/taskControler&quot;); // 项目 ID const id = require(&quot;./package.json&quot;).name || &quot;min-program&quot;; new TaskControler(id); /*---------- 相关的 gulp 任务 ----------*/ // dev 开发环境任务 task(&quot;dev&quot;, series(`dev-${id}`)); // prod 生产环境任务 task(&quot;prod&quot;, series(`prod-${id}`)); 接着，只需要执行 npm run build:dev或 npm run build:prod，然后将生成的 dist 目录丢到微信开发者工具即可。 路由封装 路由表文件 /** * 路由路径 */ const routerPath = { index: &quot;/pages/index/index&quot;, detail: &quot;/pages/detail/detail&quot;, } module.exports = routerPath; 路由逻辑处理 最后使用路由的方式为： app.Router.push({ path: &#39;detail&#39;, query: { name: &#39;Ertsul&#39;, age: 23 } }) 需要处理的问题有：路由参数转化为小程序的格式、有参无参路由。 路由参数转化为小程序的格式。 /** * 处理路由参数，拼接成字符串形式 * @param {*} queryObj ： 路由参数 */ function dealQuery(queryObj) { let tempArr = []; for (let key in queryObj) { if (queryObj.hasOwnProperty(key)) { const value = queryObj[key]; const item = `${key}=${value}`; tempArr.push(item); } } return &quot;?&quot; + tempArr.join(&quot;&amp;&quot;); } 封装一个对象，添加 push 对外暴露的方法，添加内部跳转的方法。 let Router = { /** * * @param {String} param0 : 路径 * @param {Object} param1 : 参数 * @param {String} param2 : 类型，redirectTo/reLaunch/back/navigateTo */ push({ path = &quot;&quot;, query = {}, type = &quot;navigateTo&quot; }) { if (!path) { return; } // 获取对应的小程序路径 let url = routerPath[path] || routerPath[&#39;index&#39;]; let params = &quot;&quot;; // 处理 query if (Object.keys(query) &amp;&amp; Object.prototype.toString.call(query) == &#39;[object Object]&#39;) { params = dealQuery(query); } else { console.error(&quot;路由参数类型错误！&quot;); return; } url += params; this.to(url, type); // 执行跳转 }, /** * * @param {*} url : 路径 + 参数 * @param {*} type : 类型，redirectTo/reLaunch/back/navigateTo */ to(url, type = &quot;&quot;) { switch (type) { case &quot;redirectTo&quot;: wx.redirectTo({ url }); break; case &quot;reLaunch&quot;: wx.reLaunch({ url }); break; case &quot;back&quot;: wx.navigateBack({ delta: 1 }); break; case &quot;navigateTo&quot;: wx.navigateTo({ url }); break; } } } 最后将 Router 对象挂载到 app 对象。 const Router = require(&quot;./router/router&quot;); //app.js App({ Router, ... }) http 封装及其接口统一管理http 封装，可以添加一些请求公共参数等。核心代码为： function request({ url = &#39;&#39;, data = {}, method = &#39;POST&#39;, header = { &#39;content-type&#39;: &#39;application/json&#39; // 默认值 } }) { return new Promise(async (resolve, reject) =&gt; { wx.request({ url, data, method, header, success(res) { resolve(res); }, fail(err) { reject(err); } }) }) } 接口统一管理。接口统一管理有利于后期维护。 const request = require(&#39;../http/request&#39;); const baseConfig = require(&#39;../http/baseConfig&#39;); // get 例子 const getList = request({ method: &#39;GET&#39;, url: baseConfig.baseUrl + &#39;/list?page=1&amp;size=10&#39;, }) // post 例子 const updateInfo = request({ method: &#39;POST&#39;, url: baseConfig.baseUrl + &#39;/updateInfo&#39;, data: { name: &#39;Ertsul&#39;, age: 23 } }) module.exports = { getList, updateInfo }","categories":[{"name":"minapp","slug":"minapp","permalink":"https://ertsul.github.io/categories/minapp/"}],"tags":[{"name":"minapp","slug":"minapp","permalink":"https://ertsul.github.io/tags/minapp/"}]},{"title":"Git 操作（补充）","slug":"Git-操作（补充）","date":"2019-10-12T14:10:08.000Z","updated":"2021-03-28T09:03:18.954Z","comments":true,"path":"2019/10/12/Git-操作（补充）/","link":"","permalink":"https://ertsul.github.io/2019/10/12/Git-操作（补充）/","excerpt":"","text":"cherry-pickcherry-pick 可以将分支 B 的任何一个 commit 合并到分支 A。 情景：dev 分支有两个 commit，分别是：创建 b.txt 文件 commitB、创建 c.txt 文件 commitC。现在我们只想要合并 commitAB 到 master 分支。下面是 master 和 dev* 两个分支的情况： 如果直接用 git merge 会将 commitC 也合并到 master，这不是我们想要的结果。这时候，cherry-pick 就派上用场了。用法如下： 切换到目标分支。 cherry-pick 待合并的 commitID。 上面的情景，只需要： git checkout master git cherry-pick 8f2aa26 结果如下： 不过，cherry-pick 只能合并单个指定的 commit。☞ cherry-pick 更多操作 rebaserebase变基 是 Git 中整合来自不同分支修改的一种操作。（另一种是 merge） 情景1：dev 分支有两个 commit ，分别是：创建 d.txt 文件 commitD、创建 e.txt 文件 commitE。现在我们想要将 dev 分支的所有 commit 合并到 master。下面是 dev 分支的情况： 想要通过 rebase 变基将 commit 合并到 master，只需要： 将 dev 分支变基到 master 分支。 切换到 master 分支。 执行 merge 操作。 git rebase master git checkout master git merge --no-ff dev 最后结果如下： 通过 rebase 合并分支跟 merge 合并是不一样的。☞ 点击查看区别) 情景2：dev 分支上有四个 commit，顺序分别是：创建 f.txt 文件 commitF、增加 f.txt 文件内容 commitF1、创建 g.txt 文件 commitG、增加 g.txt 文件内容 commitG1。现在只想要将 dev 分支上关于文件 f.txt 的所有操作合并到 master 分支。下面是 dev 分支的情况： 现在只想要将 dev 分支上关于文件 f.txt 的所有操作合并到 master 分支，需要： 以 f.txt 的最后一个修改的 commitID 新建一个分支 dev-temp。 将以 dev-temp 分支上关于 f.txt 的第一个修改的 commitID rabase 变基到 master 分支。 切换到 master 分支。 merge dev-temp 分支到 master 分支。 git checkout -b dev-temp 884c858 git rebase --onto master 3b0bfd7^ git checkout master git merge --no-ff dev-temp 情景3：dev 分支上有四个 commit，顺序分别是：创建 i.txt 文件 commitI、增加 i.txt 文件内容 commitI1、创建 j.txt 文件 commitJ、增加 j.txt 文件内容 commitJ1。现在只想要将 dev 分支上关于文件 j.txt 的所有操作合并到 master 分支。下面是 dev 分支的情况：（其实跟上面的情况和操作一样） 现在只想要将 dev 分支上关于文件 j.txt 的所有操作合并到 master 分支，需要： 以 j.txt 的最后一个修改的 commitID 新建一个分支 dev-temp1。 将以 dev-temp1 分支上关于 j.txt 的第一个修改的 commitID rabase 变基到 master 分支。 切换到 master 分支。 merge dev-temp1 分支到 master 分支。 git checkout -b dev-temp1 54ea4bd git rebase --onto master e31249b^ git checkout master git merge --no-ff dev-temp1 rebase更多操作) 合并多个 commit 为一个 commit合并多个 commit 为一个 commit 同样需要 rebase。 如下图：要将最新的两个 commit 合并为一个 commit。具体操作如下： 找到这三个 commit 的前一个 commit 的 commitID，执行 git rebase -i commitID 这时候会进入 vi 编辑。 pick 的意思是要会执行这个 commit squash 的意思是这个 commit 会被合并到前一个 commit 之后会进入 vi 编辑 commit 信息。只需要将原先的 commit 信息注释，在顶部添加新的 commit 信息。 完成。 删除分支删除分支包括删除本地分支和远程分支： 删除本地分支 如本地分支不是打开状态，则：git branch -d branchName 如本地分支是打开状态，则：git branch -D branchName 删除远程分支 git push origin --delete branchName 恢复分支恢复分支，我们只需要以之前分支的 commitID 新开一个分支即可。 如果不记得 commitID，可以通过 git reflog 进行查看。 撤销本地修改 撤销指定本地文件的修改（未提交状态）：git checkout -- fileName 撤销本地的所有修改（未提交状态）：git reset --hard 其他基本操作 生成本地的 key，并添加到远程仓库 ssh-keygen -t rsa 初始化本地目录 git init 添加到本地仓库 git add filename 提交到仓库（git 提交的是修改） git commit -m &quot;description&quot; 查看仓库状态 git status 查看不同点 git diff filename 版本回退 git reset --hard 第一分支 master 创建分支 v1 （HEAD 指向当前分支） // 创建并指向新分支 git checkout -b v1 // 分步执行 git branch v1 git checkouut v1 合并到当前分支 git merge v1 删除指定分支 git branch -d v1 指定分支将远程仓库的代码拉到本地 git clone gitAddress -b branchName 将本地的代码提交到远程仓库 git pull //获取最新的更改 git add modefied_filename git commit -m &quot;description&quot; git push // 推送 冲突解决可以用上面的方法解决就解决，不行的话就用下面的方法： 用远程仓库的代码完全覆盖本地代码。 git reset --hard // 版本回退 git pull 修改 commit 提交的内容 git commit --amend 打印 log 数量 git log -p -3 文件被添加到暂存区，撤销该文件到工作目录 git reset HEAD fliename 工作目的删除文件后，还有在暂存区中删除该文件 rm filename git rm filename 撤销对当前文件的修改，恢复到上一次快照的状态 git checkout -- filename HEAD 指针指向当前的分支，提交后都会快进（fast-forward ：指针右移）。 rebase 合并分支变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 git checkout dev ......修改...... git add filename git commit -m &quot;......&quot; git rebase master git checkout master git merge dev","categories":[{"name":"Git","slug":"Git","permalink":"https://ertsul.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ertsul.github.io/tags/Git/"}]},{"title":"Git 操作","slug":"Git-操作","date":"2019-10-12T13:55:55.000Z","updated":"2021-03-28T09:03:14.767Z","comments":true,"path":"2019/10/12/Git-操作/","link":"","permalink":"https://ertsul.github.io/2019/10/12/Git-操作/","excerpt":"","text":"想必每个开发者对Git并不陌生，先来看看官方对于Git的定义： Git是一个免费和开源的分布式版本控制系统，旨在快速和有效率地处理从大到小的项目。 安装 Git 和查看 Git 版本 安装（仅说明在 Linux 系统下的安装，若您是windows系统，直接官网下载安装就行~） sudo apt install git 由于我之前已经安装过了，所以这里升级等都是 0。 查看是否安装成功 git 输入git命令后，出现一系列关于Git的参数和命令等，说明安装成功了。 查看 Git 版本 git --version 创建 Git 仓库所谓 Git 仓库（repository），也叫版本库。简单理解，就是可以被 Git 管理（修改，删除等）的目录。 新建本地目录，并切换到新目录 mkdir gitFile cd gitFile 将本地目录初始化为 Git 仓库 git init 查看 Git 仓库的目录 ls -al 您会发现，这里多了一个 .git 的目录，作用是 Git 来跟踪管理 Git 仓库的；注意，如果输入的命令是 ls 是不会看到 .git，因为这个目录默认是隐藏的。 将文件放到Git仓库（一定要在 git init 的目录／子目录下） 新建 test.txt 文件并输入内容 cat &gt; test.txt 将 test.txt 文件上传到Git仓库 git add test.txt 告知 Git 仓库提交了新文件，并添加标注信息 git commit -m &quot;My first git.&quot; -m 后面是 commit 信息。很简单吧～只需要两步，就可以将文件上传到Git仓库。 查看 Git 仓库的当前状态 git status 倘若修改了文件，但没有提交，结果是这样的： 提交后的结果是这样的： 查看文件修改内容如果修改了文件，但还没提交，可以对比文件前后的修改内容。 git diff test.txt 可知，文件 test.txt 添加了新的一行 This is the third line. 创建GitHub账号如果没有 GitHub 账号，得先到GitHub官网注册账号。注册登录为常规操作，不多说。 SSH设置由于Git和GitHub之间是通过SSH加密传输的，所以需要进行SSH设置。 创建SSH Key（用户主目录） ssh-keygen -t rsa -C &quot;你的邮箱&quot; 接下来回车默认就好了。 在用户主目录下找到 .ssh 目录 ls -al | find -name &quot;*.ssh&quot; 发现存在 .ssh 目录，切换到 .ssh 目录，发现文件中秘钥有 id_rsa（私钥）和 id_rsa.pub（公钥），其中是 id_rsa.pub 是我们所需要的 打开 ip_rsa.pub ，并复制 cat ip_rsa.pub 在 GitHub 中添加 SSH Key Settings-&gt;SSH and GRG keys-&gt;new SSH key 创建成功后，跳转页面中你会看到你新建的ssh key 创建 GitHub 仓库 登录GitHub账号后，创建新的仓库，仓库名称看自己需要命名，其他默认就好了。我这里为了测试，就取为test GitHub仓库创建成功后，会有SSH和HTTPS地址 Git 连接 GitHub，并推送本地文件到远程仓库 在本地仓库的目录 gitFile 下运行命令 git remote add origin 仓库的SSH地址 注意，这里的 origin 是远程仓库的名字（Git的默认叫法） 将本地仓库 Git 的文件推送到远程仓库 GitHub git push -u origin master 不出意外，在GitHub的 test 仓库中会看到我们传送的文件 从 GitHub 中克隆文件到本地 在 GitHub 中创建文件，并且复制SSH 地址 输入以下克隆命令 git clone SSH地址 你会发现，GitHub 中的目录包括你刚才新建的文件都存在本地目录中了。","categories":[{"name":"Git","slug":"Git","permalink":"https://ertsul.github.io/categories/Git/"}],"tags":[{"name":"Git","slug":"Git","permalink":"https://ertsul.github.io/tags/Git/"}]},{"title":"防抖和节流","slug":"防抖和节流","date":"2019-02-18T13:34:34.000Z","updated":"2020-01-01T16:09:41.798Z","comments":true,"path":"2019/02/18/防抖和节流/","link":"","permalink":"https://ertsul.github.io/2019/02/18/防抖和节流/","excerpt":"","text":"防抖 对于一些高频触发操作的场景，我们需要加防抖操作。比如：监听页面滚动、输入实时显示搜索结果等。这些都需要加防抖操作，不然对页面性能有很大的副作用。 简单概括：防抖就是将高频操作优化为最后一次执行。 实现： function debounce(fn, wait, immediate = false) { var timeout, result; timeout &amp;&amp; clearTimeout(timeout); var debounced = function () { var context = this; var args = arguments; if (immediate) { // 事件停止触发后 n 秒，触发事件立刻执行回调 var callNow = !timeout; timeout = setTimeout(function () { timeout = null; }, wait) if (callNow) { result = fn.apply(context, args); } } else { // 事件停止触发后，执行回调函数 timeout = setTimeout(function () { fn.apply(context, args); }, wait); } } debounced.cancel = function () { clearTimeout(timeout); timeout = null; } return debounced; } 节流每段时间后执行一次，将高频转化为低频。 时间戳 function throttle(fn, wait) { var previous = 0; return function () { var args = arguments; var context = this; var now = +new Date(); if (now - previous &gt; wait) { fn.apply(context, args); previous = now; } } } 定时器 function throttle(fn, wait) { var timeout; return function() { var args = arguments; var context = this; if (!timeout) { timeout = setTimeout(function() { timeout = null; fn.apply(context, args); }, wait) } } }","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"js","slug":"frontEnd/js","permalink":"https://ertsul.github.io/categories/frontEnd/js/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"vue-cli3.0项目创建+配置+自动部署","slug":"vue-cli3-0项目创建-配置-自动部署","date":"2019-02-17T14:09:53.000Z","updated":"2019-11-11T15:36:52.886Z","comments":true,"path":"2019/02/17/vue-cli3-0项目创建-配置-自动部署/","link":"","permalink":"https://ertsul.github.io/2019/02/17/vue-cli3-0项目创建-配置-自动部署/","excerpt":"","text":"创建项目 安装 vue3.0 脚手架 npm install -g @vue/cli 创建项目 vue create my_project 一系列选择之后，可以保存你当前的选择配置，之后创建项目的时候就可以直接用了。 安装依赖 cd my_project 最后的项目目录结构如下： 运行项目vue3.0 运行项目主要有两种方式： 命令行方式： npm run serve UI视图方式，这也是3.0版本的一大亮点。通过UI视图方式，可以帮助我们很多事，如：运行项目、安装依赖、安装插件等。 vue ui webpack 配置vue 已经帮我们配置了很多，额外自己又添加了一些配置；在根目录添加 vue.config.js 配置文件： const path = require(&#39;path&#39;); const px2rem = require(&#39;postcss-px2rem&#39;); const VconsoleWebpackPlugin = require(&#39;vconsole-webpack-plugin&#39;); const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;); // 判断是否为生产环境 const isProduction = process.env.NNODE_ENV === &#39;production&#39;; // 路径处理函数 const resolve = name =&gt; path.resolve(__dirname, name); module.exports = { publicPath: isProduction ? &#39;/production&#39; : &#39;/&#39;, // 部署应用包时的基本 URL productionSourceMap: !isProduction, // 生产环境不开启 source-map devServer: { // webpack-dev-server 的配置 port: 8089, // 本地端口 open: true, // 自动打开浏览器 // proxy: { // 代理 // &#39;/api&#39;: { // target: &#39;&lt;url&gt;&#39;, // ws: true, // changeOrigin: true // }, // } }, css: { extract: isProduction, // 生产环境将 css 单独抽离成一个文件 sourceMap: !isProduction, // 生成环境不开启 source-map loaderOptions: { postcss: { // 移动端使用rem plugins: [ px2rem({ remUnit: 75 }) ] }, // 全局共享variables.scss sass: { // @/ 是 src/ 的别名 // 所以这里假设你有 `src/variables.scss` 这个文件 data: `@import &quot;@/variables.scss&quot;;` } } }, configureWebpack: config =&gt; { const devPlugins = [ new VconsoleWebpackPlugin({ // 微信移动端调试控制台 enable: !isProduction }) ]; const prodPlugins = [ new TerserWebpackPlugin({ terserOptions: { // 打包时候的配置 warnings: false, compress: true, drop_console: true, drop_debugger: true, pure_funcs: [&#39;console.log&#39;] } }) ]; if (isProduction) { // 生产环境 config.optimization.minimizer = [ ...config.optimization.minimizer, ...prodPlugins ] } else { // 开发环境 config.plugins = [...config.plugins, ...devPlugins] } }, chainWebpack: config =&gt; { // 自定义全局变量 // config // .plugin(&#39;define&#39;) // .tap((args) =&gt; { // args[0].PRODUCTION = isProduction ? JSON.stringify(&#39;&#39;) : // JSON.stringify( // &#39;other/&#39;, // ); // return args; // }); // 别名设置 config.resolve.alias .set(&#39;js&#39;, resolve(&#39;src/assets/js&#39;)) .set(&#39;scss&#39;, resolve(&#39;src/assets/scss&#39;)) .set(&#39;images&#39;, resolve(&#39;src/assets/images&#39;)) .set(&#39;components&#39;, resolve(&#39;src/components&#39;)); } } 路由配置vue3.0 的路由配置已经很完善了，这里我仅仅小改动，封装了路由懒加载函数： import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import Home from &#39;./views/Home.vue&#39; Vue.use(Router) // 路由懒加载 // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. const addRouterComponent = path =&gt; import(path); export default new Router({ mode: &#39;history&#39;, base: process.env.BASE_URL, routes: [{ path: &#39;/&#39;, name: &#39;home&#39;, component: Home }, { path: &#39;/about&#39;, name: &#39;about&#39;, component: addRouterComponent(&#39;./views/About.vue&#39;) } ] }) axios 的配置在 scr 目录下添加 api 目录，并新建两个文件：config.js 和 api.js。配置如下： config.js import axios from &#39;axios&#39;; import qs from &#39;qs&#39;; axios.defaults.withCredentials = false; // 请求拦截器 axios.interceptors.request.use( request =&gt; { request.data = request.data || {}; const hasHttp = /^http(|s):\\/\\//.test(request.url); if (!hasHttp) { // 无 http or https 头处理 request.url = `https://${request.url}`; } if (request.data) { request.data = { // commom: &#39;&#39;, 这里可以添加一些公共的请求参数 data: JSON.stringify(request.data) }; request.data = qs.stringify(request.data); } return request; }, error =&gt; Promise.reject(error) ); // 响应拦截器 axios.interceptors.response.use( response =&gt; { const responseData = response.data; if (responseData.errcode !== 0) { // 错误处理 return Promise.reject(responseData.msg || &#39;未知错误&#39;); } responseData.result = responseData.result || {}; return responseData; }, error =&gt; Promise.reject(error) ); export { axios }; api.js import { axios } from &#39;./config.js&#39;; // 例子 1 export const aApi1Name = params =&gt; axios.post(url, params); // 例子 2 export const aApi2Name = params =&gt; axios.get(url, params); 打包后自动部署到服务器使用的是 scp2；通过向脚本传递不同参数，部署到不同的服务器路径；在根目录添加 deploy.js 脚本。相关配置如下： package.json &quot;buildTest&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js development&quot;, &quot;buildProd&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js production&quot; deploy.js const qs = require(&#39;qs&#39;); // 判断是否输出帮助信息 const helpMessage = `usage: node deploy.js [deploy_target]`; if ( process.argv.length !== 3 || process.argv[2] === &#39;-h&#39; || process.argv[2] === &#39;--help&#39; ) { console.log(helpMessage); process.exit(0); } // 判断是否是生产环境 const isProduction = process.argv[2] === &#39;production&#39;; // 设置部署的文件路径，正服 or 测服 let deployPath = &#39;&#39;; if (isProduction) { deployPath = &#39;/production&#39; } else { deployPath = &#39;/test&#39; } // 设置服务器服务器信息 const SERVER_INFO = { host: &#39;134.175.150.8&#39;, port: 22, username: &#39;&#39;, password: &#39;&#39;, path: deployPath } // 部署到服务器 client.scp(&#39;./dist/&#39;, SERVER_INFO, err =&gt; { if (err) { console.log(&#39;Deploy Failed!\\n&#39;, err); } }) console.log(`Deploy ${isProduction ? &#39;production&#39; : &#39;developemt&#39;} finished!`); 总结：通过上面的配置，基本可以实现 vue 项目从创建到配置到打包自动部署的过程。","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"Vue","slug":"frontEnd/Vue","permalink":"https://ertsul.github.io/categories/frontEnd/Vue/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"Vue","slug":"Vue","permalink":"https://ertsul.github.io/tags/Vue/"}]},{"title":"websocket","slug":"websocket","date":"2019-02-17T13:57:39.000Z","updated":"2019-11-11T15:36:59.393Z","comments":true,"path":"2019/02/17/websocket/","link":"","permalink":"https://ertsul.github.io/2019/02/17/websocket/","excerpt":"","text":"HTTP/HTTPS 协议 一个 request 对应一个 response。一般使用 轮询 机制获取信息。 虽然后期有 keep-alive，可以一次连接中处理多个 request 合并发送，接收多个 response，对每个请求仍然需要单独发 header。 HTTP 的 response 是被动的，通信只能由客户端发起，做不到服务端主动向客户端推送信息。 HTTP 是无状态协议。 需要三次握手。 HTTP：TCP + HTTP HTTPS：TCP + HTTP + TLS ajax 轮询ajax 轮询 是指客户端 不断 向服务器发送资源请求 request，服务端不管有无目标资源，都会返回 response 结果。这样就要求服务器拥有更好的处理速度。 long poll / 长轮询long poll 比 ajax 轮询 好点，不会不断 向服务器发送资源请求 request，一旦接受客户端的请求，有资源就返回；无资源就挂起，直到有资源才返回 response 结果（有且仅有返回一次）。高并发，需要服务器可以同时处理多个请求的能力。 websocket 协议 websocket 是 html5 出的协议。 websocket 是一个持久化的协议，websocket 只需要一次请求（一次 HTTP 握手 ），就可以得到所需的资源。 服务端可以 主动 向客户端推送信息，客户端也可以 主动 向服务端推送消息，实现“双向平等”，是属于服务器推送技术的一种。 与 HTTP 有较好的兼容性，在握手阶段采用 HTTP 协议。 默认端口 80 and 443。 数据格式轻量，性能开销小，通信高效，可以发送文本，也可以二进制数据。 没有同源策略。 WS：TCP + WS WSS：TCP + WS + TLS websocket 握手GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Upgrade/Connection：通知服务器发起的是 wesocket 协议。 Sec-WebSocket-Key：浏览器随机生成的 Base64 encode 的值，用于验证服务器是不是 websocket 协议。 Sec-WebSocket-Protocol：用户定义的字符串，用来区分 同 url 下，不同的服务所需要的协议。 Sec-WebSocket-Version：协议版本。 服务器返回HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat Upgrade/Connection：通知客户端升级的是 websocket 协议。 Sec-WebSocket-Accept：经服务器确认，加密后的 Sec-WebSocket-Key。 Sec-WebSocket-Protocol：最终使用的协议。 代码实现ws.addEventListener(&#39;open&#39;, function () { console.log(&#39;Open the websocket...&#39;); ws.send(&#39;Hello websocket...&#39;); }); ws.addEventListener(&#39;message&#39;, function (e) { console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Receive the websocket message...&#39; + e.data); ws.close(); setTimeout(() =&gt; { console.log(&#39;Ready state: &#39; + ws.readyState); }, 1000) }); ws.addEventListener(&#39;close&#39;, function () { console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Close the websocket...&#39;); }) 结果： 参考： https://www.zhihu.com/search?type=content&amp;q=websocket http://www.ruanyifeng.com/blog/2017/05/websocket.html","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"}]},{"title":"用户认证小总结","slug":"用户认证小总结","date":"2019-02-17T13:52:43.000Z","updated":"2019-11-11T15:36:28.594Z","comments":true,"path":"2019/02/17/用户认证小总结/","link":"","permalink":"https://ertsul.github.io/2019/02/17/用户认证小总结/","excerpt":"","text":"用户认证一般的用户认证流程如下图： 但是，这种模式的扩展性不好。单个服务器没问题，如果多个服务器集群，要求共享 session ，每个服务器都能访问到 session 。 解决方案一：session 数据持久化，写入数据库或者其他持久层。各个服务器收到请求后，向持久层发送数据请求。 缺点：工程量大。 解决方案二：服务器不保存 session 数据，所有的数据保存在客户端，每次请求都发回服务器。如：JWT(Json Web Token)。 JWTJWT 服务器不保存 session 数据，在服务器认证之后，返回一个 JSON 对象。格式如下： { &quot;姓名&quot;: &quot;zero&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2018年10月6日0点0分&quot; } 之后，客户端与服务器的用户认证都靠这个 JSON 对象，当然，这个对象后面会加上签名，保证数据不被篡改。 JWT 的数据结构 JWT 是一个很长的字符串，中间用 . 分隔，内部没有换行。 组成由三个部分：Header.Payload.Signature Header：头部。JSON 对象，描述 JWT 的元数据。 Payload：负载。JSON 对象，存放实际需要传递的数据；不加密。 Signature：签名。对 Header 和 Payload 的签名，防止数据被篡改。 Header 格式： { &quot;alg&quot;: &quot;HS256&quot;, // 签名的算法 &quot;typ&quot;: &quot;JWT&quot; // token 类型 } Payload 七个字段： iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 JWT 的使用方式 存储在 cookie 中。 存储在 localStorage 中。 客户端每次与服务器进行通信的时候，都会带上 JWT。 参考： http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"}]},{"title":"web safe","slug":"web-safe","date":"2019-02-17T13:41:10.000Z","updated":"2019-11-11T15:36:55.140Z","comments":true,"path":"2019/02/17/web-safe/","link":"","permalink":"https://ertsul.github.io/2019/02/17/web-safe/","excerpt":"","text":"CSRF : Cross Site Request ForgeryCSRF 跨站请求伪造。是一种劫持受信任用户向服务器发送非预期请求的攻击方式。简而言之：用户在登录的情况下访问了钓鱼网站，钓鱼网站通过用户向其他网站发送请求，这样就达到了模拟用户的目的。具体实现如下图： 防御手段 验证码实现用户验证。验证码强制用户必须与应用进行交互，才能完成最终的请求。 通过 referer 实现用户验证。根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的 来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。 通过 token 实现用户验证。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用 post 操作。 避免全站通用的 cookie，严格设置 cookie 的域。 XSS : Cross Site ScriptXSS 跨站脚本攻击。攻击者向用户的网站嵌入的 js 脚本代码，当用户访问该网站的时候，该 js 脚本代码就会被执行，从而达到攻击用户的目的。 反射型 XSS 攻击又称非持久性跨站脚本攻击。发出请求时，XSS 代码出现在 URL 中，作为输入提交到服务器端，服务器端解析后响应，XSS 随响应内容一起返回给浏览器，最后浏览器解析执行 XSS 代码。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。比如： http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！ 存储型 XSS 攻击XSS 提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交 XSS 代码。这种攻击方式的稳定性很好。比如： 攻击者在 value 填写&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;【或者 html 其他标签（破坏样式。。。）、一段攻击型代码】；将数据存储到数据库中；其他用户取出数据显示的时候，将会执行这些攻击性代码。 具体方式 攻击者向服务器注入 js 代码。 诱导用户访问受到攻击的网站。 用户访问受到攻击的网站，执行注入的 js 代码。 XSS 防御方式 HttpOnly 输入检查 输出检查 参考链接： https://www.cnblogs.com/shytong/p/5308667.html https://github.com/dwqs/blog/issues/68 https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label3","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"web-safe","slug":"frontEnd/web-safe","permalink":"https://ertsul.github.io/categories/frontEnd/web-safe/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"web-safe","slug":"web-safe","permalink":"https://ertsul.github.io/tags/web-safe/"}]},{"title":"Ajax和跨域总结","slug":"Ajax和跨域总结","date":"2019-02-16T16:00:28.000Z","updated":"2019-11-11T15:36:30.832Z","comments":true,"path":"2019/02/17/Ajax和跨域总结/","link":"","permalink":"https://ertsul.github.io/2019/02/17/Ajax和跨域总结/","excerpt":"","text":"Ajax（JavaScript实现）简介Ajax（Async Javascript And Xml）：异步Js和Xml，意思就是用Js执行异步网络请求。作用主要是在不重新加载全部网页的情况下，对部分页面进行更新。 创建XMLHttpRequest对象除了IE5和IE6不支持之外（支持ActiveXObject对象），几乎现在所有的有内建的XMLHttpRequest对象。所以在创建请求对象之前判断下就好了： let xhr = null; xhr = window.XMLHttpRequest ? new xmlHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) // 或者 if(window.XMLHttpRequest){ xhr = new XMLHttpRequest() }else{ xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;) } 通过open()和send()向服务器发送请求 xhr.open(method, url, async)这个方法的参数分别是：method请求的类型GET或者POST；URL请求的文件在服务器上的地址；async是否异步请求true或者false（一般不设置为false）。 xhr.send()：发送请求。 xhr.setRequestHeader(header, value)：如果是POST的话，要设置发送的HTTP头，然后通过send方法发送内容。参数分别是：发送的头部名称，头部的值。一般都是固定的。 // 向浏览器发送请求 xhr.open(&#39;GET&#39;, &#39;./server.php&#39;, true) // 添加HTTP头（POST方法） xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;) xhr.send() GET方法不需要参数，POST方法则需要把body参数；如果要想向服务器发送相关的参数，则通过open里面的第二个参数url进行发送，具体实现如下代码： url = &quot;./filePath?paramName=&quot; + paramValue + ...; 判断准备状态xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { ... } } xhr.onreadystatechange方法中，每当readyState改变时，就会触发xhr.onreadystatechange事件。 readyState属性：存有XMLHttpRequest的状态信息。0：请求未初始化；1：服务器链接已经建立；2：请求已经接受；3：请求处理中；4：请求已完成，且响应已就绪。一共有5个状态，所以onreadystatechange事件会被触发5次。 实际上onreadystateschange是通过回调函数实现的，即：每当readyState的状态改变时，这个回调函数就会被执行。 status属性：表示响应的结果。 总的代码如下： document.getElementById(&#39;btn&#39;).onclick = function () { // 创建请求对象（先判断浏览器类型） // var xhr = null; // if (window.XMLHttpRequest) { // xhr = new XMLHttpRequest() // } else { // xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;) // } xhr = (window.XMLHttpRequest) ? (new XMLHttpRequest()) : (new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)) // 判断响应状态并执行相关的操作 xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { let data = xhr.responseText console.log(data); document.getElementById(&#39;myDiv&#39;).innerText = data } } // 向浏览器发送请求 let url = &quot;./server.txt&quot; xhr.open(&#39;GET&#39;, url, true) // 添加HTTP头（POST方法） // xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;) xhr.send(null); } 但是，由于在同源策略的作用下，浏览器只能同源的其他域的资源，先看看什么是同源策略～ 同源策略/SOP（Same origin policy）来自百度的解释： 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能（防止CSRF/XSRF攻击：跨站请求伪造）。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。 简单来说，就是浏览器只能请求同源的其他域的资源，即同源的网页才能相互获取资源，而不能访问其他域的资源；但是有一个例外，同源策略不会阻止动态脚本插入到文档中；其中，\\是开放策略；当web网页执行一个脚本之前，会检查是否同源，只有同源才会被执行，非同源则会被拒绝访问。截取网上的图片说明同源： 跨域跨域就是突破同源策略的限制，获取其他源的资源。非同源主要有三种行为会受到限制： Cookie,LocalStorage和IndexDB无法读取。 DOM无法获取。 Ajax无法获取。 JSONPJSONP是实现跨域的常用方法，但是JSONP只能实现GET方法。实际上是是利用了浏览器允许跨域引用JavaScript资源（script标签是开放策略）。 下面举一个例子：我们从360浏览器首页的天气查询获取天气查询的异步请求地址；这里我们实现通过本地localhost服务器跨域请求360的天气查询，来说明JSONP怎么实现跨域。我们请求资源的地址为：https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600在浏览器中打开这个地址，我们会得到这样的数据：__jsonp21__({…})。解释：JSONP返回的通常是以函数的形式返回，前面这个__jsonp21__是函数名，所以我们需要在我们的代码中事先准备好名称为__jsonp21__的函数，我们对跨域请求到的数据就是放在这个函数中的，然后动态加载一个script节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。 具体代码如下： // 请求的地址为：https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600 function __jsonp21__(data) { // 将要处理了的数据放在这个函数中 console.log(data); // 得到的是跨域请求的数据 let myDiv = document.getElementById(&#39;myDiv&#39;) myDiv.innerHTML = data.area } window.onload = function () { let btn = document.getElementById(&#39;btn&#39;) btn.addEventListener(&#39;click&#39;, function () { let url = &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39; let scriptTag = document.createElement(&#39;script&#39;) // 动态创建script标签 scriptTag.setAttribute(&#39;src&#39;, url) // 将其他源的地址设置为动态script的src属性 // console.log(scriptTag); // 得到的是script标签 document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag) // 将动态创建的script标签添加到html页面中 }) } 注意：数据处理的函数名要跟跨域返回的函数名一样，这样我们通过JSONP请求数据的时候，服务器才能返回数据。最终结果如下： 再句一个例子：请求地址是http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice function refreshPrice(data) { console.log(data); } window.onload = function () { let scriptTag = document.createElement(&#39;script&#39;) let url = &#39;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&#39; scriptTag.setAttribute(&#39;src&#39;, url) document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag) } Ajax（JQuery实现）在JQuery中，实现Ajax主要是由$.ajax({…})方法实现。方法的常用参数有： async：是否实现异步加载，一般来说，是true。 type：GET或者POST。 url：发送请求的地址。 timeout：设置请求的超时时间。 success：请求成功后的回调函数。 error：请求失败后的回调函数。 jsonp：在一个JSONP请求中重写回调函数的名字，默认为callback，用来重新命名回调我们跨域请求时候的函数名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback：为JSONP请求指定一个回调函数名。 dataType：预期服务器返回的数据类型。不指定的话，JQueryhi自动判断。”xml”: 返回 XML 文档，可用jQuery处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行；”script”: 返回纯文本JavaScript代码。不会自动缓存结果。除非设置了”cache”参数。注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。（因为将使用DOM的 script标签来加载）；”json”: 返回JSON数据；”jsonp”: JSONP格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数；”text”: 返回纯文本字符串。 用JQuery实现同源的Ajax请求： $(function () { $(&#39;button&#39;).on(&#39;click&#39;, function () { $.ajax({ url: &#39;./server.txt&#39;, // 请求地址 type: &#39;GET&#39;, // 请求方式 async: true, // 是否异步 success: function (data) { console.log(data); } // 请求成功后执行的函数 }) }) }) 实现结果如下： 用JQuery实现非同源的JSONP跨域请求： $(function () { $(&#39;button&#39;).on(&#39;click&#39;, function () { $.ajax({ url: &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39;, type: &#39;GET&#39;, async: true, dataType: &#39;jsonp&#39;, jsonp: &#39;_jsonp&#39;, jsonpCallback: &#39;__jsonp21__&#39;, success: function (data) { console.log(data); $(&#39;#myDiv&#39;).html(data.area) }, error: function (err) { console.log(err); } }) }) }) 实现结果如下：","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"js","slug":"frontEnd/js","permalink":"https://ertsul.github.io/categories/frontEnd/js/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"3D立体骰子","slug":"3D立体骰子","date":"2019-02-16T15:58:03.000Z","updated":"2019-11-11T15:50:43.596Z","comments":true,"path":"2019/02/16/3D立体骰子/","link":"","permalink":"https://ertsul.github.io/2019/02/16/3D立体骰子/","excerpt":"","text":"CSS3确实很强大，很多高大上的动画都可以实现，这里来实现下3D立方体，效果图如下： html其实，实现3D立方体需要的html十分简单，只需要一个ul标签里面包裹6个li标签，分别用来表示3D立方体的6个面[ 前，下，后，上，左，右 ]。具体代码如下: &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; CSS3ul基本的宽高这些就不说了；作为整个3D立方体的父级元素，需要设置positiion属性为relative，还要最重要的是设置它的动画类型tranform-style为preserve-3d，这样就可以实现它的所有子元素都进行3d动画。 li宽高设置为100%，position属性设置为absolute。 前设置背景，并且沿着Z轴移动50px，即宽高的一半(为什么得添加这个, 后面用动画进行解释说明)。 下设置背景，沿着X轴旋转-90deg，作为底面，同样，并且沿着Z轴移动50px。 后设置背景，沿着X轴旋转-180deg，作为后面，同样，并且沿着Z轴移动50px。 上设置背景，沿着X轴旋转90deg，作为上面，同样，并且沿着Z轴移动50px。 左设置背景，沿着Y轴旋转-90deg，作为左面，同样，并且沿着Z轴移动50px。 右设置背景，沿着Y轴旋转90deg，作为右面，同样，并且沿着Z轴移动50px。 结尾说明这里说明上面那个translate，先来看看如果不添加这个属性是怎样的效果：可见，所有的面都交集于立方体的中心点。由于未对6个面作任何动画处理的时候，所有的面都集合在一起。所以在面作旋转的同时需要对其进行Z轴的位移处理。 代码&lt;style&gt; * { margin: 0; padding: 0; } body { background-color: black; } ul { list-style: none; width: 100px; height: 100px; position: relative; cursor: pointer; margin: 150px auto; transition: 1s; /* 设置过渡时间 */ transform-style: preserve-3d; /* 设置所有的子元素实现3D动画 */ } /* 设置鼠标悬停的动画 */ ul:hover { transform: rotateX(120deg) rotateY(120deg); } ul li { width: 100%; height: 100%; text-align: center; line-height: 100px; font-size: 40px; font-weight: 700; position: absolute; top: 0px; } /* 前 */ ul li:nth-child(1) { background-color: rgba(225, 0, 0, .4); transform: rotateX(0deg) translateZ(50px); } /* 下 */ ul li:nth-child(2) { background-color: rgba(0, 255, 0, .4); transform: rotateX(-90deg) translateZ(50px); } /* 后 */ ul li:nth-child(3) { background-color: rgba(0, 0, 255, .4); transform: rotateX(-180deg) translateZ(50px); } /* 上 */ ul li:nth-child(4) { background-color: rgba(125, 125, 0, .4); transform: rotateX(90deg) translateZ(50px); } /* 左 */ ul li:nth-child(5) { background-color: rgba(0, 125, 125, .4); transform: rotateY(-90deg) translateZ(50px); } /* 右 */ ul li:nth-child(6) { background-color: rgba(10, 45, 36, .4); transform: rotateY(90deg) translateZ(50px); } &lt;/style&gt;","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"css","slug":"frontEnd/css","permalink":"https://ertsul.github.io/categories/frontEnd/css/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"css","slug":"css","permalink":"https://ertsul.github.io/tags/css/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2019-02-16T15:56:55.000Z","updated":"2019-11-11T15:36:34.048Z","comments":true,"path":"2019/02/16/DOM事件/","link":"","permalink":"https://ertsul.github.io/2019/02/16/DOM事件/","excerpt":"","text":"事件事件就是用户或者浏览器进行的特定行为，比如：鼠标点击事件。 事件名称比如：click就是一个事件名。 事件流的执行过程事件流：指的是 DOM 事件流（多个事件按照一定顺序执行），DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。事件流的执行过程：从window开始，最后回到window。事件流被分为三个阶段：事件捕获（1-5），事件触发（5-6），事件冒泡（6-10）。 来自网上的图片： 事件冒泡来自百度的解释： 当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。 就比如：我们用button产生一个click事件，但是由于button按钮本身可能不能处理这个事件，就要开始传播出去这个事件。实现事件冒泡的条件是：元素之间有嵌套，每个元素都有相同的事件，这样当最里层的事件触发时，这个事件就会一级一级向上传播，也就是”冒泡“。 举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。这样，当里层点击事件触发时，外层的点击事件也会被触发。 &lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; window.onload = function () { let inner = document.getElementById(&#39;inner&#39;) let outer = document.getElementById(&#39;outer&#39;) inner.addEventListener(&#39;click&#39;, function (e) { console.log(&#39;inner&#39;); }) outer.addEventListener(&#39;click&#39;, function () { console.log(&#39;outer&#39;); }) } &lt;/script&gt; 结果为： 阻止事件冒泡 一般浏览器：event.stopPropagation() IE浏览器：event.cancelBubble = true 阻止默认事件 一般浏览器：event.preventDefault() IE浏览器：event.returnValue = false addEventListener的第三个参数addEventListener方法用于将事件和函数进行绑定，函数为：addEventListener(event, fn, useCapture)，这些参数分别是：事件名，事件处理函数，第三个参数 useCapture 是一个布尔值，用来设置该事件的执行是在哪个阶段发生的（默认是在冒泡阶段）。 true：表示该事件是在“事件捕获阶段”触发的。（由外向内） false：表示该事件是在“事件冒泡阶段”触发的。（由内向外） 举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。 将第三个参数设置为true，事件在 捕获阶段 执行： &lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; window.onload = function () { let inner = document.getElementById(&#39;inner&#39;) let outer = document.getElementById(&#39;outer&#39;) inner.addEventListener(&#39;click&#39;, function (e) { console.log(&#39;inner&#39;); }, true) outer.addEventListener(&#39;click&#39;, function () { console.log(&#39;outer&#39;); }, true) } &lt;/script&gt; 由于是 捕获阶段 执行，即：由外向内执行，所以结果为： outer inner。 结果为： 将第三个参数设置为false，事件在 冒泡阶段 执行，输出结果为： inner outer。 事件处理函数/事件监听函数事件触发后的处理函数。如：btn.onclick = fn，fn就是事件处理函数/事件监听函数。 HTML事件处理程序例如： &lt;button onclick = &quot;fn()&quot;&gt;click&lt;/button&gt; 这种方式的缺点是：结构和行为耦合在一起。 DOM0级事件处理程序形式为：ele.on + ‘事件名称’ = 事件处理函数例如： ele.onclick = function() {…}，this指向当前元素。 DOM2级事件处理程序这种方式主要是通过这两个方法：addEventListener()，removeEventListener()这种方式的优点就是：可以同一个事件处理程序绑定多个事件处理函数。 事件委托事件委托要处理的问题是：解决事件处理程序过多的问题。简单来说，就是将很多个事件处理程序委托给一个事件处理程序，通过这个事件处理程序来管理这么多个事件处理程序。好处：减少对DOM的访问，提高性能；可以对后来添加进来的元素也能绑定委托事件。 例如：在一个 ul 标签中有很多个 li 标签，我们的需求而是点击每一个 li 标签显示每一个 li 标签的内容。如果没有使用事件委托，我们需要给每一个 li 标签都添加事件监听函数，很明显，这样的效率并不高，而且对整个网页的性能也会影响；如果我们使用事件委托，将这些 li 的事件委托给 ul 标签，这样就可以只用一个事件监听函数实现。 代码如下： &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;111111&lt;/li&gt; &lt;li&gt;222222&lt;/li&gt; &lt;li&gt;333333&lt;/li&gt; &lt;li&gt;444444&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; window.onload = function () { // 传统的方法 // let lis = document.getElementsByTagName(&#39;li&#39;) // console.log(lis); // for(let i = 0; i &lt; lis.length; i++){ // lis[i].addEventListener(&#39;click&#39;, function () { // console.log(this.innerHTML); // }) // } // 使用事件委托 let list = document.getElementById(&#39;list&#39;) list.addEventListener(&#39;click&#39;, function (e) { let target = e.target console.log(target.innerHTML); }, false) } &lt;/script&gt; 事件委托一般使用的是 事件冒泡阶段 进行（虽然事件捕获阶段也可以），因为事件冒泡的事件流模型被所有的主流浏览器兼容，事件冒泡的兼容性更好。","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"js","slug":"frontEnd/js","permalink":"https://ertsul.github.io/categories/frontEnd/js/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"px/em/rem总结","slug":"px-em-rem总结","date":"2019-02-16T15:55:21.000Z","updated":"2019-11-11T15:36:50.594Z","comments":true,"path":"2019/02/16/px-em-rem总结/","link":"","permalink":"https://ertsul.github.io/2019/02/16/px-em-rem总结/","excerpt":"","text":"px对于px，大家都不陌生。它是一个相对于屏幕的相对长度单位。 emem也是一个相对长度单位，但它相对的是父级元素的字体大小。对于em有一个推算过程：如果没有定义自己的font-size，则：浏览器默认：1em = 16px所以：12px = 0.75em10px = 0.625em但是如果每次都这样进行计算很麻烦，而且开发效率也很低，因此为了简化计算，我们将浏览器的font-size设置为62.5%，这样：1em = （16px * 62.5%） = 10px； 1.2em = 12px依次类推，要使用em这个相对长度单位，只要我们在body标签里面设置了font-size为62.5%，这样只要就可以得到计算公式：(n)px = (n \\ 10)em 但是，em单位是相对的，不是固定的，是逐级继承的（一层一层向上计算），举个例子：比如，一个div里面嵌套了一个div，这两个div都设置了font-size为1.2em，浏览器的font-size设置为62.5%，此时，最里层的div的font-size大小是：（1.2 * 1.2） = 1.44em。 remrem也是相对长度单位，从它的单位也可以看出，它跟em比较，多了个 r 字母，它的意思就是root（根）的意思。简单来说，就是它是相对于根节点（html标签）的font-size而言的。这样子，就消除了em单位逐级继承的缺点。举个例子：先将html标签设置为62.5%，这样，html里面的任何子标签都是继承于这个标签，也就是说相对于这个标签。所以，不论标签中有多少级的嵌套，最里层标签的font-size的计算公式永远是：(n)px = (n \\ 10)rem","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"css","slug":"frontEnd/css","permalink":"https://ertsul.github.io/categories/frontEnd/css/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"css","slug":"css","permalink":"https://ertsul.github.io/tags/css/"}]},{"title":"js的原型和继承","slug":"js的原型和继承","date":"2019-02-16T15:54:24.000Z","updated":"2019-11-11T15:36:48.400Z","comments":true,"path":"2019/02/16/js的原型和继承/","link":"","permalink":"https://ertsul.github.io/2019/02/16/js的原型和继承/","excerpt":"","text":"原型模式原型模式在《JavaScript高级程序设计》中的定义： 我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用这个对象的好处就是可以让所有对象实例共享它包含的属性和方法。 这里还有一个__proto__属性，每一个对象都拥有这个属性，这个属性指向对应的构造函数的prototype属性。 通过原型对象，我们就不用将信息添加到构造函数中了。 实例对象共享原型对象的属性function Person(){} Person.prototype.name = &#39;A&#39; Person.prototype.age = 1 // 实例对象共享原型对象的属性 let p1 = new Person() console.log(p1.name, p1.age); // A 1 let p2 = new Person() console.log(p2.name, p2.age); // A 1 constructor（构造函数）属性每个原型对象在默认情况下都会自动获取一个constructor（构造函数）属性，这个属性包含一个指针，指向这个原型所在的函数。在上面的例子中，创建Person函数后，它的prototype指向它的原型对象，这个原型对象就会获取获取constructor属性，指向Person函数。 判断实例对象与原型对象之间的关系 Obj.prototype.isPrototypeOf(obj) console.log(Person.prototype.isPrototypeOf(p1)) // true Object.getPrototypeOf(obj)：返回对象实例的原型[es5] console.log(Object.getPrototypeOf(p1) == Person.prototype); // true console.log(Object.getPrototypeOf(p1).name); // A obj.hasOwnPrototype(attr)：检测一个属性是否存在于实例中。只有当实例对象重写原型对象的属性后（非原型属性）才会返回true。 console.log(p1.hasOwnProperty(&#39;name&#39;)); // false p1.name = &#39;Ertsul&#39; console.log(p1.hasOwnProperty(&#39;name&#39;)); //true in操作符：通过in操作符和hasOwnProperty()可以判断某属性存在于实例还是原型对象中【in判断是否存在属性，hasOwnProperty()判断存在于哪里。】可以单独使用和for-in循环使用：无论属性属于实例还是原型中，都会返回true。(‘name’ in person1) 获取所有实例的属性名字，无论是否可以枚举。 console.log(Object.getOwnPropertyNames(p1)); // [&quot;name&quot;] instanceof console.log(p1 instanceof Person); // true 更简单的语法function Person() { } Person.prototype = { name: &#39;001&#39; } let p1 = new Person() console.log(p1.name); 这里的例外是：constructor属性不再指向Person；本质上相当于完全重写了Person对象了。注：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。[详见《JavaScript高级程序设计》P156-P157，原型的动态性] ####搜索机制 解释器会现在目标对象中搜索目标属性，如果当前对象没有目标属性，解释器继续在目标对象的原型对象中搜索。 通过delete只能删除对象的属性，而不能删除原型对象中的属性。 组合模式（默认类型）：构造函数模式 + 原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 继承原型链// 父亲 function Father() { this.fatherProperty = true } Father.prototype.getFatherValue = function () { return this.fatherProperty } // 儿子 function Son() { this.sonProperty = false } // 继承父亲：通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性 Son.prototype = new Father() Son.prototype.getSonValue = function () { return this.sonProperty } let instance = new Son() console.log(instance.fatherProperty); // true 上面例子中，通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性。（重写儿子的原型）。这里，儿子原型对象的[[prototype]]（注：不是prototype，[[prototype]]存在于原型中）指向的是父亲的原型对象，而父亲的原型对象的[[prototype]]指向的是Object Prototype。（由于所有函数的默认原型都是Object的实例，所以默认原型都会包含一个内部指针，指向Object.prototype） 借用构造函数 主要是为了解决因为引用类型值的原型属性会被所有实例共享的问题。 借用构造函数/伪造对象/经典继承：在子类型构造函数的内部调用超类型构造函数。 // 父亲 function Father() { this.info = [&#39;Zero&#39;] } // 儿子 function Son() { // 继承父亲：在子类型构造函数的内部调用超类型构造函数 // 《JavaScript高级程序设计》：函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call() 可以在新创建的对象上执行构造函数。 Father.call(this) // 借用超类的构造函数 } let f = new Father() f.info.push(&#39;100&#39;) console.log(f.info); // [&quot;Zero&quot;, &quot;100&quot;] let s = new Son() console.log(s.info); // [&quot;Zero&quot;] 如果在继承的时候要传递参数，则在后面添加参数即可。如：Father.call(this， param1, param2) __proto__通过__proto__也可以实现子类型对超类型的继承。 const obj = { num : 123 } const obj1 = { __proto__ : obj } console.log(obj1.num); // 123 Object.create(source)const obj = { num : 123 } const obj2 = Object.create(obj) console.log(obj2.num); // 123 Object.assign(Object.create(obj), {…})const obj = { num : 123 } const obj3 = Object.assign( Object.create(obj), { num2 : 234 } ) console.log(obj3.num, obj3.num2); // 123 234 补充继承机制如下图： 测试代码如下：// 父类 function SuperType(){ } // 子类 function SubType(){ } // 子类继承父类 SubType.prototype = new SuperType(); // 实例化父类和子类 let superIns = new SuperType(); let subIns = new SubType(); // 子类 console.log(SubType.prototype); // SuperType {} console.log(subIns.__proto__); // SuperType {} // 父类 console.log(SuperType.prototype); // {constructor: ƒ} console.log(superIns.__proto__); // {constructor: ƒ} console.log(SuperType.prototype.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …} // 即： Object prototype console.log(SuperType.prototype.__proto__.constructor); // ƒ Object() { [native code] } 即：Object","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"js","slug":"frontEnd/js","permalink":"https://ertsul.github.io/categories/frontEnd/js/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"js的存储和拷贝","slug":"js的存储和拷贝","date":"2019-02-16T15:52:58.000Z","updated":"2019-11-11T15:36:45.807Z","comments":true,"path":"2019/02/16/js的存储和拷贝/","link":"","permalink":"https://ertsul.github.io/2019/02/16/js的存储和拷贝/","excerpt":"","text":"数据类型基本数据类型 Number String Boolean Undefined Null引用类型多个基本数据类型复合形成。 Object 存储方式基本数据类型的存储方式 每当定义一个基本数据类型的变量，会在 栈区 开辟一个内存空间，用于存放该变量。栈区的特点是：静态分配，大小固定。 当一个变量通过直接复制的方式复制给另一个变量，系统会在 栈区 重新开辟一个内存空间；两个变量互不影响。 let num1 = 10; let num2 = num1; num2 = 20; console.log(num1); // 10 引用类型的存储方式 每当定义一个引用类型，如：对象，会在 堆区 开辟一个内存空间；然后如果创建一个该对象的实例，会在 栈区 开辟一个内存存放该实例，该实例实际上是一个指向 堆内存 对象的指针。堆区的特点是：动态分配，大小不固定。 当一个实例直接复制给另一个实例，系统会在 栈区 重新开辟一个内存空间，但是新实例同样也是一个指向 堆内存 对象的指针，所以，这样的操作，这样的修改都会对新旧实例产生影响。 let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } //直接复制 let obj2 = obj1; obj2.name = &#39;Ertsul&#39;; obj2.num[0] = &#39;一&#39;; console.log(obj1, obj2); // name:&quot;Ertsul&quot; // age:22 // num:[&quot;一&quot;, &quot;2&quot;, &quot;3&quot;] 浅拷贝和深拷贝区别两者的区别主要在于 复制层次 的不同： 浅拷贝主要复制到对象属性这一层次，如果对象里面有子对象，则无法对子对象完成复制；之后对于子对象的修改 会 影响到原复制对象。 深拷贝则是浅拷贝的 加强版 ，可以实现对于子对象的拷贝；之后对于子对象的修改 不会 影响到原复制对象。主要实现方法有： 递归 JSON解析浅拷贝 // 浅拷贝 function shallowCopy(source) { let result = {}; for(let key in source){ result[key] = source[key] } return result; } let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } let obj2 = {}; obj2 = shallowCopy(obj1); obj2.name = &#39;Ertsul&#39;; // 不会产生影响 obj2.num[0] = &#39;一&#39;; // 产生影响 console.log(&quot;obj1&quot;, obj1); console.log(&quot;obj2&quot;, obj2); 结果如图： 深拷贝递归// 递归实现深拷贝 function deepCopy(source, res){ var res = res || {}; for(let i in source){ if(typeof source[i] === &#39;object&#39;){ if(source[i].constructor === Array){ res[i] = [] }else { res[i] = {} } deepCopy(source[i], res[i]); // 递归子对象属性 }else{ res[i] = source[i] } } return res; } let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } let result = {} result = deepCopy(obj1, result); result.name = &#39;Ertsul&#39;; result.num[1] = &#39;二&#39;; console.log(&quot;result&quot;, result); console.log(&quot;obj1&quot;, obj1); 结果如图： JSON解析// JSON实现深拷贝 let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } let result1 = JSON.parse(JSON.stringify(obj1)); result1.num[2] = &#39;三&#39;; console.log(&#39;result1&#39;, result1); console.log(&#39;obj1&#39;, obj1); 结果如图：","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"js","slug":"frontEnd/js","permalink":"https://ertsul.github.io/categories/frontEnd/js/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"js/es6小知识大杂烩","slug":"js-es6小知识大杂烩","date":"2019-02-16T15:46:09.000Z","updated":"2019-11-11T15:36:43.675Z","comments":true,"path":"2019/02/16/js-es6小知识大杂烩/","link":"","permalink":"https://ertsul.github.io/2019/02/16/js-es6小知识大杂烩/","excerpt":"","text":"合并两个数组 数组的解构 […arr1, …arr2] Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。 arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。 let arr1 = [1, 2, 3]; let arr2 = [4, 5, 6]; let arr3 = [...arr1, ...arr2]; console.log(arr3); Array.prototype.push.apply(arr1, arr2); console.log(arr1); arguments/伪数组 转化为数组 […arguments] Array.prototype.slice.call(arguments) (function Fn() { let arr = [...arguments, &#39;Ertsul&#39;]; console.log(arr); })(&#39;zero&#39;); (function Fn1() { let arr = Array.prototype.slice.call(arguments); console.log(arr); })(&#39;zero&#39;); 判断字符类型 Object.prototype.toString.call() typeof instanceof 创建实例的方法 字面量 let obj = {…} new Object()构造函数 构造函数 Object.create() 工厂模式 // 字面量 let obj1 = { name: &#39;zero&#39;, age: 22 }; // Object 构造函数 let obj2 = new Object(); obj2.name = &#39;zero&#39;; console.log(obj2.name); // 工厂模式 function Person(name) { let obj = new Object(); obj.name = name; return obj; } let p1 = Person(&#39;zero&#39;); console.log(p1.name); // 构造函数 function Animal(name) { this.name = name; } let a2 = new Animal(&#39;dog&#39;); console.log(a2.name); 数组的拆解 flatlet arr2 = [1, [2, 3, [100, 8989]], [4, 5, 6, 7, 8]]; const flat = arr =&gt; arr.toString().split(&#39;,).map(item =&gt; +item); console.log(flat(arr2)); // [1, 2, 3, 100, 8989, 4, 5, 6, 7, 8] 继承的方法 – 8种 通过原型继承 缺点：引用类型存在共享问题。 function Fn1() { ... } function Fn2() { ... } Fn2.prototype = new Fn1(); 构造函数：通过 call 更改 this 指向；实际上是调用了父类的构造函数。 缺点：父类中的方法（构造函数中）子类不可见。 function Fn1() { ... } function Fn2() { Fn1.call(this); // 将 this 绑定到 Fn1 } function SuperType(){ } SuperType.prototype.sayHi = function(){ console.log(&#39;Hi&#39;); } function subType(){ SuperType.call(this); } let superIns = new SuperType(); superIns.sayHi(); // Hi let subIns = new subType(); subIns.sayHi(); // Uncaught TypeError 组合继承（原型 + 构造）属性通过构造函数继承；方法通过原型继承。记得要更改 Fn2.prototype.constructor 的指向，指向子类。 // 组合继承 function Fn1() { this.name = &#39;zero&#39; } Fn1.prototype.sayName = function () { console.log(this.name); }; function Fn2() { // 继承属性 Fn1.call(this); this.age = 22; } // 继承方法 Fn2.prototype = new Fn1(); Fn2.prototype.constructor = Fn2; // 需要修复构造函数指向 Fn2.prototype.sayAge = function () { console.log(this.age); }; let f = new Fn2(); f.sayName(); f.sayAge(); 实例继承在一个函数内实例化，然后添加新属性，并返回该对象。 function Fn() { ... } function Fn2(name) { let obj = new Fn(); obj.name = name; return obj; } 原型式继承将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。 function SuperType(name) { this.name = name } function Object(o){ function F(){} F.prototype = o; return new F(); } let subType = Object(new SuperType(&#39;zero&#39;)); console.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__ 拷贝继承将原型/父类上的属性全部拷贝到子类上。 // 拷贝继承 function Fn1() { this.name = &#39;zero&#39;; this.age = 22 } function Fn2() { let f1 = new Fn1(); // 注意这里要用 in 操作符 for (let item in f1) { Fn2.prototype[item] = f1[item]; } Fn2.prototype.ownFun = function () { console.log(&#39;my own function.&#39;); } } let f = new Fn2(); console.log(f.name + &quot;, &quot; + f.age); f.ownFun(); 寄生组合式模型 通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。 通过构造函数实现属性的继承。 // 寄生组合式继承 function inheritPrototype(subType, superType) { // 创建对象：新建的对象指向父类的原型 let prototype = Object(superType.prototype); // 增强对象：新建对象的 constructor 指向子类 prototype.constructor = subType; // 指定对象：子类的原型指向新建对象 subType.prototype = prototype; } function Fn1() { this.name = &#39;Ertsul&#39;; } Fn1.prototype.sayName = function () { console.log(this.name); }; function Fn2() { Fn1.call(this); this.age = 22; } inheritPrototype(Fn2, Fn1); Fn2.prototype.sayAge = function () { console.log(this.age); }; let f = new Fn2(); f.sayName();f.sayAge(); es6 的 extends // class class F1 { constructor(name) { this.name = name; } } class F2 extends F1 { constructor(name, age){ super(name); // 调用父类的构造函数 this.age = age; } showMsg(){ console.log(this.name + &#39;, &#39; + this.age); } } let p = new F2(&#39;zero&#39;, 22); p.showMsg(); // zero, 22 比较两个对象是否相等 遍历对象对象进行判断。 将对象转化为字符串进行判断。 let obj1 = { name: &#39;a&#39;, age: 1 } let obj2 = obj1; let obj3 = { name: &#39;a&#39;, age: 2 } console.log(JSON.stringify(obj1)); console.log(JSON.parse(JSON.stringify(obj1))); console.log(JSON.stringify(obj1) == JSON.stringify(obj2)); // true console.log(JSON.stringify(obj1) == JSON.stringify(obj3)); // false 封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行function time(time){ return new Promise((resolve, reject) =&gt; { setTimeout(resolve, time); }) } let t = new time(5000); t.then((a, b) =&gt; { console.log(&#39;time&#39;); }) 原型相关的API Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例 Object.getPrototypeOf(p1)：获取原型 p1.hasOwnProperty(‘name’)：判断某个属性是否属于某个实例（只能获取属性实例） in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中） function Person(name, age) { this.name = name; this.age = age; } let p1 = new Person(&#39;Ertsul&#39;, 22); console.log(Person.prototype); // constructor f console.log(Person.prototype.constructor); // Person console.log(Person.prototype.__proto__); // constructor 的原型 console.log(p1.__proto__); // // constructor f console.log(Person.prototype.isPrototypeOf(p1)); // true console.log(Person.isPrototypeOf(p1)); // false console.log(Object.getPrototypeOf(p1)); // constructor f console.log(p1.hasOwnProperty(&#39;name&#39;)); // true 存在实例中 Person.prototype.num = 100 console.log(p1.hasOwnProperty(&#39;num&#39;)); // fasle 存在原型中 console.log(&#39;num&#39; in p1); // true 不管是实例还是原型中 js 判断数组类型 arr instanceof Array arr.constructor === Array let arr = [1, 2, 3]; let obj = {} function judgeFn(arr){ // return arr.constructor === Array ? true : false return arr instanceof Array ? true : false } console.log(judgeFn(arr)); // true console.log(judgeFn(obj )); // false 日期格式化/* 日期格式化 */ function formatNumber(num) { const n = `${num}`; // 转化为字符串 return n[1] ? n : `0${n}`; } function formatTime(date){ // 年 月 日 const year = date.getFullYear(); const month = date.getMonth() + 1; const day = date.getDate(); // 时 分 秒 const hour = date.getHours(); const minute = date.getMinutes(); const second = date.getSeconds(); return `${[year, month, day].map(formatNumber).join(&#39;-&#39;)} ${[hour, minute, second].map(formatNumber).join(&#39;:&#39;)}` } let time = new Date(); console.log(time); // Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间) let t1 = formatTime(time); console.log(t1); // 2018-08-14 16:52:06 字符串转化为标准日期格式/* 字符串转化为标准日期格式 */ function time2string(str) { const chunks = str.split(&#39; &#39;); const date = chunks[0].split(&#39;-&#39;); const time = chunks[1].split(&#39;:&#39;); return new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]); } let str = &quot;2018-08-14 23:59:59&quot;; let t2 = time2string(str); console.log(t2); // Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间) 防抖节流/* 防抖节流 debounce throttle */ // 防抖 - 连续快速触发的解决方案 function debounce(fn, wait) { let timeout = null; // 初始化 timer 定时器 return function (){ timeout &amp;&amp; clearTimeout(timeout); // 清空定时器 timeout = setTimeout(fn, wait); // 设置定时器 } } // 节流 - 一定时间内请求一次 -- 定时器法 function throttle1(fn, wait) { let timer = null; // 初始化 timer 定时器 return function () { let context = this; // 保存上下文 this let args = arguments; // 记录参数 if(!timer) { // 定时器为空 timer = setTimeout(() =&gt; { fn.apply(context, args); timer = null; // 清空定时器 }, wait); } } } // 节流 - 一定时间内请求一次 -- 时间戳法 function throttle2(fn, wait) { let prev = Date.now(); // 记录前一个时间 return function () { let context = this; // 保存上下文 this let args = arguments; // 记录参数 let now = Date.now(); // 记录当前时间 if(now - prev &gt;= wait){ // 时间戳大于设置的时间 fn.apply(context, args); prev = Date.now(); // 记录前一个时间 } } } // window.addEventListener(&#39;scroll&#39;, debounce(() =&gt; { // console.log(Math.random()); // }, 500)); // window.addEventListener(&#39;scroll&#39;, throttle1(() =&gt; { // console.log(Math.random()); // }, 1000)); window.addEventListener(&#39;scroll&#39;, throttle2(() =&gt; { console.log(Math.random()); }, 1000)) JSON.stringfy(obj, [replace, space]) 巧用第二个参数，可以实现json对象的过滤替换。 第三个参数，是缩进的空格数。 如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。 let obj1 = { name: &#39;zero&#39;, age: 22, hobby: &#39;ball&#39; }; let str1 = JSON.stringify(obj1); console.log(str1, typeof str1, str1.constructor === String); // {&quot;name&quot;:&quot;zero&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;} string true let str2 = JSON.stringify(obj1, (key, value) =&gt; { if(value === &#39;zero&#39;) { return &#39;Ertsul.&#39; }else { return value; } }); console.log(str2); // {&quot;name&quot;:&quot;Ertsul.&quot;,&quot;age&quot;:22,&quot;hobby&quot;:&quot;ball&quot;} let obj2 = { num: 100, toJSON(){ return &#39;apple&#39; } }; let str3 = JSON.stringify(obj2); console.log(str3); // apple 数组的 sort()sort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。如果要对数组的数字进行排序，则需要： array.sort((val1, val2) =&gt; {return val - val2}); 通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。 let arr10 = [1, 2, 19, 12, 22]; console.log(arr10.sort()); // [1, 12, 19, 2, 22] console.log(arr10.sort((val1, val2) =&gt; { // [1, 2, 12, 19, 22] return val1 - val2; })); reduce函数 reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。 其完整的函数为： arr.reduce((prev, next, cur, srcArr) =&gt; { ...... }, initVal) prev: 上次返回的值 next: 下一个数组元素的值 cur: 当前数组元素的索引值 scrArr: 源数组 initVal: 设置第一次的 prev 例子 1： let arr = [&#39;apple&#39;, &#39;pear&#39;, &#39;bananas&#39;]; arr.reduce((prev, next, cur, arr) =&gt; { console.warn(prev, next, cur, arr); return next; }, &#39;fruit&#39;) 例子 2：统计一个数组中单词出现的次数 // 统计数组中单词出现的次数 let arr = [&quot;apple&quot;, &quot;orange&quot;, &quot;apple&quot;, &quot;orange&quot;, &quot;pear&quot;, &quot;orange&quot;, &quot;bananas&quot;, &quot;bananas&quot;]; function getCount(arr) { return arr.reduce((prev, next, cur) =&gt; { prev[next] = (prev[next] + 1) || 1 return prev; }, {}) } console.warn(getCount(arr)); // {apple: 2, orange: 3, pear: 1, bananas: 2} Object.seal()防止对象纂改：不能添加也不能删除属性 let obj = { name: &#39;Ersul&#39; } Object.seal(obj); // 防止对象纂改：不能删除也不能添加属性 delete obj.name; console.warn(obj.name); // Ertsul obj.age = 22; console.warn(obj.age); // undefined Object.freeze()冻结对象，不能修改对象任何属性的值。如若 let obj = { name: &#39;Ersul&#39; } Object.freeze(obj); // 冻结对象，不能修改属性的值 obj.name = &#39;Zero&#39;; console.warn(obj.name); // Ertsul 数组字符串的相互转化 // 数组 --&gt; 字符串 : join() let arr3 = [1, 2, 3, 4, 5]; console.log(arr3.join(&#39;-&#39;)); // 字符串 --&gt; 数组 : split() let str = &#39;apple,pear,bananas&#39;; console.log(str.split(&#39;,&#39;));","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"js","slug":"frontEnd/js","permalink":"https://ertsul.github.io/categories/frontEnd/js/"},{"name":"es6","slug":"frontEnd/js/es6","permalink":"https://ertsul.github.io/categories/frontEnd/js/es6/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://ertsul.github.io/tags/es6/"}]},{"title":"webpack学习笔记","slug":"webpack学习笔记","date":"2019-02-16T15:20:58.000Z","updated":"2019-11-11T15:36:57.639Z","comments":true,"path":"2019/02/16/webpack学习笔记/","link":"","permalink":"https://ertsul.github.io/2019/02/16/webpack学习笔记/","excerpt":"","text":"项目构建 新建项目文件夹 npm init 设置项目目录结构，结构如下： build 目录是 webpack 打包后的生成目录，index.html 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。 src 目录是项目源文件，template.html 是 html 文件模板。 webpack.config.js 是配置 webpack 的总文件。 module.exports = { ... } 模式 modemode: &quot;development&quot;, // development or production 入口 entry设置打包的入口文件, entry: filepath entry: &quot;./src/index.js&quot;, // 入口 输出 output设置打包后的输出文件，output: { … } output: { // 输出 filename: &quot;bundle.[hash:8].js&quot;, path: path.resolve(__dirname + &#39;/build&#39;), // publicPath: &quot;http://&quot;, // 公共路径前缀 }, 注： path 后面应是绝对路径。 bundle.[hash:8].js 中的 [hash:8] 可以在每次打包后都在文件后面追加 hash 值。 通过上面三项，可以实现一个简单的 webpack 打包配置。在 package.json 添加脚本或直接执行 ./node_modules/.bin/webpack 即可实现打包： &quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;, webpack-dev-serverwebpack 开发服务器，用于开发时候的配置： yarn add taco –dev webpack-dev-server / npm install –save-dev webpack-dev-server 基本配置如下： devServer: { // 开发服务器 port: 3001, contentBase: path.resolve(__dirname + &#39;/build&#39;), // 本地服务器目录 progress: true, // 进度条 open: true, // 自动打开浏览器 compress: true, // 压缩 // 1. 代理 proxy: { &quot;/api&quot;: { target: &quot;&quot;, pathRewrite: { &quot;/api&quot;: &quot;&quot; } } }, // 2. 用 express 内置钩子模拟数据 before(app) { app.get(&quot;/api&quot;, (req, res) =&gt; { ... }) }, // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件 }, }, 在 package.json 添加脚本即可： &quot;dev&quot;: &quot;webpack-dev-server&quot; source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map作用：源码映射，报错时显示出错的位置。 source-map：会单独生成一个 sourcemap 文件；会显示行列。 eval-source-map：不会单独生成一个 sourcemap 文件，会将生成的 sourcemap 放到打包后的 html 文件；会显示行和列。 cheap-module-source-map：会生成 sourcemap 文件，不会显示列。 cheap-module-eval-source-map：不会生成 sourcemap 文件，集成在 html 文件中，不会显示列。 devtool: &quot;source-map&quot;, // 源码映射 watch作用：监控代码实时变化，进行编译打包。 watch: true, // 监控代码实时变化，进行编译打包 watchOptions: { poll: 1000, // 多毫秒监控一次 aggreatement: 500, // 防抖 ignored: &quot;node_modules&quot; // 忽略文件夹 }, resolve作用：解析第三方包 resolve: { // 解析 第三方包 modules: [ path.resolve(&quot;node_modules&quot;), // 在当前目录下查找模块 path.resolve(&quot;other_modules&quot;), // 在其他目录下查找模块 ], // 自动添加扩展名，主要是 import 时候使用, 依次解析 extensions: [&quot;.js&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.vue&quot;], // 比如引用 bootstrap 的 css 样式 // 方式一： bootstrap 的主入口 mainFields: [&quot;style&quot;, &quot;main&quot;], // 方式二：别名 // alias: { // bootstrap: &quot;bootstrap/dist/css/bootstrap.css&quot; // } }, 插件webpack 的插件配置是一个数组，里面存放着各种各样的插件。 plugins: [ new pluginName(...) ] html-webpack-plugin插件作用：打包时候自动根据 html 模板生成目标 html 文件，自动生成目标打包目录；另外，可配置 html 的相关打包配置，如：压缩，去双引号等。 new HtmlWebpackPlugin({ filename: &quot;index.html&quot;, // 目标文件名称 template: path.resolve(__dirname + &#39;/src/template.html&#39;), // 模板文件 minify: { // 压缩配置 removeAttributeQuotes: true, // 去双引号 collapseWhitespace: true, // 不换行 }, hash: true // 生成 hash 戳 }) mini-css-extract-plugin作用：将生成的 css样式 抽离成一个 css文件，并将该样式文件引进目标 html 文件中。 plugins: [ // 插件 new MiniCssExtractPlugin({ filename: &quot;main.css&quot;, }) ], module: { // 模块 rules: [{ test: /\\.css$/, use: [ // { // loader: &quot;style-loader&quot;, // options: { // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // } // }, MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序 &quot;css-loader&quot; ] }] } 注：这里抽离出来的 main.css 文件并没有压缩，要通过手动添加以下两个插件到优化项： optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin optimization: { // 优化项 minimizer: [ new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件 new UglifyjsWebpackPlugin({ cache: true, parallel: true, }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置 ] }, optimize-css-assets-webpack-plugin插件作用：压缩抽离出来的 main.css 文件。但是，使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 uglifyjs-webpack-plugin 。 uglifyjs-webpack-plugin插件作用：压缩打包后的 js 文件。 clean-webpack-plugin作用：清理文件 plugins: [ new CleanWebpackPlugin(&quot;./build&quot;) ] copy-webpack-plugin作用：将某些文件拷贝到打包后的文件夹。 new CopyWebpackPlugin([ {from: &quot;./copy&quot;, to: &quot;./&quot;} ]) banner-plugin作用：版权声明，是 webpack 的内置模块。 new webpack.BannerPlugin(&quot;@copyright by Ertsul&quot;) webpack.DefinePlugin({ … })作用：定义环境变量。 plugins: [ new webpack.DefinePlugin({ DEV: JSON.stringify(&quot;development&quot;), PRO: JSON.stringify(&quot;production&quot;) }) ] webpacfk.IgnorePlugin()作用：忽略模块的引进 plugins: [ new webpack.IgnorePlugin(/\\./locale/, /moment/) ] 注：如果直接使用 DEV: ‘development’ 的话，会把 DEV 直接替换为 引号内部的内容。如：console.log(DEV)，会变成 console.log(dev)，最后的结果是 undefined。所以，需要通过 JSON.stringfy() 进行转化。 模块 module模块主要是各种 loader，作用：解析各种类型的文件。 module: { rules: [ { test: regx, use: [loadName] } ] } css-loader / style-loader css-loader：主要是用于解析在 css 文件中通过 @import 方式引进其他的 css 文件。 style-loader: 主要是用于将 js 文件中通过 require 方式引进的 css 文件插入到目标 html 文件的 head 中（插到最后，层级最高）。 // 数组方式 module: { // 模块 rules: [{ test: /\\.css$/, // 正则 use: [&quot;style-loader&quot;, &quot;css-loader&quot;] // loader 数组 }] } // 对象方式 module: { // 模块 rules: [{ test: /\\.css$/, // 正则 use: [ { loader: &quot;style-loader&quot;, options: { insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 } }, &quot;css-loader&quot; ] }] } 注：loader 是从右向左、从下到上的执行顺序，故：use: [“style-loader”, “css-loader”] postcss-loader + autoprefixer这两个的配合使用可以自动添加 css 的浏览器前缀。 autoprefixer：自动添加 css 的浏览器前缀。 postcss-loader：loader 处理 autoprefixer。 // 使用 postcss-loader module: { // 模块 rules: [{ test: /\\.css$/, use: [ // { // loader: &quot;style-loader&quot;, // options: { // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // } // }, MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;postcss-loader&quot; // 注意顺序 ] }] } 根目录下新建 postcss.config.js 文件 module.exports = { plugins: [ require(&quot;autoprefixer&quot;) ] } babel-loader + @babel/core + @babel/preset-env作用：转化 es6 语法 module: { // 模块 rules: [{ test: /\\.js$/, use: { loader: &quot;babel-loader&quot;, options: { // 用 babel-loader 需要把 es6 转化为 es5 presets: [ &quot;@babel/preset-env&quot;, // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块 ], // plugins: [...] // 其他的小插件 } } }] } expose-loader作用：暴露全局的 loader，暴露到 window 上。 // 一般情况 import $ from &#39;jquery&#39;; console.log(window.$); // undefined // 内联 loader 方式 import $ from &#39;expose-loader?$!jquery&#39;; console.log(window.$); // 其他方式：在每个模块中注入 new webpack.ProvidePlugin({ $: &quot;jquery&quot; }) console.log($); console.log(window.$); // undefined file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader在 webpack 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。 file-loader：js 文件中通过 import 方式引进图片。 html-withimg-loader：html 文件中通过 scr 方式引进图片。 在 css 中使用图片，style-loader 已经做了处理。 url-loader：将图片转化为 base64 module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: { loader: &quot;url-loader&quot;, options: { limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader // publicPath: &quot;http://&quot;, // 公共路径前缀 } } }, { test: /\\.html$/, use: [&quot;html-withimg-loader&quot;] } ] } ` 模块 module – noParse作用：不解析指定包的依赖关系。 module: { noParse: /jquery/ } 模块 module – exclude作用：排除 module: { exclude: /node_module/ } 模块 module – include作用：包含 module: { include: /src/ } 区分不同环境，实现开发和生产配置的分离将 webpack 的配置文件划分为以下文件： webpack.base.js：基本、共有的配置。 webpack.dev.js：开发配置。 webpack.prod.js：生产配置。 使用 webpack-merger 插件： 安装 webpack-merge 插件； 引进目标模块 import { smart } from &quot;webpack-merge&quot;; 使用 const base = require(&quot;webpack.base.js); module.exports = smart(base, { ... }) webpack 自带优化 import 语法（生成环境），tree-shaking 自动删除没有用到的代码； es6 模块会把语法放到 default 上； 自动省略可以简化的代码； scope hosting，作用域提升。 webpack 懒加载 通过 import 实现（该语法内部由 jsonp 实现），返回的是一个 promise。 要在 babel-loader 中添加 @babel/plugin-syntax-dynamic-import 插件。 vue 和 react 的l懒加载都是这样实现的。 /* * 模拟点击加载 source.js 的内容 */ // 1 { loader: &#39;babel-loader&#39;, options: { presets: [ &#39;@babel/preset-env&#39; ], plugins: [ &#39;@babel/plugin-syntax-dynamic-import&#39; ] }, } // 2 let btn = document.createElement(&#39;button&#39;); btn.innerHTML = &#39;btn&#39;; btn.addEventListener(&#39;click&#39;, function () { // 内部由 jsonp 实现动态加载文件 import(&#39;./source.js&#39;) .then(data =&gt; { console.log(data); }) }) document.body.appendChild(btn); 点击按钮后结果如下： 热更新 / 热替换 / Hot Module Replacement / HMR热更新：页面只更新改动的模块。 devServer 开始 hot 热更新模块。 使用 webpack 内置热更新插件。 NamedModulesPlugin HotModuleReplacementPlugin // devServer 配置 devServer: { port: 8089, contentBase: path.resolve(__dirname + &#39;/dist/&#39;), compress: true, progress: true, // open: true hot: true, // 开启热更新，只更新更改的模块 }, // 添加插件 plugins: [ new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径 new webpack.HotModuleReplacementPlugin(), // 热更新 ] 使用热更新 import source from &#39;./source.js&#39;; console.log(source); // 添加热更新操作，不然不会实现热更新 if (module.hot) { module.hot.accept(&#39;./source.js&#39;, () =&gt; { require(&#39;./source.js&#39;); }) 多线程打包使用 happypack 可以实现多线程打包。 安装并引进 happypack; 改写 module; plugin 配置。 // 改写 module module: { rules: [ { test: /\\.js$/, // use: { // loader: &#39;babel-loader&#39;, // options: { // presets: [ // &#39;@babel/preset-env&#39; // ] // } // } use: { loader: &#39;Happypack/loader?id=js&#39;, } }, ] } // plugin 配置 plugins: [ new Happypack({ id: &#39;js&#39;, use: [ { loader: &#39;babel-loader&#39;, options: { presets: [ &#39;@babel/preset-env&#39; ] } } ] }), ] 多页面打包const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); module.exports = { mode: &quot;production&quot;, entry: { home: &quot;./src/home.js&quot;, about: &quot;./src/about.js&quot;, other: &quot;./src/other.js&quot; }, output: { path: path.resolve(__dirname + &quot;/build/&quot;), filename: &quot;[name].js&quot;, }, plugins: [ new HtmlWebpackPlugin({ template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;home.html&quot;, chunks: [&quot;home&quot;] }), new HtmlWebpackPlugin({ template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;other.html&quot;, chunks: [&quot;other&quot;] }), new HtmlWebpackPlugin({ template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;about.html&quot;, chunks: [&quot;about&quot;] }), ] } 多页面打包抽离公共代码块打包 多页面 需要将公共的代码块抽离出来进行优化： optimation: { splitChunks: { // 分割代码块 cacheGroups: { // 缓存组 common: { // 公共的模块 chunks: &#39;initial&#39;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 }, vender: { // 第三方模块 priority: 1, // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用 test: /node_modules/, // 抽离出来 chunks: &#39;initial&#39;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 } } } } Tapablewebpack 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 Tapable，通过 Tapable 实现各种钩子（如同步钩子异步钩子）。而 Tapable 核心是依赖于 发布订阅者模式。 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tap 注册。 使用： const { SyncHook } = require(&#39;tapable&#39;); class Hook { constructor() { this.hooks = { arch: new SyncHook([&#39;name&#39;]) } } tap() { // 注册监听事件 this.hooks.arch.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); }) this.hooks.arch.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) } start() { // 开始 this.hooks.arch.call(&#39;Ertsul&#39;) } } let h = new Hook(); h.tap(); h.start(); 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tapAsync 注册。 setTimeout()方式使用： const { AsyncParallelHook } = require(&#39;tapable&#39;); class AsyncHook { constructor() { this.hooks = { arch: new AsyncParallelHook([&#39;name&#39;]) } } tap() { this.hooks.arch.tapAsync(&#39;vue&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); cb &amp;&amp; cb(); }, 1000) }) this.hooks.arch.tapAsync(&#39;react&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); cb &amp;&amp; cb(); }, 1000) }) } start() { this.hooks.arch.callAsync(&#39;Ertsul&#39;, () =&gt; { console.log(&#39;All finished!&#39;); }) } } const a = new AsyncHook(); a.tap(); a.start(); Promise()方式使用： const { AsyncParallelHook } = require(&#39;tapable&#39;); class AsyncHook { constructor() { this.hooks = { arch: new AsyncParallelHook([&#39;name&#39;]) } } tap() { this.hooks.arch.tapPromise(&#39;vue&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); resolve(); }, 1000) }) }) this.hooks.arch.tapPromise(&#39;react&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); resolve(); }, 1000) }) }) } start() { this.hooks.arch.promise(&#39;Ertsul&#39;).then(() =&gt; { console.log(&#39;hook all finished!&#39;); }) } } const a = new AsyncHook(); a.tap(); a.start(); Synchook 同步钩子实现： class Synchook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tap(name, task) { // 注册事件 this.tasks.push(task); } call(...args) { // 发布事件 this.tasks.forEach(task =&gt; { task(...args); }) } } let hook = new Synchook([&#39;Synchook&#39;]); hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); }) hook.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) hook.call(&#39;Ertsul&#39;); SyncBailHook 同步熔断钩子Synchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。 实现： // Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数 class Syncbailhook { constructor(args) { this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { let ret = &#39;&#39;; // 当前函数的返回值 let index = 0; // 当前任务数组的索引 do { ret = this.tasks[index++](...args); } while (ret === undefined &amp;&amp; index &lt; this.tasks.length) } } let hook = new Syncbailhook([&#39;Syncbailhook&#39;]); hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); }) hook.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) hook.call(&#39;Ertsul&#39;); SyncWaterfallHook 同步瀑布钩子Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。 实现： /** * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系 * 上一个函数的执行返回结果在当前函数的输入 */ class Syncwaterfallhook { constructor(args) { this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { let [first, ...others] = this.tasks; let ret = first(...args); others.reduce((prev, current) =&gt; { return current(prev); }, ret) } } let hook = new Syncwaterfallhook([&#39;Syncwaterfallhook&#39;]); hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); return &#39;vue learnt&#39;; }) hook.tap(&#39;react&#39;, (data) =&gt; { console.log(&#39;react&#39;, data); }) hook.call(&#39;Ertsul&#39;); SyncLoopHook 同步循环钩子同步循环钩子回让某个函数执行一定的次数。 实现： // Tapable Syncloophook 同步循环钩子 class Syncloophook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tap(name, task) { // 注册事件 this.tasks.push(task); } call(...args) { // 发布事件 this.tasks.forEach(task =&gt; { let ret = &#39;&#39;; do { ret = task(...args); } while (ret != undefined); }) } } let hook = new Syncloophook([&#39;Syncloophook&#39;]); const total = 3; let index = 0; hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); return ++index === total ? undefined : &#39;continue&#39;; }) hook.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) hook.call(&#39;Ertsul&#39;); AsyncParallelHook 异步并发钩子 回调函数方式实现： // Tapable Asynchook 异步钩子 class asyncparallelhook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tapAsync(name, task) { // 注册事件 this.tasks.push(task); } callAsync(...args) { // 发布事件 let finalCallback = args.pop(); let index = 0; const done = () =&gt; { index++; if (index === this.tasks.length) { finalCallback(); } } this.tasks.forEach(task =&gt; { task(...args, done); }) } } let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]); hook.tapAsync(&#39;vue&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); cb &amp;&amp; cb(); }, 1000) }) hook.tapAsync(&#39;react&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); cb &amp;&amp; cb(); }, 1000) }) hook.callAsync(&#39;Ertsul&#39;, () =&gt; { console.log(&#39;All hook finished!&#39;); }); AsyncParallelHook 异步并发钩子 Promise方式实现： // Tapable Asynchook 异步钩子 class asyncparallelhook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tapPromise(name, task) { // 注册事件 this.tasks.push(task); } promise(...args) { // 发布事件 let tasks = this.tasks.map(task =&gt; task(...args)); return Promise.all(tasks); } } let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]); hook.tapPromise(&#39;vue&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); resolve(); }, 1000) }) }) hook.tapPromise(&#39;react&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); resolve(); }, 1000) }) }) hook.promise(&#39;Ertsul&#39;).then(() =&gt; { console.log(&#39;All hooks finished!&#39;); }) AsyncSeriesHook 异步串行钩子AsyncWaterfallHook 异步瀑布流钩子","categories":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/categories/frontEnd/"},{"name":"webpack","slug":"frontEnd/webpack","permalink":"https://ertsul.github.io/categories/frontEnd/webpack/"}],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"webpack","slug":"webpack","permalink":"https://ertsul.github.io/tags/webpack/"}]}]}