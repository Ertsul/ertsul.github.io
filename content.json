{"meta":{"title":"Ertsul","subtitle":"","description":"Ertsul's Blog","author":"Ertsul","url":"https://ertsul.github.io"},"pages":[{"title":"about","date":"2019-02-16T14:42:19.000Z","updated":"2019-02-16T15:13:21.129Z","comments":true,"path":"about/index.html","permalink":"https://ertsul.github.io/about/index.html","excerpt":"","text":"Stay Hungry, stay foolish."}],"posts":[{"title":"Git 操作（补充）","slug":"Git-操作（补充）","date":"2019-10-12T14:10:08.000Z","updated":"2019-10-14T12:40:09.256Z","comments":true,"path":"2019/10/12/Git-操作（补充）/","link":"","permalink":"https://ertsul.github.io/2019/10/12/Git-操作（补充）/","excerpt":"","text":"cherry-pickcherry-pick 可以将分支 B 的任何一个 commit 合并到分支 A。 情景：dev 分支有两个 commit，分别是：创建 b.txt 文件 commitB、创建 c.txt 文件 commitC。现在我们只想要合并 commitAB 到 master 分支。下面是 master 和 dev* 两个分支的情况： 如果直接用 git merge 会将 commitC 也合并到 master，这不是我们想要的结果。这时候，cherry-pick 就派上用场了。用法如下： 切换到目标分支。 cherry-pick 待合并的 commitID。 上面的情景，只需要： git checkout master git cherry-pick 8f2aa26 结果如下： 不过，cherry-pick 只能合并单个指定的 commit。☞ cherry-pick 更多操作 rebaserebase变基 是 Git 中整合来自不同分支修改的一种操作。（另一种是 merge） 情景1：dev 分支有两个 commit ，分别是：创建 d.txt 文件 commitD、创建 e.txt 文件 commitE。现在我们想要将 dev 分支的所有 commit 合并到 master。下面是 dev 分支的情况： 想要通过 rebase 变基将 commit 合并到 master，只需要： 将 dev 分支变基到 master 分支。 切换到 master 分支。 执行 merge 操作。 git rebase master git checkout master git merge --no-ff dev 最后结果如下： 通过 rebase 合并分支跟 merge 合并是不一样的。☞ 点击查看区别) 情景2：dev 分支上有四个 commit，顺序分别是：创建 f.txt 文件 commitF、增加 f.txt 文件内容 commitF1、创建 g.txt 文件 commitG、增加 g.txt 文件内容 commitG1。现在只想要将 dev 分支上关于文件 f.txt 的所有操作合并到 master 分支。下面是 dev 分支的情况： 现在只想要将 dev 分支上关于文件 f.txt 的所有操作合并到 master 分支，需要： 以 f.txt 的最后一个修改的 commitID 新建一个分支 dev-temp。 将以 dev-temp 分支上关于 f.txt 的第一个修改的 commitID rabase 变基到 master 分支。 切换到 master 分支。 merge dev-temp 分支到 master 分支。 git checkout -b dev-temp 884c858 git rebase --onto master 3b0bfd7^ git checkout master git merge --no-ff dev-temp 情景3：dev 分支上有四个 commit，顺序分别是：创建 i.txt 文件 commitI、增加 i.txt 文件内容 commitI1、创建 j.txt 文件 commitJ、增加 j.txt 文件内容 commitJ1。现在只想要将 dev 分支上关于文件 j.txt 的所有操作合并到 master 分支。下面是 dev 分支的情况：（其实跟上面的情况和操作一样） 现在只想要将 dev 分支上关于文件 j.txt 的所有操作合并到 master 分支，需要： 以 j.txt 的最后一个修改的 commitID 新建一个分支 dev-temp1。 将以 dev-temp1 分支上关于 j.txt 的第一个修改的 commitID rabase 变基到 master 分支。 切换到 master 分支。 merge dev-temp1 分支到 master 分支。 git checkout -b dev-temp1 54ea4bd git rebase --onto master e31249b^ git checkout master git merge --no-ff dev-temp1 rebase更多操作) 合并多个 commit 为一个 commit合并多个 commit 为一个 commit 同样需要 rebase。 如下图：要将最新的两个 commit 合并为一个 commit。具体操作如下： 找到这三个 commit 的前一个 commit 的 commitID，执行 git rebase -i commitID 这时候会进入 vi 编辑。 pick 的意思是要会执行这个 commit squash 的意思是这个 commit 会被合并到前一个 commit 之后会进入 vi 编辑 commit 信息。只需要将原先的 commit 信息注释，在顶部添加新的 commit 信息。 完成。 删除分支删除分支包括删除本地分支和远程分支： 删除本地分支 如本地分支不是打开状态，则：git branch -d branchName 如本地分支是打开状态，则：git branch -D branchName 删除远程分支 git push origin --delete branchName 恢复分支恢复分支，我们只需要以之前分支的 commitID 新开一个分支即可。 如果不记得 commitID，可以通过 git reflog 进行查看。 撤销本地修改 撤销指定本地文件的修改（未提交状态）：git checkout -- fileName 撤销本地的所有修改（未提交状态）：git reset --hard 其他基本操作 生成本地的 key，并添加到远程仓库 ssh-keygen -t rsa 初始化本地目录 git init 添加到本地仓库 git add filename 提交到仓库（git 提交的是修改） git commit -m &quot;description&quot; 查看仓库状态 git status 查看不同点 git diff filename 版本回退 git reset --hard 第一分支 master 创建分支 v1 （HEAD 指向当前分支） // 创建并指向新分支 git checkout -b v1 // 分步执行 git branch v1 git checkouut v1 合并到当前分支 git merge v1 删除指定分支 git branch -d v1 指定分支将远程仓库的代码拉到本地 git clone gitAddress -b branchName 将本地的代码提交到远程仓库 git pull //获取最新的更改 git add modefied_filename git commit -m &quot;description&quot; git push // 推送 冲突解决可以用上面的方法解决就解决，不行的话就用下面的方法： 用远程仓库的代码完全覆盖本地代码。 git reset --hard // 版本回退 git pull 修改 commit 提交的内容 git commit --amend 打印 log 数量 git log -p -3 文件被添加到暂存区，撤销该文件到工作目录 git reset HEAD fliename 工作目的删除文件后，还有在暂存区中删除该文件 rm filename git rm filename 撤销对当前文件的修改，恢复到上一次快照的状态 git checkout -- filename HEAD 指针指向当前的分支，提交后都会快进（fast-forward ：指针右移）。 rebase 合并分支变基是将一系列提交按照原有次序依次应用到另一分支上，而合并是把最终结果合在一起。使得提交历史更加整洁。 你在查看一个经过变基的分支的历史记录时会发现，尽管实际的开发工作是并行的，但它们看上去就像是串行的一样，提交历史是一条直线没有分叉。 git checkout dev ......修改...... git add filename git commit -m &quot;......&quot; git rebase master git checkout master git merge dev","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://ertsul.github.io/tags/Git/"}]},{"title":"Git 操作","slug":"Git-操作","date":"2019-10-12T13:55:55.000Z","updated":"2019-10-14T13:27:07.008Z","comments":true,"path":"2019/10/12/Git-操作/","link":"","permalink":"https://ertsul.github.io/2019/10/12/Git-操作/","excerpt":"","text":"想必每个开发者对Git并不陌生，先来看看官方对于Git的定义： Git是一个免费和开源的分布式版本控制系统，旨在快速和有效率地处理从大到小的项目。 安装 Git 和查看 Git 版本 安装（仅说明在 Linux 系统下的安装，若您是windows系统，直接官网下载安装就行~） sudo apt install git 由于我之前已经安装过了，所以这里升级等都是 0。 查看是否安装成功 git 输入git命令后，出现一系列关于Git的参数和命令等，说明安装成功了。 查看 Git 版本 git --version 创建 Git 仓库所谓 Git 仓库（repository），也叫版本库。简单理解，就是可以被 Git 管理（修改，删除等）的目录。 新建本地目录，并切换到新目录 mkdir gitFile cd gitFile 将本地目录初始化为 Git 仓库 git init 查看 Git 仓库的目录 ls -al 您会发现，这里多了一个 .git 的目录，作用是 Git 来跟踪管理 Git 仓库的；注意，如果输入的命令是 ls 是不会看到 .git，因为这个目录默认是隐藏的。 将文件放到Git仓库（一定要在 git init 的目录／子目录下） 新建 test.txt 文件并输入内容 cat &gt; test.txt 将 test.txt 文件上传到Git仓库 git add test.txt 告知 Git 仓库提交了新文件，并添加标注信息 git commit -m &quot;My first git.&quot; -m 后面是 commit 信息。很简单吧～只需要两步，就可以将文件上传到Git仓库。 查看 Git 仓库的当前状态 git status 倘若修改了文件，但没有提交，结果是这样的： 提交后的结果是这样的： 查看文件修改内容如果修改了文件，但还没提交，可以对比文件前后的修改内容。 git diff test.txt 可知，文件 test.txt 添加了新的一行 This is the third line. 创建GitHub账号如果没有 GitHub 账号，得先到GitHub官网注册账号。注册登录为常规操作，不多说。 SSH设置由于Git和GitHub之间是通过SSH加密传输的，所以需要进行SSH设置。 创建SSH Key（用户主目录） ssh-keygen -t rsa -C &quot;你的邮箱&quot; 接下来回车默认就好了。 在用户主目录下找到 .ssh 目录 ls -al | find -name &quot;*.ssh&quot; 发现存在 .ssh 目录，切换到 .ssh 目录，发现文件中秘钥有 id_rsa（私钥）和 id_rsa.pub（公钥），其中是 id_rsa.pub 是我们所需要的 打开 ip_rsa.pub ，并复制 cat ip_rsa.pub 在 GitHub 中添加 SSH Key Settings-&gt;SSH and GRG keys-&gt;new SSH key 创建成功后，跳转页面中你会看到你新建的ssh key 创建 GitHub 仓库 登录GitHub账号后，创建新的仓库，仓库名称看自己需要命名，其他默认就好了。我这里为了测试，就取为test GitHub仓库创建成功后，会有SSH和HTTPS地址 Git 连接 GitHub，并推送本地文件到远程仓库 在本地仓库的目录 gitFile 下运行命令 git remote add origin 仓库的SSH地址 注意，这里的 origin 是远程仓库的名字（Git的默认叫法） 将本地仓库 Git 的文件推送到远程仓库 GitHub git push -u origin master 不出意外，在GitHub的 test 仓库中会看到我们传送的文件 从 GitHub 中克隆文件到本地 在 GitHub 中创建文件，并且复制SSH 地址 输入以下克隆命令 git clone SSH地址 你会发现，GitHub 中的目录包括你刚才新建的文件都存在本地目录中了。","categories":[],"tags":[{"name":"Git","slug":"Git","permalink":"https://ertsul.github.io/tags/Git/"}]},{"title":"防抖和节流","slug":"防抖和节流","date":"2019-02-18T13:34:34.000Z","updated":"2019-02-18T13:37:17.929Z","comments":true,"path":"2019/02/18/防抖和节流/","link":"","permalink":"https://ertsul.github.io/2019/02/18/防抖和节流/","excerpt":"","text":"防抖 对于一些高频触发操作的场景，我们需要加防抖操作。比如：监听页面滚动、输入实时显示搜索结果等。这些都需要加防抖操作，不然对页面性能有很大的副作用。 简单概括：防抖就是将高频操作优化为最后一次执行。 实现： // 防抖 const debounce = (fn, wait, immediate = false) =&gt; { let timer = null; return function () { let context = this, args = arguments; if (immediate &amp;&amp; !timer) { fn.apply(context, args); } if (timer) { clearTimeout(timer); } timer = setTimeout(() =&gt; { fn.apply(context, args); }, wait) } } 节流每段时间后执行一次，将高频转化为低频。 // 节流 const throttle = (fn, wait, immediate = false) =&gt; { let timer = null; return function () { let context = this, args = arguments; if (immediate) { fn.apply(context, args); } if (!timer) { timer = setTimeout(() =&gt; { fn.apply(context, args); timer = null; }, wait) } } }","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"vue-cli3.0项目创建+配置+自动部署","slug":"vue-cli3-0项目创建-配置-自动部署","date":"2019-02-17T14:09:53.000Z","updated":"2019-10-14T12:47:30.026Z","comments":true,"path":"2019/02/17/vue-cli3-0项目创建-配置-自动部署/","link":"","permalink":"https://ertsul.github.io/2019/02/17/vue-cli3-0项目创建-配置-自动部署/","excerpt":"","text":"创建项目 安装 vue3.0 脚手架 npm install -g @vue/cli 创建项目 vue create my_project 一系列选择之后，可以保存你当前的选择配置，之后创建项目的时候就可以直接用了。 安装依赖 cd my_project 最后的项目目录结构如下： 运行项目vue3.0 运行项目主要有两种方式： 命令行方式： npm run serve UI视图方式，这也是3.0版本的一大亮点。通过UI视图方式，可以帮助我们很多事，如：运行项目、安装依赖、安装插件等。 vue ui webpack 配置vue 已经帮我们配置了很多，额外自己又添加了一些配置；在根目录添加 vue.config.js 配置文件： const path = require(&#39;path&#39;); const px2rem = require(&#39;postcss-px2rem&#39;); const VconsoleWebpackPlugin = require(&#39;vconsole-webpack-plugin&#39;); const TerserWebpackPlugin = require(&#39;terser-webpack-plugin&#39;); // 判断是否为生产环境 const isProduction = process.env.NNODE_ENV === &#39;production&#39;; // 路径处理函数 const resolve = name =&gt; path.resolve(__dirname, name); module.exports = { publicPath: isProduction ? &#39;/production&#39; : &#39;/&#39;, // 部署应用包时的基本 URL productionSourceMap: !isProduction, // 生产环境不开启 source-map devServer: { // webpack-dev-server 的配置 port: 8089, // 本地端口 open: true, // 自动打开浏览器 // proxy: { // 代理 // &#39;/api&#39;: { // target: &#39;&lt;url&gt;&#39;, // ws: true, // changeOrigin: true // }, // } }, css: { extract: isProduction, // 生产环境将 css 单独抽离成一个文件 sourceMap: !isProduction, // 生成环境不开启 source-map loaderOptions: { postcss: { // 移动端使用rem plugins: [ px2rem({ remUnit: 75 }) ] }, // 全局共享variables.scss sass: { // @/ 是 src/ 的别名 // 所以这里假设你有 `src/variables.scss` 这个文件 data: `@import &quot;@/variables.scss&quot;;` } } }, configureWebpack: config =&gt; { const devPlugins = [ new VconsoleWebpackPlugin({ // 微信移动端调试控制台 enable: !isProduction }) ]; const prodPlugins = [ new TerserWebpackPlugin({ terserOptions: { // 打包时候的配置 warnings: false, compress: true, drop_console: true, drop_debugger: true, pure_funcs: [&#39;console.log&#39;] } }) ]; if (isProduction) { // 生产环境 config.optimization.minimizer = [ ...config.optimization.minimizer, ...prodPlugins ] } else { // 开发环境 config.plugins = [...config.plugins, ...devPlugins] } }, chainWebpack: config =&gt; { // 自定义全局变量 // config // .plugin(&#39;define&#39;) // .tap((args) =&gt; { // args[0].PRODUCTION = isProduction ? JSON.stringify(&#39;&#39;) : // JSON.stringify( // &#39;other/&#39;, // ); // return args; // }); // 别名设置 config.resolve.alias .set(&#39;js&#39;, resolve(&#39;src/assets/js&#39;)) .set(&#39;scss&#39;, resolve(&#39;src/assets/scss&#39;)) .set(&#39;images&#39;, resolve(&#39;src/assets/images&#39;)) .set(&#39;components&#39;, resolve(&#39;src/components&#39;)); } } 路由配置vue3.0 的路由配置已经很完善了，这里我仅仅小改动，封装了路由懒加载函数： import Vue from &#39;vue&#39; import Router from &#39;vue-router&#39; import Home from &#39;./views/Home.vue&#39; Vue.use(Router) // 路由懒加载 // route level code-splitting // this generates a separate chunk (about.[hash].js) for this route // which is lazy-loaded when the route is visited. const addRouterComponent = path =&gt; import(path); export default new Router({ mode: &#39;history&#39;, base: process.env.BASE_URL, routes: [{ path: &#39;/&#39;, name: &#39;home&#39;, component: Home }, { path: &#39;/about&#39;, name: &#39;about&#39;, component: addRouterComponent(&#39;./views/About.vue&#39;) } ] }) axios 的配置在 scr 目录下添加 api 目录，并新建两个文件：config.js 和 api.js。配置如下： config.js import axios from &#39;axios&#39;; import qs from &#39;qs&#39;; axios.defaults.withCredentials = false; // 请求拦截器 axios.interceptors.request.use( request =&gt; { request.data = request.data || {}; const hasHttp = /^http(|s):\\/\\//.test(request.url); if (!hasHttp) { // 无 http or https 头处理 request.url = `https://${request.url}`; } if (request.data) { request.data = { // commom: &#39;&#39;, 这里可以添加一些公共的请求参数 data: JSON.stringify(request.data) }; request.data = qs.stringify(request.data); } return request; }, error =&gt; Promise.reject(error) ); // 响应拦截器 axios.interceptors.response.use( response =&gt; { const responseData = response.data; if (responseData.errcode !== 0) { // 错误处理 return Promise.reject(responseData.msg || &#39;未知错误&#39;); } responseData.result = responseData.result || {}; return responseData; }, error =&gt; Promise.reject(error) ); export { axios }; api.js import { axios } from &#39;./config.js&#39;; // 例子 1 export const aApi1Name = params =&gt; axios.post(url, params); // 例子 2 export const aApi2Name = params =&gt; axios.get(url, params); 打包后自动部署到服务器使用的是 scp2；通过向脚本传递不同参数，部署到不同的服务器路径；在根目录添加 deploy.js 脚本。相关配置如下： package.json &quot;buildTest&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js development&quot;, &quot;buildProd&quot;: &quot;vue-cli-service build &amp;&amp; node deploy.js production&quot; deploy.js const qs = require(&#39;qs&#39;); // 判断是否输出帮助信息 const helpMessage = `usage: node deploy.js [deploy_target]`; if ( process.argv.length !== 3 || process.argv[2] === &#39;-h&#39; || process.argv[2] === &#39;--help&#39; ) { console.log(helpMessage); process.exit(0); } // 判断是否是生产环境 const isProduction = process.argv[2] === &#39;production&#39;; // 设置部署的文件路径，正服 or 测服 let deployPath = &#39;&#39;; if (isProduction) { deployPath = &#39;/production&#39; } else { deployPath = &#39;/test&#39; } // 设置服务器服务器信息 const SERVER_INFO = { host: &#39;134.175.150.8&#39;, port: 22, username: &#39;&#39;, password: &#39;&#39;, path: deployPath } // 部署到服务器 client.scp(&#39;./dist/&#39;, SERVER_INFO, err =&gt; { if (err) { console.log(&#39;Deploy Failed!\\n&#39;, err); } }) console.log(`Deploy ${isProduction ? &#39;production&#39; : &#39;developemt&#39;} finished!`); 总结：通过上面的配置，基本可以实现 vue 项目从创建到配置到打包自动部署的过程。","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"Vue","slug":"Vue","permalink":"https://ertsul.github.io/tags/Vue/"}]},{"title":"websocket","slug":"websocket","date":"2019-02-17T13:57:39.000Z","updated":"2019-10-14T12:48:13.750Z","comments":true,"path":"2019/02/17/websocket/","link":"","permalink":"https://ertsul.github.io/2019/02/17/websocket/","excerpt":"","text":"HTTP/HTTPS 协议 一个 request 对应一个 response。一般使用 轮询 机制获取信息。 虽然后期有 keep-alive，可以一次连接中处理多个 request 合并发送，接收多个 response，对每个请求仍然需要单独发 header。 HTTP 的 response 是被动的，通信只能由客户端发起，做不到服务端主动向客户端推送信息。 HTTP 是无状态协议。 需要三次握手。 HTTP：TCP + HTTP HTTPS：TCP + HTTP + TLS ajax 轮询ajax 轮询 是指客户端 不断 向服务器发送资源请求 request，服务端不管有无目标资源，都会返回 response 结果。这样就要求服务器拥有更好的处理速度。 long poll / 长轮询long poll 比 ajax 轮询 好点，不会不断 向服务器发送资源请求 request，一旦接受客户端的请求，有资源就返回；无资源就挂起，直到有资源才返回 response 结果（有且仅有返回一次）。高并发，需要服务器可以同时处理多个请求的能力。 websocket 协议 websocket 是 html5 出的协议。 websocket 是一个持久化的协议，websocket 只需要一次请求（一次 HTTP 握手 ），就可以得到所需的资源。 服务端可以 主动 向客户端推送信息，客户端也可以 主动 向服务端推送消息，实现“双向平等”，是属于服务器推送技术的一种。 与 HTTP 有较好的兼容性，在握手阶段采用 HTTP 协议。 默认端口 80 and 443。 数据格式轻量，性能开销小，通信高效，可以发送文本，也可以二进制数据。 没有同源策略。 WS：TCP + WS WSS：TCP + WS + TLS websocket 握手GET /chat HTTP/1.1 Host: server.example.com Upgrade: websocket Connection: Upgrade Sec-WebSocket-Key: x3JJHMbDL1EzLkh9GBhXDw== Sec-WebSocket-Protocol: chat, superchat Sec-WebSocket-Version: 13 Upgrade/Connection：通知服务器发起的是 wesocket 协议。 Sec-WebSocket-Key：浏览器随机生成的 Base64 encode 的值，用于验证服务器是不是 websocket 协议。 Sec-WebSocket-Protocol：用户定义的字符串，用来区分 同 url 下，不同的服务所需要的协议。 Sec-WebSocket-Version：协议版本。 服务器返回HTTP/1.1 101 Switching Protocols Upgrade: websocket Connection: Upgrade Sec-WebSocket-Accept: HSmrc0sMlYUkAGmm5OPpG2HaGWk= Sec-WebSocket-Protocol: chat Upgrade/Connection：通知客户端升级的是 websocket 协议。 Sec-WebSocket-Accept：经服务器确认，加密后的 Sec-WebSocket-Key。 Sec-WebSocket-Protocol：最终使用的协议。 代码实现ws.addEventListener(&#39;open&#39;, function () { console.log(&#39;Open the websocket...&#39;); ws.send(&#39;Hello websocket...&#39;); }); ws.addEventListener(&#39;message&#39;, function (e) { console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Receive the websocket message...&#39; + e.data); ws.close(); setTimeout(() =&gt; { console.log(&#39;Ready state: &#39; + ws.readyState); }, 1000) }); ws.addEventListener(&#39;close&#39;, function () { console.log(&#39;Ready state: &#39; + ws.readyState, &#39;Close the websocket...&#39;); }) 结果： 参考： https://www.zhihu.com/search?type=content&amp;q=websocket http://www.ruanyifeng.com/blog/2017/05/websocket.html","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"}]},{"title":"用户认证小总结","slug":"用户认证小总结","date":"2019-02-17T13:52:43.000Z","updated":"2019-10-14T12:48:25.180Z","comments":true,"path":"2019/02/17/用户认证小总结/","link":"","permalink":"https://ertsul.github.io/2019/02/17/用户认证小总结/","excerpt":"","text":"用户认证一般的用户认证流程如下图： 但是，这种模式的扩展性不好。单个服务器没问题，如果多个服务器集群，要求共享 session ，每个服务器都能访问到 session 。 解决方案一：session 数据持久化，写入数据库或者其他持久层。各个服务器收到请求后，向持久层发送数据请求。 缺点：工程量大。 解决方案二：服务器不保存 session 数据，所有的数据保存在客户端，每次请求都发回服务器。如：JWT(Json Web Token)。 JWTJWT 服务器不保存 session 数据，在服务器认证之后，返回一个 JSON 对象。格式如下： { &quot;姓名&quot;: &quot;zero&quot;, &quot;角色&quot;: &quot;管理员&quot;, &quot;到期时间&quot;: &quot;2018年10月6日0点0分&quot; } 之后，客户端与服务器的用户认证都靠这个 JSON 对象，当然，这个对象后面会加上签名，保证数据不被篡改。 JWT 的数据结构 JWT 是一个很长的字符串，中间用 . 分隔，内部没有换行。 组成由三个部分：Header.Payload.Signature Header：头部。JSON 对象，描述 JWT 的元数据。 Payload：负载。JSON 对象，存放实际需要传递的数据；不加密。 Signature：签名。对 Header 和 Payload 的签名，防止数据被篡改。 Header 格式： { &quot;alg&quot;: &quot;HS256&quot;, // 签名的算法 &quot;typ&quot;: &quot;JWT&quot; // token 类型 } Payload 七个字段： iss (issuer)：签发人 exp (expiration time)：过期时间 sub (subject)：主题 aud (audience)：受众 nbf (Not Before)：生效时间 iat (Issued At)：签发时间 jti (JWT ID)：编号 JWT 的使用方式 存储在 cookie 中。 存储在 localStorage 中。 客户端每次与服务器进行通信的时候，都会带上 JWT。 参考： http://www.ruanyifeng.com/blog/2018/07/json_web_token-tutorial.html","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"}]},{"title":"web safe","slug":"web-safe","date":"2019-02-17T13:41:10.000Z","updated":"2019-10-14T12:49:16.831Z","comments":true,"path":"2019/02/17/web-safe/","link":"","permalink":"https://ertsul.github.io/2019/02/17/web-safe/","excerpt":"","text":"CSRF : Cross Site Request ForgeryCSRF 跨站请求伪造。是一种劫持受信任用户向服务器发送非预期请求的攻击方式。简而言之：用户在登录的情况下访问了钓鱼网站，钓鱼网站通过用户向其他网站发送请求，这样就达到了模拟用户的目的。具体实现如下图： 防御手段 验证码实现用户验证。验证码强制用户必须与应用进行交互，才能完成最终的请求。 通过 referer 实现用户验证。根据 HTTP 协议，在 HTTP 头中有一个字段叫 Referer，它记录了该 HTTP 请求的 来源地址。通过 Referer Check，可以检查请求是否来自合法的”源”。 通过 token 实现用户验证。 尽量不要在页面的链接中暴露用户隐私信息。 对于用户修改删除等操作最好都使用 post 操作。 避免全站通用的 cookie，严格设置 cookie 的域。 XSS : Cross Site ScriptXSS 跨站脚本攻击。攻击者向用户的网站嵌入的 js 脚本代码，当用户访问该网站的时候，该 js 脚本代码就会被执行，从而达到攻击用户的目的。 反射型 XSS 攻击又称非持久性跨站脚本攻击。发出请求时，XSS 代码出现在 URL 中，作为输入提交到服务器端，服务器端解析后响应，XSS 随响应内容一起返回给浏览器，最后浏览器解析执行 XSS 代码。漏洞产生的原因是攻击者注入的数据反映在响应中。一个典型的非持久性 XSS 包含一个带 XSS 攻击向量的链接(即每次攻击需要用户的点击)。比如： http://www.test.com/message.php?send=&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;！ 存储型 XSS 攻击XSS 提交的代码会存储在服务器端（数据库，内存，文件系统等），下次请求目标页面时不用再提交 XSS 代码。这种攻击方式的稳定性很好。比如： 攻击者在 value 填写&lt;script&gt;alert(‘foolish!’)&lt;/script&gt;【或者 html 其他标签（破坏样式。。。）、一段攻击型代码】；将数据存储到数据库中；其他用户取出数据显示的时候，将会执行这些攻击性代码。 具体方式 攻击者向服务器注入 js 代码。 诱导用户访问受到攻击的网站。 用户访问受到攻击的网站，执行注入的 js 代码。 XSS 防御方式 HttpOnly 输入检查 输出检查 参考链接： https://www.cnblogs.com/shytong/p/5308667.html https://github.com/dwqs/blog/issues/68 https://www.cnblogs.com/phpstudy2015-6/p/6767032.html#_label3","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"web-safe","slug":"web-safe","permalink":"https://ertsul.github.io/tags/web-safe/"}]},{"title":"Ajax和跨域总结","slug":"Ajax和跨域总结","date":"2019-02-16T16:00:28.000Z","updated":"2019-10-14T12:54:58.178Z","comments":true,"path":"2019/02/17/Ajax和跨域总结/","link":"","permalink":"https://ertsul.github.io/2019/02/17/Ajax和跨域总结/","excerpt":"","text":"Ajax（JavaScript实现）简介Ajax（Async Javascript And Xml）：异步Js和Xml，意思就是用Js执行异步网络请求。作用主要是在不重新加载全部网页的情况下，对部分页面进行更新。 创建XMLHttpRequest对象除了IE5和IE6不支持之外（支持ActiveXObject对象），几乎现在所有的有内建的XMLHttpRequest对象。所以在创建请求对象之前判断下就好了： let xhr = null; xhr = window.XMLHttpRequest ? new xmlHttpRequest() : new ActiveXObject(&quot;Microsoft.XMLHTTP&quot;) // 或者 if(window.XMLHttpRequest){ xhr = new XMLHttpRequest() }else{ xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;) } 通过open()和send()向服务器发送请求 xhr.open(method, url, async)这个方法的参数分别是：method请求的类型GET或者POST；URL请求的文件在服务器上的地址；async是否异步请求true或者false（一般不设置为false）。 xhr.send()：发送请求。 xhr.setRequestHeader(header, value)：如果是POST的话，要设置发送的HTTP头，然后通过send方法发送内容。参数分别是：发送的头部名称，头部的值。一般都是固定的。 // 向浏览器发送请求 xhr.open(&#39;GET&#39;, &#39;./server.php&#39;, true) // 添加HTTP头（POST方法） xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;) xhr.send() GET方法不需要参数，POST方法则需要把body参数；如果要想向服务器发送相关的参数，则通过open里面的第二个参数url进行发送，具体实现如下代码： url = &quot;./filePath?paramName=&quot; + paramValue + ...; 判断准备状态xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { ... } } xhr.onreadystatechange方法中，每当readyState改变时，就会触发xhr.onreadystatechange事件。 readyState属性：存有XMLHttpRequest的状态信息。0：请求未初始化；1：服务器链接已经建立；2：请求已经接受；3：请求处理中；4：请求已完成，且响应已就绪。一共有5个状态，所以onreadystatechange事件会被触发5次。 实际上onreadystateschange是通过回调函数实现的，即：每当readyState的状态改变时，这个回调函数就会被执行。 status属性：表示响应的结果。 总的代码如下： document.getElementById(&#39;btn&#39;).onclick = function () { // 创建请求对象（先判断浏览器类型） // var xhr = null; // if (window.XMLHttpRequest) { // xhr = new XMLHttpRequest() // } else { // xhr = new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;) // } xhr = (window.XMLHttpRequest) ? (new XMLHttpRequest()) : (new ActiveXObject(&#39;Microsoft.XMLHTTP&#39;)) // 判断响应状态并执行相关的操作 xhr.onreadystatechange = function () { if (xhr.readyState == 4 &amp;&amp; xhr.status == 200) { let data = xhr.responseText console.log(data); document.getElementById(&#39;myDiv&#39;).innerText = data } } // 向浏览器发送请求 let url = &quot;./server.txt&quot; xhr.open(&#39;GET&#39;, url, true) // 添加HTTP头（POST方法） // xhr.setRequestHeader(&#39;Content-Text&#39;, &#39;application/x-www-form-urlencoded&#39;) xhr.send(null); } 但是，由于在同源策略的作用下，浏览器只能同源的其他域的资源，先看看什么是同源策略～ 同源策略/SOP（Same origin policy）来自百度的解释： 同源策略（Same origin policy）是一种约定，它是浏览器最核心也最基本的安全功能（防止CSRF/XSRF攻击：跨站请求伪造）。现在所有支持JavaScript 的浏览器都会使用这个策略。所谓同源是指，域名，协议，端口相同。 简单来说，就是浏览器只能请求同源的其他域的资源，即同源的网页才能相互获取资源，而不能访问其他域的资源；但是有一个例外，同源策略不会阻止动态脚本插入到文档中；其中，\\是开放策略；当web网页执行一个脚本之前，会检查是否同源，只有同源才会被执行，非同源则会被拒绝访问。截取网上的图片说明同源： 跨域跨域就是突破同源策略的限制，获取其他源的资源。非同源主要有三种行为会受到限制： Cookie,LocalStorage和IndexDB无法读取。 DOM无法获取。 Ajax无法获取。 JSONPJSONP是实现跨域的常用方法，但是JSONP只能实现GET方法。实际上是是利用了浏览器允许跨域引用JavaScript资源（script标签是开放策略）。 下面举一个例子：我们从360浏览器首页的天气查询获取天气查询的异步请求地址；这里我们实现通过本地localhost服务器跨域请求360的天气查询，来说明JSONP怎么实现跨域。我们请求资源的地址为：https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600在浏览器中打开这个地址，我们会得到这样的数据：__jsonp21__({…})。解释：JSONP返回的通常是以函数的形式返回，前面这个__jsonp21__是函数名，所以我们需要在我们的代码中事先准备好名称为__jsonp21__的函数，我们对跨域请求到的数据就是放在这个函数中的，然后动态加载一个script节点，相当于动态读取外域的JavaScript资源，最后就等着接收回调了。 具体代码如下： // 请求的地址为：https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600 function __jsonp21__(data) { // 将要处理了的数据放在这个函数中 console.log(data); // 得到的是跨域请求的数据 let myDiv = document.getElementById(&#39;myDiv&#39;) myDiv.innerHTML = data.area } window.onload = function () { let btn = document.getElementById(&#39;btn&#39;) btn.addEventListener(&#39;click&#39;, function () { let url = &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39; let scriptTag = document.createElement(&#39;script&#39;) // 动态创建script标签 scriptTag.setAttribute(&#39;src&#39;, url) // 将其他源的地址设置为动态script的src属性 // console.log(scriptTag); // 得到的是script标签 document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag) // 将动态创建的script标签添加到html页面中 }) } 注意：数据处理的函数名要跟跨域返回的函数名一样，这样我们通过JSONP请求数据的时候，服务器才能返回数据。最终结果如下： 再句一个例子：请求地址是http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice function refreshPrice(data) { console.log(data); } window.onload = function () { let scriptTag = document.createElement(&#39;script&#39;) let url = &#39;http://api.money.126.net/data/feed/0000001,1399001?callback=refreshPrice&#39; scriptTag.setAttribute(&#39;src&#39;, url) document.getElementsByTagName(&#39;body&#39;)[0].appendChild(scriptTag) } Ajax（JQuery实现）在JQuery中，实现Ajax主要是由$.ajax({…})方法实现。方法的常用参数有： async：是否实现异步加载，一般来说，是true。 type：GET或者POST。 url：发送请求的地址。 timeout：设置请求的超时时间。 success：请求成功后的回调函数。 error：请求失败后的回调函数。 jsonp：在一个JSONP请求中重写回调函数的名字，默认为callback，用来重新命名回调我们跨域请求时候的函数名字。这个值用来替代在 “callback=?” 这种 GET 或 POST 请求中 URL 参数里的 “callback” 部分，比如 {jsonp:’onJsonPLoad’} 会导致将 “onJsonPLoad=?” 传给服务器。 jsonpCallback：为JSONP请求指定一个回调函数名。 dataType：预期服务器返回的数据类型。不指定的话，JQueryhi自动判断。”xml”: 返回 XML 文档，可用jQuery处理。 “html”: 返回纯文本 HTML 信息；包含的 script 标签会在插入 dom 时执行；”script”: 返回纯文本JavaScript代码。不会自动缓存结果。除非设置了”cache”参数。注意：在远程请求时(不在同一个域下)，所有POST请求都将转为GET请求。（因为将使用DOM的 script标签来加载）；”json”: 返回JSON数据；”jsonp”: JSONP格式。使用 JSONP 形式调用函数时，如 “myurl?callback=?” jQuery 将自动替换 ? 为正确的函数名，以执行回调函数；”text”: 返回纯文本字符串。 用JQuery实现同源的Ajax请求： $(function () { $(&#39;button&#39;).on(&#39;click&#39;, function () { $.ajax({ url: &#39;./server.txt&#39;, // 请求地址 type: &#39;GET&#39;, // 请求方式 async: true, // 是否异步 success: function (data) { console.log(data); } // 请求成功后执行的函数 }) }) }) 实现结果如下： 用JQuery实现非同源的JSONP跨域请求： $(function () { $(&#39;button&#39;).on(&#39;click&#39;, function () { $.ajax({ url: &#39;https://cdn.weather.hao.360.cn/sed_api_weather_info.php?code=101280501&amp;v=2&amp;param=weather&amp;app=hao360&amp;_jsonp=__jsonp21__&amp;t=2521600&#39;, type: &#39;GET&#39;, async: true, dataType: &#39;jsonp&#39;, jsonp: &#39;_jsonp&#39;, jsonpCallback: &#39;__jsonp21__&#39;, success: function (data) { console.log(data); $(&#39;#myDiv&#39;).html(data.area) }, error: function (err) { console.log(err); } }) }) }) 实现结果如下：","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"3D立体骰子","slug":"3D立体骰子","date":"2019-02-16T15:58:03.000Z","updated":"2019-02-16T15:58:33.734Z","comments":true,"path":"2019/02/16/3D立体骰子/","link":"","permalink":"https://ertsul.github.io/2019/02/16/3D立体骰子/","excerpt":"","text":"CSS3确实很强大，很多高大上的动画都可以实现，这里来实现下3D立方体，效果图如下： html其实，实现3D立方体需要的html十分简单，只需要一个ul标签里面包裹6个li标签，分别用来表示3D立方体的6个面[ 前，下，后，上，左，右 ]。具体代码如下: &lt;ul&gt; &lt;li&gt;1&lt;/li&gt; &lt;li&gt;2&lt;/li&gt; &lt;li&gt;3&lt;/li&gt; &lt;li&gt;4&lt;/li&gt; &lt;li&gt;5&lt;/li&gt; &lt;li&gt;6&lt;/li&gt; &lt;/ul&gt; CSS3ul基本的宽高这些就不说了；作为整个3D立方体的父级元素，需要设置positiion属性为relative，还要最重要的是设置它的动画类型tranform-style为preserve-3d，这样就可以实现它的所有子元素都进行3d动画。 li宽高设置为100%，position属性设置为absolute。 前设置背景，并且沿着Z轴移动50px，即宽高的一半(为什么得添加这个, 后面用动画进行解释说明)。 下设置背景，沿着X轴旋转-90deg，作为底面，同样，并且沿着Z轴移动50px。 后设置背景，沿着X轴旋转-180deg，作为后面，同样，并且沿着Z轴移动50px。 上设置背景，沿着X轴旋转90deg，作为上面，同样，并且沿着Z轴移动50px。 左设置背景，沿着Y轴旋转-90deg，作为左面，同样，并且沿着Z轴移动50px。 右设置背景，沿着Y轴旋转90deg，作为右面，同样，并且沿着Z轴移动50px。 结尾说明这里说明上面那个translate，先来看看如果不添加这个属性是怎样的效果：可见，所有的面都交集于立方体的中心点。由于未对6个面作任何动画处理的时候，所有的面都集合在一起。所以在面作旋转的同时需要对其进行Z轴的位移处理。 代码&lt;style&gt; * { margin: 0; padding: 0; } body { background-color: black; } ul { list-style: none; width: 100px; height: 100px; position: relative; cursor: pointer; margin: 150px auto; transition: 1s; /* 设置过渡时间 */ transform-style: preserve-3d; /* 设置所有的子元素实现3D动画 */ } /* 设置鼠标悬停的动画 */ ul:hover { transform: rotateX(120deg) rotateY(120deg); } ul li { width: 100%; height: 100%; text-align: center; line-height: 100px; font-size: 40px; font-weight: 700; position: absolute; top: 0px; } /* 前 */ ul li:nth-child(1) { background-color: rgba(225, 0, 0, .4); transform: rotateX(0deg) translateZ(50px); } /* 下 */ ul li:nth-child(2) { background-color: rgba(0, 255, 0, .4); transform: rotateX(-90deg) translateZ(50px); } /* 后 */ ul li:nth-child(3) { background-color: rgba(0, 0, 255, .4); transform: rotateX(-180deg) translateZ(50px); } /* 上 */ ul li:nth-child(4) { background-color: rgba(125, 125, 0, .4); transform: rotateX(90deg) translateZ(50px); } /* 左 */ ul li:nth-child(5) { background-color: rgba(0, 125, 125, .4); transform: rotateY(-90deg) translateZ(50px); } /* 右 */ ul li:nth-child(6) { background-color: rgba(10, 45, 36, .4); transform: rotateY(90deg) translateZ(50px); } &lt;/style&gt;","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"css","slug":"css","permalink":"https://ertsul.github.io/tags/css/"}]},{"title":"DOM事件","slug":"DOM事件","date":"2019-02-16T15:56:55.000Z","updated":"2019-10-12T15:28:36.464Z","comments":true,"path":"2019/02/16/DOM事件/","link":"","permalink":"https://ertsul.github.io/2019/02/16/DOM事件/","excerpt":"","text":"事件事件就是用户或者浏览器进行的特定行为，比如：鼠标点击事件。 事件名称比如：click就是一个事件名。 事件流的执行过程事件流：指的是 DOM 事件流（多个事件按照一定顺序执行），DOM(文档对象模型)结构是一个树型结构，当一个HTML元素产生一个事件时，该事件会在元素节点与根结点之间的路径传播，路径所经过的结点都会收到该事件，这个传播过程可称为DOM事件流。事件流的执行过程：从window开始，最后回到window。事件流被分为三个阶段：事件捕获（1-5），事件触发（5-6），事件冒泡（6-10）。 来自网上的图片： 事件冒泡来自百度的解释： 当事件发生后，这个事件就要开始传播(从里到外或者从外向里)。为什么要传播呢？因为事件源本身（可能）并没有处理事件的能力，即处理事件的函数（方法）并未绑定在该事件源上。 就比如：我们用button产生一个click事件，但是由于button按钮本身可能不能处理这个事件，就要开始传播出去这个事件。实现事件冒泡的条件是：元素之间有嵌套，每个元素都有相同的事件，这样当最里层的事件触发时，这个事件就会一级一级向上传播，也就是”冒泡“。 举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。这样，当里层点击事件触发时，外层的点击事件也会被触发。 &lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; window.onload = function () { let inner = document.getElementById(&#39;inner&#39;) let outer = document.getElementById(&#39;outer&#39;) inner.addEventListener(&#39;click&#39;, function (e) { console.log(&#39;inner&#39;); }) outer.addEventListener(&#39;click&#39;, function () { console.log(&#39;outer&#39;); }) } &lt;/script&gt; 结果为： 阻止事件冒泡 一般浏览器：event.stopPropagation() IE浏览器：event.cancelBubble = true 阻止默认事件 一般浏览器：event.preventDefault() IE浏览器：event.returnValue = false addEventListener的第三个参数addEventListener方法用于将事件和函数进行绑定，函数为：addEventListener(event, fn, useCapture)，这些参数分别是：事件名，事件处理函数，第三个参数 useCapture 是一个布尔值，用来设置该事件的执行是在哪个阶段发生的（默认是在冒泡阶段）。 true：表示该事件是在“事件捕获阶段”触发的。（由外向内） false：表示该事件是在“事件冒泡阶段”触发的。（由内向外） 举个例子：在一个div里面嵌套另一个div，两个div都绑定了相同的事件监听函数click。 将第三个参数设置为true，事件在 捕获阶段 执行： &lt;div id=&quot;outer&quot;&gt; &lt;div id=&quot;inner&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;script&gt; window.onload = function () { let inner = document.getElementById(&#39;inner&#39;) let outer = document.getElementById(&#39;outer&#39;) inner.addEventListener(&#39;click&#39;, function (e) { console.log(&#39;inner&#39;); }, true) outer.addEventListener(&#39;click&#39;, function () { console.log(&#39;outer&#39;); }, true) } &lt;/script&gt; 由于是 捕获阶段 执行，即：由外向内执行，所以结果为： outer inner。 结果为： 将第三个参数设置为false，事件在 冒泡阶段 执行，输出结果为： inner outer。 事件处理函数/事件监听函数事件触发后的处理函数。如：btn.onclick = fn，fn就是事件处理函数/事件监听函数。 HTML事件处理程序例如： &lt;button onclick = &quot;fn()&quot;&gt;click&lt;/button&gt; 这种方式的缺点是：结构和行为耦合在一起。 DOM0级事件处理程序形式为：ele.on + ‘事件名称’ = 事件处理函数例如： ele.onclick = function() {…}，this指向当前元素。 DOM2级事件处理程序这种方式主要是通过这两个方法：addEventListener()，removeEventListener()这种方式的优点就是：可以同一个事件处理程序绑定多个事件处理函数。 事件委托事件委托要处理的问题是：解决事件处理程序过多的问题。简单来说，就是将很多个事件处理程序委托给一个事件处理程序，通过这个事件处理程序来管理这么多个事件处理程序。好处：减少对DOM的访问，提高性能；可以对后来添加进来的元素也能绑定委托事件。 例如：在一个 ul 标签中有很多个 li 标签，我们的需求而是点击每一个 li 标签显示每一个 li 标签的内容。如果没有使用事件委托，我们需要给每一个 li 标签都添加事件监听函数，很明显，这样的效率并不高，而且对整个网页的性能也会影响；如果我们使用事件委托，将这些 li 的事件委托给 ul 标签，这样就可以只用一个事件监听函数实现。 代码如下： &lt;ul id=&quot;list&quot;&gt; &lt;li&gt;111111&lt;/li&gt; &lt;li&gt;222222&lt;/li&gt; &lt;li&gt;333333&lt;/li&gt; &lt;li&gt;444444&lt;/li&gt; &lt;/ul&gt; &lt;script&gt; window.onload = function () { // 传统的方法 // let lis = document.getElementsByTagName(&#39;li&#39;) // console.log(lis); // for(let i = 0; i &lt; lis.length; i++){ // lis[i].addEventListener(&#39;click&#39;, function () { // console.log(this.innerHTML); // }) // } // 使用事件委托 let list = document.getElementById(&#39;list&#39;) list.addEventListener(&#39;click&#39;, function (e) { let target = e.target console.log(target.innerHTML); }, false) } &lt;/script&gt; 事件委托一般使用的是 事件冒泡阶段 进行（虽然事件捕获阶段也可以），因为事件冒泡的事件流模型被所有的主流浏览器兼容，事件冒泡的兼容性更好。","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"px/em/rem总结","slug":"px-em-rem总结","date":"2019-02-16T15:55:21.000Z","updated":"2019-02-16T15:56:18.057Z","comments":true,"path":"2019/02/16/px-em-rem总结/","link":"","permalink":"https://ertsul.github.io/2019/02/16/px-em-rem总结/","excerpt":"","text":"px对于px，大家都不陌生。它是一个相对于屏幕的相对长度单位。 emem也是一个相对长度单位，但它相对的是父级元素的字体大小。对于em有一个推算过程：如果没有定义自己的font-size，则：浏览器默认：1em = 16px所以：12px = 0.75em10px = 0.625em但是如果每次都这样进行计算很麻烦，而且开发效率也很低，因此为了简化计算，我们将浏览器的font-size设置为62.5%，这样：1em = （16px * 62.5%） = 10px； 1.2em = 12px依次类推，要使用em这个相对长度单位，只要我们在body标签里面设置了font-size为62.5%，这样只要就可以得到计算公式：(n)px = (n \\ 10)em 但是，em单位是相对的，不是固定的，是逐级继承的（一层一层向上计算），举个例子：比如，一个div里面嵌套了一个div，这两个div都设置了font-size为1.2em，浏览器的font-size设置为62.5%，此时，最里层的div的font-size大小是：（1.2 * 1.2） = 1.44em。 remrem也是相对长度单位，从它的单位也可以看出，它跟em比较，多了个 r 字母，它的意思就是root（根）的意思。简单来说，就是它是相对于根节点（html标签）的font-size而言的。这样子，就消除了em单位逐级继承的缺点。举个例子：先将html标签设置为62.5%，这样，html里面的任何子标签都是继承于这个标签，也就是说相对于这个标签。所以，不论标签中有多少级的嵌套，最里层标签的font-size的计算公式永远是：(n)px = (n \\ 10)rem","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"css","slug":"css","permalink":"https://ertsul.github.io/tags/css/"}]},{"title":"js的原型和继承","slug":"js的原型和继承","date":"2019-02-16T15:54:24.000Z","updated":"2019-10-14T12:56:27.514Z","comments":true,"path":"2019/02/16/js的原型和继承/","link":"","permalink":"https://ertsul.github.io/2019/02/16/js的原型和继承/","excerpt":"","text":"原型模式原型模式在《JavaScript高级程序设计》中的定义： 我们创建的每个函数都有一个prototype（原型）属性，这个属性是一个指针，指向一个对象，而这个对象的用途是包含可以由特定类型的所有实例共享的属性和方法。如果按照字面意思来理解，那么prototype就是通过调用构造函数而创建的那个对象实例的原型对象。使用这个对象的好处就是可以让所有对象实例共享它包含的属性和方法。 这里还有一个__proto__属性，每一个对象都拥有这个属性，这个属性指向对应的构造函数的prototype属性。 通过原型对象，我们就不用将信息添加到构造函数中了。 实例对象共享原型对象的属性function Person(){} Person.prototype.name = &#39;A&#39; Person.prototype.age = 1 // 实例对象共享原型对象的属性 let p1 = new Person() console.log(p1.name, p1.age); // A 1 let p2 = new Person() console.log(p2.name, p2.age); // A 1 constructor（构造函数）属性每个原型对象在默认情况下都会自动获取一个constructor（构造函数）属性，这个属性包含一个指针，指向这个原型所在的函数。在上面的例子中，创建Person函数后，它的prototype指向它的原型对象，这个原型对象就会获取获取constructor属性，指向Person函数。 判断实例对象与原型对象之间的关系 Obj.prototype.isPrototypeOf(obj) console.log(Person.prototype.isPrototypeOf(p1)) // true Object.getPrototypeOf(obj)：返回对象实例的原型[es5] console.log(Object.getPrototypeOf(p1) == Person.prototype); // true console.log(Object.getPrototypeOf(p1).name); // A obj.hasOwnPrototype(attr)：检测一个属性是否存在于实例中。只有当实例对象重写原型对象的属性后（非原型属性）才会返回true。 console.log(p1.hasOwnProperty(&#39;name&#39;)); // false p1.name = &#39;Ertsul&#39; console.log(p1.hasOwnProperty(&#39;name&#39;)); //true in操作符：通过in操作符和hasOwnProperty()可以判断某属性存在于实例还是原型对象中【in判断是否存在属性，hasOwnProperty()判断存在于哪里。】可以单独使用和for-in循环使用：无论属性属于实例还是原型中，都会返回true。(‘name’ in person1) 获取所有实例的属性名字，无论是否可以枚举。 console.log(Object.getOwnPropertyNames(p1)); // [&quot;name&quot;] instanceof console.log(p1 instanceof Person); // true 更简单的语法function Person() { } Person.prototype = { name: &#39;001&#39; } let p1 = new Person() console.log(p1.name); 这里的例外是：constructor属性不再指向Person；本质上相当于完全重写了Person对象了。注：重写原型对象切断了现有原型与任何之前已经存在的对象实例之间的联系，它们引用的仍然是最初的原型。[详见《JavaScript高级程序设计》P156-P157，原型的动态性] ####搜索机制 解释器会现在目标对象中搜索目标属性，如果当前对象没有目标属性，解释器继续在目标对象的原型对象中搜索。 通过delete只能删除对象的属性，而不能删除原型对象中的属性。 组合模式（默认类型）：构造函数模式 + 原型模式构造函数模式用于定义实例属性，而原型模式用于定义方法和共享的属性。 继承原型链// 父亲 function Father() { this.fatherProperty = true } Father.prototype.getFatherValue = function () { return this.fatherProperty } // 儿子 function Son() { this.sonProperty = false } // 继承父亲：通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性 Son.prototype = new Father() Son.prototype.getSonValue = function () { return this.sonProperty } let instance = new Son() console.log(instance.fatherProperty); // true 上面例子中，通过实例化父亲，将实例化对象作为儿子的原型，这样儿子就继承了父亲的属性。（重写儿子的原型）。这里，儿子原型对象的[[prototype]]（注：不是prototype，[[prototype]]存在于原型中）指向的是父亲的原型对象，而父亲的原型对象的[[prototype]]指向的是Object Prototype。（由于所有函数的默认原型都是Object的实例，所以默认原型都会包含一个内部指针，指向Object.prototype） 借用构造函数 主要是为了解决因为引用类型值的原型属性会被所有实例共享的问题。 借用构造函数/伪造对象/经典继承：在子类型构造函数的内部调用超类型构造函数。 // 父亲 function Father() { this.info = [&#39;Zero&#39;] } // 儿子 function Son() { // 继承父亲：在子类型构造函数的内部调用超类型构造函数 // 《JavaScript高级程序设计》：函数只不过是在特定环境中执行代码的对象，因此通过使用 apply()和 call() 可以在新创建的对象上执行构造函数。 Father.call(this) // 借用超类的构造函数 } let f = new Father() f.info.push(&#39;100&#39;) console.log(f.info); // [&quot;Zero&quot;, &quot;100&quot;] let s = new Son() console.log(s.info); // [&quot;Zero&quot;] 如果在继承的时候要传递参数，则在后面添加参数即可。如：Father.call(this， param1, param2) __proto__通过__proto__也可以实现子类型对超类型的继承。 const obj = { num : 123 } const obj1 = { __proto__ : obj } console.log(obj1.num); // 123 Object.create(source)const obj = { num : 123 } const obj2 = Object.create(obj) console.log(obj2.num); // 123 Object.assign(Object.create(obj), {…})const obj = { num : 123 } const obj3 = Object.assign( Object.create(obj), { num2 : 234 } ) console.log(obj3.num, obj3.num2); // 123 234 补充继承机制如下图： 测试代码如下：// 父类 function SuperType(){ } // 子类 function SubType(){ } // 子类继承父类 SubType.prototype = new SuperType(); // 实例化父类和子类 let superIns = new SuperType(); let subIns = new SubType(); // 子类 console.log(SubType.prototype); // SuperType {} console.log(subIns.__proto__); // SuperType {} // 父类 console.log(SuperType.prototype); // {constructor: ƒ} console.log(superIns.__proto__); // {constructor: ƒ} console.log(SuperType.prototype.__proto__); // {constructor: ƒ, __defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, …} // 即： Object prototype console.log(SuperType.prototype.__proto__.constructor); // ƒ Object() { [native code] } 即：Object","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"js的存储和拷贝","slug":"js的存储和拷贝","date":"2019-02-16T15:52:58.000Z","updated":"2019-10-14T12:56:47.492Z","comments":true,"path":"2019/02/16/js的存储和拷贝/","link":"","permalink":"https://ertsul.github.io/2019/02/16/js的存储和拷贝/","excerpt":"","text":"数据类型基本数据类型 Number String Boolean Undefined Null引用类型多个基本数据类型复合形成。 Object 存储方式基本数据类型的存储方式 每当定义一个基本数据类型的变量，会在 栈区 开辟一个内存空间，用于存放该变量。栈区的特点是：静态分配，大小固定。 当一个变量通过直接复制的方式复制给另一个变量，系统会在 栈区 重新开辟一个内存空间；两个变量互不影响。 let num1 = 10; let num2 = num1; num2 = 20; console.log(num1); // 10 引用类型的存储方式 每当定义一个引用类型，如：对象，会在 堆区 开辟一个内存空间；然后如果创建一个该对象的实例，会在 栈区 开辟一个内存存放该实例，该实例实际上是一个指向 堆内存 对象的指针。堆区的特点是：动态分配，大小不固定。 当一个实例直接复制给另一个实例，系统会在 栈区 重新开辟一个内存空间，但是新实例同样也是一个指向 堆内存 对象的指针，所以，这样的操作，这样的修改都会对新旧实例产生影响。 let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } //直接复制 let obj2 = obj1; obj2.name = &#39;Ertsul&#39;; obj2.num[0] = &#39;一&#39;; console.log(obj1, obj2); // name:&quot;Ertsul&quot; // age:22 // num:[&quot;一&quot;, &quot;2&quot;, &quot;3&quot;] 浅拷贝和深拷贝区别两者的区别主要在于 复制层次 的不同： 浅拷贝主要复制到对象属性这一层次，如果对象里面有子对象，则无法对子对象完成复制；之后对于子对象的修改 会 影响到原复制对象。 深拷贝则是浅拷贝的 加强版 ，可以实现对于子对象的拷贝；之后对于子对象的修改 不会 影响到原复制对象。主要实现方法有： 递归 JSON解析浅拷贝 // 浅拷贝 function shallowCopy(source) { let result = {}; for(let key in source){ result[key] = source[key] } return result; } let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } let obj2 = {}; obj2 = shallowCopy(obj1); obj2.name = &#39;Ertsul&#39;; // 不会产生影响 obj2.num[0] = &#39;一&#39;; // 产生影响 console.log(&quot;obj1&quot;, obj1); console.log(&quot;obj2&quot;, obj2); 结果如图： 深拷贝递归// 递归实现深拷贝 function deepCopy(source, res){ var res = res || {}; for(let i in source){ if(typeof source[i] === &#39;object&#39;){ if(source[i].constructor === Array){ res[i] = [] }else { res[i] = {} } deepCopy(source[i], res[i]); // 递归子对象属性 }else{ res[i] = source[i] } } return res; } let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } let result = {} result = deepCopy(obj1, result); result.name = &#39;Ertsul&#39;; result.num[1] = &#39;二&#39;; console.log(&quot;result&quot;, result); console.log(&quot;obj1&quot;, obj1); 结果如图： JSON解析// JSON实现深拷贝 let obj1 = { name: &#39;zero&#39;, age: 22, num: [&#39;1&#39;, &#39;2&#39;, &#39;3&#39;] } let result1 = JSON.parse(JSON.stringify(obj1)); result1.num[2] = &#39;三&#39;; console.log(&#39;result1&#39;, result1); console.log(&#39;obj1&#39;, obj1); 结果如图：","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"}]},{"title":"js/es6小知识大杂烩","slug":"js-es6小知识大杂烩","date":"2019-02-16T15:46:09.000Z","updated":"2019-10-12T14:05:44.247Z","comments":true,"path":"2019/02/16/js-es6小知识大杂烩/","link":"","permalink":"https://ertsul.github.io/2019/02/16/js-es6小知识大杂烩/","excerpt":"","text":"合并两个数组 数组的解构 […arr1, …arr2] Array.prototype.push.apply(arr1, arr2)，最后合并到arr1。 arr3 = Array.prototype.slice.call(arr1, arr2)，最后合并到arr3。 let arr1 = [1, 2, 3]; let arr2 = [4, 5, 6]; let arr3 = [...arr1, ...arr2]; console.log(arr3); Array.prototype.push.apply(arr1, arr2); console.log(arr1); arguments/伪数组 转化为数组 […arguments] Array.prototype.slice.call(arguments) (function Fn() { let arr = [...arguments, &#39;Ertsul&#39;]; console.log(arr); })(&#39;zero&#39;); (function Fn1() { let arr = Array.prototype.slice.call(arguments); console.log(arr); })(&#39;zero&#39;); 判断字符类型 Object.prototype.toString.call() typeof instanceof 创建实例的方法 字面量 let obj = {…} new Object()构造函数 构造函数 Object.create() 工厂模式 // 字面量 let obj1 = { name: &#39;zero&#39;, age: 22 }; // Object 构造函数 let obj2 = new Object(); obj2.name = &#39;zero&#39;; console.log(obj2.name); // 工厂模式 function Person(name) { let obj = new Object(); obj.name = name; return obj; } let p1 = Person(&#39;zero&#39;); console.log(p1.name); // 构造函数 function Animal(name) { this.name = name; } let a2 = new Animal(&#39;dog&#39;); console.log(a2.name); 数组的拆解 flatlet arr2 = [1, [2, 3, [100, 8989]], [4, 5, 6, 7, 8]]; const flat = arr =&gt; arr.toString().split(&#39;,).map(item =&gt; +item); console.log(flat(arr2)); // [1, 2, 3, 100, 8989, 4, 5, 6, 7, 8] 继承的方法 – 8种 通过原型继承 缺点：引用类型存在共享问题。 function Fn1() { ... } function Fn2() { ... } Fn2.prototype = new Fn1(); 构造函数：通过 call 更改 this 指向；实际上是调用了父类的构造函数。 缺点：父类中的方法（构造函数中）子类不可见。 function Fn1() { ... } function Fn2() { Fn1.call(this); // 将 this 绑定到 Fn1 } function SuperType(){ } SuperType.prototype.sayHi = function(){ console.log(&#39;Hi&#39;); } function subType(){ SuperType.call(this); } let superIns = new SuperType(); superIns.sayHi(); // Hi let subIns = new subType(); subIns.sayHi(); // Uncaught TypeError 组合继承（原型 + 构造）属性通过构造函数继承；方法通过原型继承。记得要更改 Fn2.prototype.constructor 的指向，指向子类。 // 组合继承 function Fn1() { this.name = &#39;zero&#39; } Fn1.prototype.sayName = function () { console.log(this.name); }; function Fn2() { // 继承属性 Fn1.call(this); this.age = 22; } // 继承方法 Fn2.prototype = new Fn1(); Fn2.prototype.constructor = Fn2; // 需要修复构造函数指向 Fn2.prototype.sayAge = function () { console.log(this.age); }; let f = new Fn2(); f.sayName(); f.sayAge(); 实例继承在一个函数内实例化，然后添加新属性，并返回该对象。 function Fn() { ... } function Fn2(name) { let obj = new Fn(); obj.name = name; return obj; } 原型式继承将父类作为函数的参数，创建一个临时函数，继承于父类，返回父类。 function SuperType(name) { this.name = name } function Object(o){ function F(){} F.prototype = o; return new F(); } let subType = Object(new SuperType(&#39;zero&#39;)); console.log(subType.__proto__); // SuperType 因为是实例，所以只能是 __proto__ 拷贝继承将原型/父类上的属性全部拷贝到子类上。 // 拷贝继承 function Fn1() { this.name = &#39;zero&#39;; this.age = 22 } function Fn2() { let f1 = new Fn1(); // 注意这里要用 in 操作符 for (let item in f1) { Fn2.prototype[item] = f1[item]; } Fn2.prototype.ownFun = function () { console.log(&#39;my own function.&#39;); } } let f = new Fn2(); console.log(f.name + &quot;, &quot; + f.age); f.ownFun(); 寄生组合式模型 通过一个函数（创建对象，增强对象没，指定对象）：实现父类子类的方法继承。 通过构造函数实现属性的继承。 // 寄生组合式继承 function inheritPrototype(subType, superType) { // 创建对象：新建的对象指向父类的原型 let prototype = Object(superType.prototype); // 增强对象：新建对象的 constructor 指向子类 prototype.constructor = subType; // 指定对象：子类的原型指向新建对象 subType.prototype = prototype; } function Fn1() { this.name = &#39;Ertsul&#39;; } Fn1.prototype.sayName = function () { console.log(this.name); }; function Fn2() { Fn1.call(this); this.age = 22; } inheritPrototype(Fn2, Fn1); Fn2.prototype.sayAge = function () { console.log(this.age); }; let f = new Fn2(); f.sayName();f.sayAge(); es6 的 extends // class class F1 { constructor(name) { this.name = name; } } class F2 extends F1 { constructor(name, age){ super(name); // 调用父类的构造函数 this.age = age; } showMsg(){ console.log(this.name + &#39;, &#39; + this.age); } } let p = new F2(&#39;zero&#39;, 22); p.showMsg(); // zero, 22 比较两个对象是否相等 遍历对象对象进行判断。 将对象转化为字符串进行判断。 let obj1 = { name: &#39;a&#39;, age: 1 } let obj2 = obj1; let obj3 = { name: &#39;a&#39;, age: 2 } console.log(JSON.stringify(obj1)); console.log(JSON.parse(JSON.stringify(obj1))); console.log(JSON.stringify(obj1) == JSON.stringify(obj2)); // true console.log(JSON.stringify(obj1) == JSON.stringify(obj3)); // false 封装一个时间函数，时间通过 time 传递，回调函数通过 then 函数执行function time(time){ return new Promise((resolve, reject) =&gt; { setTimeout(resolve, time); }) } let t = new time(5000); t.then((a, b) =&gt; { console.log(&#39;time&#39;); }) 原型相关的API Person.prototype.isPrototypeOf(p1)：判断是否属于某个实例 Object.getPrototypeOf(p1)：获取原型 p1.hasOwnProperty(‘name’)：判断某个属性是否属于某个实例（只能获取属性实例） in操作符：判断某个属性是否属于某个实例（不管是实例中还是原型中） function Person(name, age) { this.name = name; this.age = age; } let p1 = new Person(&#39;Ertsul&#39;, 22); console.log(Person.prototype); // constructor f console.log(Person.prototype.constructor); // Person console.log(Person.prototype.__proto__); // constructor 的原型 console.log(p1.__proto__); // // constructor f console.log(Person.prototype.isPrototypeOf(p1)); // true console.log(Person.isPrototypeOf(p1)); // false console.log(Object.getPrototypeOf(p1)); // constructor f console.log(p1.hasOwnProperty(&#39;name&#39;)); // true 存在实例中 Person.prototype.num = 100 console.log(p1.hasOwnProperty(&#39;num&#39;)); // fasle 存在原型中 console.log(&#39;num&#39; in p1); // true 不管是实例还是原型中 js 判断数组类型 arr instanceof Array arr.constructor === Array let arr = [1, 2, 3]; let obj = {} function judgeFn(arr){ // return arr.constructor === Array ? true : false return arr instanceof Array ? true : false } console.log(judgeFn(arr)); // true console.log(judgeFn(obj )); // false 日期格式化/* 日期格式化 */ function formatNumber(num) { const n = `${num}`; // 转化为字符串 return n[1] ? n : `0${n}`; } function formatTime(date){ // 年 月 日 const year = date.getFullYear(); const month = date.getMonth() + 1; const day = date.getDate(); // 时 分 秒 const hour = date.getHours(); const minute = date.getMinutes(); const second = date.getSeconds(); return `${[year, month, day].map(formatNumber).join(&#39;-&#39;)} ${[hour, minute, second].map(formatNumber).join(&#39;:&#39;)}` } let time = new Date(); console.log(time); // Tue Aug 14 2018 16:52:06 GMT+0800 (中国标准时间) let t1 = formatTime(time); console.log(t1); // 2018-08-14 16:52:06 字符串转化为标准日期格式/* 字符串转化为标准日期格式 */ function time2string(str) { const chunks = str.split(&#39; &#39;); const date = chunks[0].split(&#39;-&#39;); const time = chunks[1].split(&#39;:&#39;); return new Date(date[0], date[1] - 1, date[2], time[0], time[1], time[2]); } let str = &quot;2018-08-14 23:59:59&quot;; let t2 = time2string(str); console.log(t2); // Tue Aug 14 2018 23:59:59 GMT+0800 (中国标准时间) 防抖节流/* 防抖节流 debounce throttle */ // 防抖 - 连续快速触发的解决方案 function debounce(fn, wait) { let timeout = null; // 初始化 timer 定时器 return function (){ timeout &amp;&amp; clearTimeout(timeout); // 清空定时器 timeout = setTimeout(fn, wait); // 设置定时器 } } // 节流 - 一定时间内请求一次 -- 定时器法 function throttle1(fn, wait) { let timer = null; // 初始化 timer 定时器 return function () { let context = this; // 保存上下文 this let args = arguments; // 记录参数 if(!timer) { // 定时器为空 timer = setTimeout(() =&gt; { fn.apply(context, args); timer = null; // 清空定时器 }, wait); } } } // 节流 - 一定时间内请求一次 -- 时间戳法 function throttle2(fn, wait) { let prev = Date.now(); // 记录前一个时间 return function () { let context = this; // 保存上下文 this let args = arguments; // 记录参数 let now = Date.now(); // 记录当前时间 if(now - prev &gt;= wait){ // 时间戳大于设置的时间 fn.apply(context, args); prev = Date.now(); // 记录前一个时间 } } } // window.addEventListener(&#39;scroll&#39;, debounce(() =&gt; { // console.log(Math.random()); // }, 500)); // window.addEventListener(&#39;scroll&#39;, throttle1(() =&gt; { // console.log(Math.random()); // }, 1000)); window.addEventListener(&#39;scroll&#39;, throttle2(() =&gt; { console.log(Math.random()); }, 1000)) JSON.stringfy(obj, [replace, space]) 巧用第二个参数，可以实现json对象的过滤替换。 第三个参数，是缩进的空格数。 如果被序列化对象内部含有toJSON方法，则该对象不会被序列化，而是序列化toJSON方法的返回值。`let obj1 = {name: ‘zero’,age: 22,hobby: ‘ball’}; let str1 = JSON.stringify(obj1);console.log(str1, typeof str1, str1.constructor === String); // {“name”:”zero”,”age”:22,”hobby”:”ball”} string truelet str2 = JSON.stringify(obj1, (key, value) =&gt; { if(value === ‘zero’) { return ‘Ertsul.’ }else { return value; }});console.log(str2); // {“name”:”Ertsul.”,”age”:22,”hobby”:”ball”} let obj2 = { num: 100, toJSON(){ return ‘apple’ }}; let str3 = JSON.stringify(obj2);console.log(str3); // apple - 数组的 sort() sort()默认会将每个元素转化为字符串，然后按照字符串进行排序，是不稳定的排序。 如果要对数组的数字进行排序，则需要： &gt;array.sort((val1, val2) =&gt; {return val - val2}); 通过这样实现，因为传递的参数是数字，所以通过减法操作（字符进行减法操作返回的是NaN），可以得到预期结果。 let arr10 = [1, 2, 19, 12, 22];console.log(arr10.sort()); // [1, 12, 19, 2, 22]console.log(arr10.sort((val1, val2) =&gt; { // [1, 2, 12, 19, 22] return val1 - val2;})); - reduce函数 &gt; reduce() 方法对累加器和数组中的每个元素（从左到右）应用一个函数，将其简化为单个值。 其完整的函数为： arr.reduce((prev, next, cur, srcArr) =&gt; { ……}, initVal) - prev: 上次返回的值 - next: 下一个数组元素的值 - cur: 当前数组元素的索引值 - scrArr: 源数组 - initVal: 设置第一次的 **prev** 例子 1： let arr = [‘apple’, ‘pear’, ‘bananas’];arr.reduce((prev, next, cur, arr) =&gt; { console.warn(prev, next, cur, arr); return next;}, ‘fruit’) ![image.png](https://upload-images.jianshu.io/upload_images/659084-65c2bd1bf155dfaf.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/1240) 例子 2：统计一个数组中单词出现的次数 // 统计数组中单词出现的次数let arr = [“apple”, “orange”, “apple”, “orange”, “pear”, “orange”, “bananas”, “bananas”];function getCount(arr) { return arr.reduce((prev, next, cur) =&gt; { prev[next] = (prev[next] + 1) || 1 return prev; }, {})}console.warn(getCount(arr)); // {apple: 2, orange: 3, pear: 1, bananas: 2} - Object.seal() 防止对象纂改：不能添加也不能删除属性 let obj = { name: ‘Ersul’}Object.seal(obj); // 防止对象纂改：不能删除也不能添加属性delete obj.name;console.warn(obj.name); // Ertsulobj.age = 22;console.warn(obj.age); // undefined - Object.freeze() 冻结对象，不能修改对象任何属性的值。如若 let obj = { name: ‘Ersul’} Object.freeze(obj); // 冻结对象，不能修改属性的值obj.name = ‘Zero’;console.warn(obj.name); // Ertsul - 数组字符串的相互转化 // 数组 –&gt; 字符串 : join()let arr3 = [1, 2, 3, 4, 5];console.log(arr3.join(‘-‘));// 字符串 –&gt; 数组 : split()let str = ‘apple,pear,bananas’;console.log(str.split(‘,’));`","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"js","slug":"js","permalink":"https://ertsul.github.io/tags/js/"},{"name":"es6","slug":"es6","permalink":"https://ertsul.github.io/tags/es6/"}]},{"title":"webpack学习笔记","slug":"webpack学习笔记","date":"2019-02-16T15:20:58.000Z","updated":"2019-10-14T12:57:27.888Z","comments":true,"path":"2019/02/16/webpack学习笔记/","link":"","permalink":"https://ertsul.github.io/2019/02/16/webpack学习笔记/","excerpt":"","text":"项目构建 新建项目文件夹 npm init 设置项目目录结构，结构如下： build 目录是 webpack 打包后的生成目录，index.html 是打包后的 html 文件，bundle.hash.js 是打包后的 js 文件。 src 目录是项目源文件，template.html 是 html 文件模板。 webpack.config.js 是配置 webpack 的总文件。 module.exports = { ... } 模式 modemode: &quot;development&quot;, // development or production 入口 entry设置打包的入口文件, entry: filepath entry: &quot;./src/index.js&quot;, // 入口 输出 output设置打包后的输出文件，output: { … } output: { // 输出 filename: &quot;bundle.[hash:8].js&quot;, path: path.resolve(__dirname + &#39;/build&#39;), // publicPath: &quot;http://&quot;, // 公共路径前缀 }, 注： path 后面应是绝对路径。 bundle.[hash:8].js 中的 [hash:8] 可以在每次打包后都在文件后面追加 hash 值。 通过上面三项，可以实现一个简单的 webpack 打包配置。在 package.json 添加脚本或直接执行 ./node_modules/.bin/webpack 即可实现打包： &quot;build&quot;: &quot;./node_modules/.bin/webpack&quot;, webpack-dev-serverwebpack 开发服务器，用于开发时候的配置： yarn add taco –dev webpack-dev-server / npm install –save-dev webpack-dev-server 基本配置如下： devServer: { // 开发服务器 port: 3001, contentBase: path.resolve(__dirname + &#39;/build&#39;), // 本地服务器目录 progress: true, // 进度条 open: true, // 自动打开浏览器 compress: true, // 压缩 // 1. 代理 proxy: { &quot;/api&quot;: { target: &quot;&quot;, pathRewrite: { &quot;/api&quot;: &quot;&quot; } } }, // 2. 用 express 内置钩子模拟数据 before(app) { app.get(&quot;/api&quot;, (req, res) =&gt; { ... }) }, // 3. 在服务端中启动 webpack 服务，使用 webpack-dev-middleware 中间件 }, }, 在 package.json 添加脚本即可： &quot;dev&quot;: &quot;webpack-dev-server&quot; source-map &amp;&amp; eval-source-map &amp;&amp; cheap-module-source-map &amp;&amp; cheap-module-eval-source-map作用：源码映射，报错时显示出错的位置。 source-map：会单独生成一个 sourcemap 文件；会显示行列。 eval-source-map：不会单独生成一个 sourcemap 文件，会将生成的 sourcemap 放到打包后的 html 文件；会显示行和列。 cheap-module-source-map：会生成 sourcemap 文件，不会显示列。 cheap-module-eval-source-map：不会生成 sourcemap 文件，集成在 html 文件中，不会显示列。 devtool: &quot;source-map&quot;, // 源码映射 watch作用：监控代码实时变化，进行编译打包。 watch: true, // 监控代码实时变化，进行编译打包 watchOptions: { poll: 1000, // 多毫秒监控一次 aggreatement: 500, // 防抖 ignored: &quot;node_modules&quot; // 忽略文件夹 }, resolve作用：解析第三方包 resolve: { // 解析 第三方包 modules: [ path.resolve(&quot;node_modules&quot;), // 在当前目录下查找模块 path.resolve(&quot;other_modules&quot;), // 在其他目录下查找模块 ], // 自动添加扩展名，主要是 import 时候使用, 依次解析 extensions: [&quot;.js&quot;, &quot;.css&quot;, &quot;.json&quot;, &quot;.vue&quot;], // 比如引用 bootstrap 的 css 样式 // 方式一： bootstrap 的主入口 mainFields: [&quot;style&quot;, &quot;main&quot;], // 方式二：别名 // alias: { // bootstrap: &quot;bootstrap/dist/css/bootstrap.css&quot; // } }, 插件webpack 的插件配置是一个数组，里面存放着各种各样的插件。 plugins: [ new pluginName(...) ] html-webpack-plugin插件作用：打包时候自动根据 html 模板生成目标 html 文件，自动生成目标打包目录；另外，可配置 html 的相关打包配置，如：压缩，去双引号等。 new HtmlWebpackPlugin({ filename: &quot;index.html&quot;, // 目标文件名称 template: path.resolve(__dirname + &#39;/src/template.html&#39;), // 模板文件 minify: { // 压缩配置 removeAttributeQuotes: true, // 去双引号 collapseWhitespace: true, // 不换行 }, hash: true // 生成 hash 戳 }) mini-css-extract-plugin作用：将生成的 css样式 抽离成一个 css文件，并将该样式文件引进目标 html 文件中。 plugins: [ // 插件 new MiniCssExtractPlugin({ filename: &quot;main.css&quot;, }) ], module: { // 模块 rules: [{ test: /\\.css$/, use: [ // { // loader: &quot;style-loader&quot;, // options: { // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // } // }, MiniCssExtractPlugin.loader, // 注意 loader 的使用顺序 &quot;css-loader&quot; ] }] } 注：这里抽离出来的 main.css 文件并没有压缩，要通过手动添加以下两个插件到优化项： optimize-css-assets-webpack-plugin uglifyjs-webpack-plugin optimization: { // 优化项 minimizer: [ new OptimizeCssAssetsWebpackPlugin({}), // 压缩抽离的 css 文件 new UglifyjsWebpackPlugin({ cache: true, parallel: true, }) // 使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置 ] }, optimize-css-assets-webpack-plugin插件作用：压缩抽离出来的 main.css 文件。但是，使用了 optimize-css-assets-webpack-plugin 插件后，原先的 js 压缩不起作用，要手动重新配置优化项 uglifyjs-webpack-plugin 。 uglifyjs-webpack-plugin插件作用：压缩打包后的 js 文件。 clean-webpack-plugin作用：清理文件 plugins: [ new CleanWebpackPlugin(&quot;./build&quot;) ] copy-webpack-plugin作用：将某些文件拷贝到打包后的文件夹。 new CopyWebpackPlugin([ {from: &quot;./copy&quot;, to: &quot;./&quot;} ]) banner-plugin作用：版权声明，是 webpack 的内置模块。 new webpack.BannerPlugin(&quot;@copyright by Ertsul&quot;) webpack.DefinePlugin({ … })作用：定义环境变量。 plugins: [ new webpack.DefinePlugin({ DEV: JSON.stringify(&quot;development&quot;), PRO: JSON.stringify(&quot;production&quot;) }) ] webpacfk.IgnorePlugin()作用：忽略模块的引进 plugins: [ new webpack.IgnorePlugin(/\\./locale/, /moment/) ] 注：如果直接使用 DEV: ‘development’ 的话，会把 DEV 直接替换为 引号内部的内容。如：console.log(DEV)，会变成 console.log(dev)，最后的结果是 undefined。所以，需要通过 JSON.stringfy() 进行转化。 模块 module模块主要是各种 loader，作用：解析各种类型的文件。 module: { rules: [ { test: regx, use: [loadName] } ] } css-loader / style-loader css-loader：主要是用于解析在 css 文件中通过 @import 方式引进其他的 css 文件。 style-loader: 主要是用于将 js 文件中通过 require 方式引进的 css 文件插入到目标 html 文件的 head 中（插到最后，层级最高）。 // 数组方式 module: { // 模块 rules: [{ test: /\\.css$/, // 正则 use: [&quot;style-loader&quot;, &quot;css-loader&quot;] // loader 数组 }] } // 对象方式 module: { // 模块 rules: [{ test: /\\.css$/, // 正则 use: [ { loader: &quot;style-loader&quot;, options: { insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 } }, &quot;css-loader&quot; ] }] } 注：loader 是从右向左、从下到上的执行顺序，故：use: [“style-loader”, “css-loader”] postcss-loader + autoprefixer这两个的配合使用可以自动添加 css 的浏览器前缀。 autoprefixer：自动添加 css 的浏览器前缀。 postcss-loader：loader 处理 autoprefixer。 // 使用 postcss-loader module: { // 模块 rules: [{ test: /\\.css$/, use: [ // { // loader: &quot;style-loader&quot;, // options: { // insertAt: &quot;top&quot; // 插到 head 标签的顶部，更改优先级 // } // }, MiniCssExtractPlugin.loader, &quot;css-loader&quot;, &quot;postcss-loader&quot; // 注意顺序 ] }] } 根目录下新建 postcss.config.js 文件 module.exports = { plugins: [ require(&quot;autoprefixer&quot;) ] } babel-loader + @babel/core + @babel/preset-env作用：转化 es6 语法 module: { // 模块 rules: [{ test: /\\.js$/, use: { loader: &quot;babel-loader&quot;, options: { // 用 babel-loader 需要把 es6 转化为 es5 presets: [ &quot;@babel/preset-env&quot;, // 转化 js 语法，一个大的 babel 库，包含将 es6 转化为 es5 的模块 ], // plugins: [...] // 其他的小插件 } } }] } expose-loader作用：暴露全局的 loader，暴露到 window 上。 // 一般情况 import $ from &#39;jquery&#39;; console.log(window.$); // undefined // 内联 loader 方式 import $ from &#39;expose-loader?$!jquery&#39;; console.log(window.$); // 其他方式：在每个模块中注入 new webpack.ProvidePlugin({ $: &quot;jquery&quot; }) console.log($); console.log(window.$); // undefined file-loader &amp;&amp; url-loader &amp;&amp; html-withimg-loader在 webpack 项目中不能直接使用相对路径的方式调用图片，不然打包后的图片路径会报错。 file-loader：js 文件中通过 import 方式引进图片。 html-withimg-loader：html 文件中通过 scr 方式引进图片。 在 css 中使用图片，style-loader 已经做了处理。 url-loader：将图片转化为 base64 module: { rules: [ { test: /\\.(png|jpg|gif)$/, use: { loader: &quot;url-loader&quot;, options: { limit: 200 * 1024, // 图片小于 200k，变成 base64，否则用 file-loader // publicPath: &quot;http://&quot;, // 公共路径前缀 } } }, { test: /\\.html$/, use: [&quot;html-withimg-loader&quot;] } ] } ` 模块 module – noParse作用：不解析指定包的依赖关系。 module: { noParse: /jquery/ } 模块 module – exclude作用：排除 module: { exclude: /node_module/ } 模块 module – include作用：包含 module: { include: /src/ } 区分不同环境，实现开发和生产配置的分离将 webpack 的配置文件划分为以下文件： webpack.base.js：基本、共有的配置。 webpack.dev.js：开发配置。 webpack.prod.js：生产配置。 使用 webpack-merger 插件： 安装 webpack-merge 插件； 引进目标模块 import { smart } from &quot;webpack-merge&quot;; 使用 const base = require(&quot;webpack.base.js); module.exports = smart(base, { ... }) webpack 自带优化 import 语法（生成环境），tree-shaking 自动删除没有用到的代码； es6 模块会把语法放到 default 上； 自动省略可以简化的代码； scope hosting，作用域提升。 webpack 懒加载 通过 import 实现（该语法内部由 jsonp 实现），返回的是一个 promise。 要在 babel-loader 中添加 @babel/plugin-syntax-dynamic-import 插件。 vue 和 react 的l懒加载都是这样实现的。 /* * 模拟点击加载 source.js 的内容 */ // 1 { loader: &#39;babel-loader&#39;, options: { presets: [ &#39;@babel/preset-env&#39; ], plugins: [ &#39;@babel/plugin-syntax-dynamic-import&#39; ] }, } // 2 let btn = document.createElement(&#39;button&#39;); btn.innerHTML = &#39;btn&#39;; btn.addEventListener(&#39;click&#39;, function () { // 内部由 jsonp 实现动态加载文件 import(&#39;./source.js&#39;) .then(data =&gt; { console.log(data); }) }) document.body.appendChild(btn); 点击按钮后结果如下： 热更新 / 热替换 / Hot Module Replacement / HMR热更新：页面只更新改动的模块。 devServer 开始 hot 热更新模块。 使用 webpack 内置热更新插件。 NamedModulesPlugin HotModuleReplacementPlugin // devServer 配置 devServer: { port: 8089, contentBase: path.resolve(__dirname + &#39;/dist/&#39;), compress: true, progress: true, // open: true hot: true, // 开启热更新，只更新更改的模块 }, // 添加插件 plugins: [ new webpack.NamedModulesPlugin(), // 热更新打印更新的模块路径 new webpack.HotModuleReplacementPlugin(), // 热更新 ] 使用热更新 import source from &#39;./source.js&#39;; console.log(source); // 添加热更新操作，不然不会实现热更新 if (module.hot) { module.hot.accept(&#39;./source.js&#39;, () =&gt; { require(&#39;./source.js&#39;); }) 多线程打包使用 happypack 可以实现多线程打包。 安装并引进 happypack; 改写 module; plugin 配置。 // 改写 module module: { rules: [ { test: /\\.js$/, // use: { // loader: &#39;babel-loader&#39;, // options: { // presets: [ // &#39;@babel/preset-env&#39; // ] // } // } use: { loader: &#39;Happypack/loader?id=js&#39;, } }, ] } // plugin 配置 plugins: [ new Happypack({ id: &#39;js&#39;, use: [ { loader: &#39;babel-loader&#39;, options: { presets: [ &#39;@babel/preset-env&#39; ] } } ] }), ] 多页面打包const path = require(&quot;path&quot;); const HtmlWebpackPlugin = require(&quot;html-webpack-plugin&quot;); module.exports = { mode: &quot;production&quot;, entry: { home: &quot;./src/home.js&quot;, about: &quot;./src/about.js&quot;, other: &quot;./src/other.js&quot; }, output: { path: path.resolve(__dirname + &quot;/build/&quot;), filename: &quot;[name].js&quot;, }, plugins: [ new HtmlWebpackPlugin({ template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;home.html&quot;, chunks: [&quot;home&quot;] }), new HtmlWebpackPlugin({ template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;other.html&quot;, chunks: [&quot;other&quot;] }), new HtmlWebpackPlugin({ template: path.resolve(__dirname + &quot;/src/template.html&quot;), filename: &quot;about.html&quot;, chunks: [&quot;about&quot;] }), ] } 多页面打包抽离公共代码块打包 多页面 需要将公共的代码块抽离出来进行优化： optimation: { splitChunks: { // 分割代码块 cacheGroups: { // 缓存组 common: { // 公共的模块 chunks: &#39;initial&#39;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 }, vender: { // 第三方模块 priority: 1, // 设置权重，没有设置权重的话，代码默认从上到下执行，上面的公共代码会先将第三方模块抽离出来，达不到抽离第三方模块的作用 test: /node_modules/, // 抽离出来 chunks: &#39;initial&#39;, // 从哪里开始，initial 即：入口 miniSize: 0, // 大小大于多少字节的时候抽离 miniChunks: 2 // 引用多少次的时候抽离 } } } } Tapablewebpack 本质是事件流的机制，工作流程就是将各个插件串联起来，实现核心就是 Tapable，通过 Tapable 实现各种钩子（如同步钩子异步钩子）。而 Tapable 核心是依赖于 发布订阅者模式。 同步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tap 注册。 使用： const { SyncHook } = require(&#39;tapable&#39;); class Hook { constructor() { this.hooks = { arch: new SyncHook([&#39;name&#39;]) } } tap() { // 注册监听事件 this.hooks.arch.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); }) this.hooks.arch.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) } start() { // 开始 this.hooks.arch.call(&#39;Ertsul&#39;) } } let h = new Hook(); h.tap(); h.start(); 异步钩子基本思路（发布订阅者模式）：将所有注册的函数存放到一个任务数组，发布的时候所有订阅者都会执行。使用 tapAsync 注册。 setTimeout()方式使用： const { AsyncParallelHook } = require(&#39;tapable&#39;); class AsyncHook { constructor() { this.hooks = { arch: new AsyncParallelHook([&#39;name&#39;]) } } tap() { this.hooks.arch.tapAsync(&#39;vue&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); cb &amp;&amp; cb(); }, 1000) }) this.hooks.arch.tapAsync(&#39;react&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); cb &amp;&amp; cb(); }, 1000) }) } start() { this.hooks.arch.callAsync(&#39;Ertsul&#39;, () =&gt; { console.log(&#39;All finished!&#39;); }) } } const a = new AsyncHook(); a.tap(); a.start(); Promise()方式使用： const { AsyncParallelHook } = require(&#39;tapable&#39;); class AsyncHook { constructor() { this.hooks = { arch: new AsyncParallelHook([&#39;name&#39;]) } } tap() { this.hooks.arch.tapPromise(&#39;vue&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); resolve(); }, 1000) }) }) this.hooks.arch.tapPromise(&#39;react&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); resolve(); }, 1000) }) }) } start() { this.hooks.arch.promise(&#39;Ertsul&#39;).then(() =&gt; { console.log(&#39;hook all finished!&#39;); }) } } const a = new AsyncHook(); a.tap(); a.start(); Synchook 同步钩子实现： class Synchook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tap(name, task) { // 注册事件 this.tasks.push(task); } call(...args) { // 发布事件 this.tasks.forEach(task =&gt; { task(...args); }) } } let hook = new Synchook([&#39;Synchook&#39;]); hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); }) hook.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) hook.call(&#39;Ertsul&#39;); SyncBailHook 同步熔断钩子Synchook 同步钩子在执行每个函数的时候会有一个返回值，undefined：执行成功，继续执行下一个函数，!= undefined：熔断执行，不执行下一个函数。 实现： // Syncbailhook 同步熔断执行，会判断返回是否等于 undefined 来执行下一个函数 class Syncbailhook { constructor(args) { this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { let ret = &#39;&#39;; // 当前函数的返回值 let index = 0; // 当前任务数组的索引 do { ret = this.tasks[index++](...args); } while (ret === undefined &amp;&amp; index &lt; this.tasks.length) } } let hook = new Syncbailhook([&#39;Syncbailhook&#39;]); hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); }) hook.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) hook.call(&#39;Ertsul&#39;); SyncWaterfallHook 同步瀑布钩子Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系，上一个函数的执行返回结果在当前函数的输入。 实现： /** * Syncwaterfallhook 同步瀑布执行，各个函数之间存在关系 * 上一个函数的执行返回结果在当前函数的输入 */ class Syncwaterfallhook { constructor(args) { this.tasks = []; } tap(name, task) { this.tasks.push(task); } call(...args) { let [first, ...others] = this.tasks; let ret = first(...args); others.reduce((prev, current) =&gt; { return current(prev); }, ret) } } let hook = new Syncwaterfallhook([&#39;Syncwaterfallhook&#39;]); hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); return &#39;vue learnt&#39;; }) hook.tap(&#39;react&#39;, (data) =&gt; { console.log(&#39;react&#39;, data); }) hook.call(&#39;Ertsul&#39;); SyncLoopHook 同步循环钩子同步循环钩子回让某个函数执行一定的次数。 实现： // Tapable Syncloophook 同步循环钩子 class Syncloophook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tap(name, task) { // 注册事件 this.tasks.push(task); } call(...args) { // 发布事件 this.tasks.forEach(task =&gt; { let ret = &#39;&#39;; do { ret = task(...args); } while (ret != undefined); }) } } let hook = new Syncloophook([&#39;Syncloophook&#39;]); const total = 3; let index = 0; hook.tap(&#39;vue&#39;, (name) =&gt; { console.log(&#39;vue&#39;, name); return ++index === total ? undefined : &#39;continue&#39;; }) hook.tap(&#39;react&#39;, (name) =&gt; { console.log(&#39;react&#39;, name); }) hook.call(&#39;Ertsul&#39;); AsyncParallelHook 异步并发钩子 回调函数方式实现： // Tapable Asynchook 异步钩子 class asyncparallelhook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tapAsync(name, task) { // 注册事件 this.tasks.push(task); } callAsync(...args) { // 发布事件 let finalCallback = args.pop(); let index = 0; const done = () =&gt; { index++; if (index === this.tasks.length) { finalCallback(); } } this.tasks.forEach(task =&gt; { task(...args, done); }) } } let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]); hook.tapAsync(&#39;vue&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); cb &amp;&amp; cb(); }, 1000) }) hook.tapAsync(&#39;react&#39;, (name, cb) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); cb &amp;&amp; cb(); }, 1000) }) hook.callAsync(&#39;Ertsul&#39;, () =&gt; { console.log(&#39;All hook finished!&#39;); }); AsyncParallelHook 异步并发钩子 Promise方式实现： // Tapable Asynchook 异步钩子 class asyncparallelhook { constructor(args) { // args =&gt; [&#39;Synchook&#39;] this.tasks = []; // 注册事件数组 } tapPromise(name, task) { // 注册事件 this.tasks.push(task); } promise(...args) { // 发布事件 let tasks = this.tasks.map(task =&gt; task(...args)); return Promise.all(tasks); } } let hook = new asyncparallelhook([&#39;asyncparallelhook&#39;]); hook.tapPromise(&#39;vue&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;vue&#39;, name); resolve(); }, 1000) }) }) hook.tapPromise(&#39;react&#39;, (name) =&gt; { return new Promise((resolve, reject) =&gt; { setTimeout(() =&gt; { console.log(&#39;react&#39;, name); resolve(); }, 1000) }) }) hook.promise(&#39;Ertsul&#39;).then(() =&gt; { console.log(&#39;All hooks finished!&#39;); }) AsyncSeriesHook 异步串行钩子AsyncWaterfallHook 异步瀑布流钩子","categories":[],"tags":[{"name":"frontEnd","slug":"frontEnd","permalink":"https://ertsul.github.io/tags/frontEnd/"},{"name":"webpack","slug":"webpack","permalink":"https://ertsul.github.io/tags/webpack/"}]}]}